<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Ultimate Tic Tac Toe</title>
    <style>
      /* Styles globaux */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }
      /* Animation de rebond */
      @keyframes bounce {
        0%,
        20%,
        50%,
        80%,
        100% {
          transform: scale(1);
        }
        40% {
          transform: scale(1.2);
        }
        60% {
          transform: scale(0.9);
        }
      }
      .bounce {
        animation: bounce 0.5s;
      }
      /* Animation accentuÃ©e */
      @keyframes enhancedBounce {
        0%,
        20%,
        50%,
        80%,
        100% {
          transform: scale(1);
        }
        40% {
          transform: scale(1.4);
        }
        60% {
          transform: scale(0.8);
        }
      }
      .enhanced-bounce {
        animation: enhancedBounce 0.7s;
      }
      /* Animation d'entrÃ©e */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes fadeInLayout {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      /* Animation de sortie */
      @keyframes fadeOut {
        from {
          opacity: 1;
          transform: translateY(0);
        }
        to {
          opacity: 0;
          transform: translateY(-20px);
        }
      }
      @keyframes zoom {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
      .zoom {
        animation: zoom 1s infinite;
      }
      /* Animation d'entrÃ©e aux layouts */
      .rounded-button {
        border-radius: 1.5rem; /* Ajustez cette valeur selon vos besoins */
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      .mt-4 .flex .justify-center .gap-2 button {
        border-radius: 1.5rem;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      .modal-buttons button,
      .settings-modal-buttons button {
        border-radius: 1.5rem; /* Ajoutez cette ligne pour arrondir les coins */
        width: 50%;
      }
      .fade-in {
        animation: fadeIn 0.5s ease-in-out;
      }
      .lobby-button {
        border-radius: 1.5rem;
        padding: 0.85rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        font-size: 1.125rem;
        font-weight: 500;
        width: 90%;
        margin: 0 auto; /* Cela aide Ã  centrer les boutons */
        transition: transform 0.2s, background-color 0.2s;
      }
      .lobby-button:hover {
        transform: scale(1.02);
      }
      .separator {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 24px 0; /* Ajoute de l'espace vertical autour du sÃ©parateur */
        width: 100%;
      }
      .separator-line-light {
        border: 0;
        height: 2px;
        background: #000000;
        margin: 0 auto;
        width: 90%;
        opacity: 1;
      }
      .separator-line {
        flex-grow: 1;
        height: 2px; /* Ã‰paisseur de la ligne */
        background-color: #000; /* Couleur de la ligne */
        margin: 0 16px; /* Ajoute de l'espace horizontal entre la ligne et le texte */
      }
      .separator-text {
        font-weight: bold;
        margin: 0 8px;
        white-space: nowrap; /* EmpÃªche le texte de passer Ã  la ligne suivante */
        font-size: 1.1rem; /* Taille de police fixe pour s'assurer qu'elle est visible */
      }
      .dark .separator-line {
        background-color: white;
      }
      .lobby-view,
      .game-view,
      .rules-view,
      .credits-view {
        animation: fadeInLayout 0.3s ease-in-out;
      }
      /* Animation de sortie aux layouts */
      .lobby-view.exit,
      .game-view.exit,
      .rules-view.exit,
      .credits-view.exit {
        animation: fadeOut 0.3s ease-in-out;
      }
      /* Animation d'entrÃ©e aux messages */
      .tooltip,
      .modal-content {
        animation: fadeIn 0.3s ease-in-out;
      }
      /* Animation de sortie aux messages */
      .tooltip.exit,
      .modal-content.exit {
        animation: fadeOut 0.3s ease-in-out;
      }
      /* Animation pour le modal de paramÃ¨tres */
      .settings-modal-overlay {
        animation: fadeIn 0.3s ease-in-out;
      }
      .settings-modal-overlay.exit {
        animation: fadeOut 0.3s ease-in-out;
      }
      .settings-modal-content {
        animation: fadeIn 0.3s ease-in-out;
      }
      .settings-modal-content.exit {
        animation: fadeOut 0.3s ease-in-out;
      }
      /* Transition pour le changement de thÃ¨me */
      body,
      div,
      button,
      p,
      h1,
      h2,
      footer {
        transition: background-color 0.3s, color 0.3s, border-color 0.3s;
      }
      /* Effet de survol pour les cases valides */
      .cell.valid {
        cursor: pointer;
        transition: transform 0.2s, background-color 0.2s;
      }
      .cell.valid:hover {
        transform: scale(1.13);
        background-color: #dbeafe;
      }
      /* Assurez-vous que l'effet est visible en mode sombre */
      .dark .cell.valid:hover {
        background-color: #4b5563;
      }
      /* Ajoutez ce style pour la modal de paramÃ¨tres */
      .settings-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .settings-modal-content {
        border-radius: 0.5rem;
        max-width: 384px;
        width: 100%;
        padding: 24px;
      }
      .settings-modal-header {
        text-align: center;
        margin-bottom: 24px;
      }
      .settings-modal-buttons {
        display: flex;
        gap: 12px;
      }
      .header-responsive {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        position: relative;
      }
      .title-responsive {
        text-align: center;
      }
      /* Conteneurs principaux */
      .container {
        width: 100%;
        max-width: 512px;
        margin: 0 auto;
        padding: 0 16px;
      }
      .min-h-screen {
        min-height: 100vh;
        padding: 32px 16px;
      }
      /* Light mode */
      .bg-gray-100 {
        background-color: #f3f4f6;
      }
      .bg-white {
        background-color: #ffffff;
      }
      .text-gray-900 {
        color: #111827;
      }
      .text-gray-600 {
        color: #4b5563;
      }
      .border-gray-300 {
        border-color: #9ca3af; 
      }
      .bg-gray-200 {
        background-color: #e5e7eb;
      }
      .text-gray-800 {
        color: #1f2937;
      }
      .hover\:bg-gray-300:hover {
        background-color: #d1d5db;
      }
      .bg-blue-100 {
        background-color: #dbeafe;
      }
      .bg-red-200 {
        background-color: #fecaca;
      }
      .bg-blue-200 {
        background-color: #bfdbfe;
      }
      .ring-yellow-400 {
        box-shadow: 0 0 0 4px #fbbf24;
      }
      .text-gray-500 {
        color: #6b7280;
      }
      /* Theme classes - Dark mode */
      body.dark {
        background-color: #111827;
      }
      .dark .bg-gray-900 {
        background-color: #111827;
      }
      .dark .bg-gray-800 {
        background-color: #1f2937;
      }
      .dark .text-white {
        color: #ffffff;
      }
      .dark .text-gray-300 {
        color: #d1d5db;
      }
      .dark .border-gray-700 {
        border-color: #374151;
      }
      .dark .bg-gray-700 {
        background-color: #374151;
      }
      .dark .bg-blue-900 {
        background-color: #1e3a8a;
      }
      .dark .text-gray-200 {
        color: #e5e7eb;
      }
      .dark .hover\:bg-gray-600:hover {
        background-color: #4b5563;
      }
      .dark .bg-gray-600 {
        background-color: #4b5563;
      }
      .dark .bg-red-900 {
        background-color: #7f1d1d;
      }
      .dark .ring-yellow-500 {
        box-shadow: 0 0 0 4px #f59e0b;
      }
      .dark .text-gray-400 {
        color: #9ca3af;
      }
      /* Common button styles */
      .difficulty-selector {
        margin-bottom: 16px;
        text-align: center;
        border-radius: 1.5rem;
      }
      .difficulty-selector label {
        margin-right: 8px;
        font-weight: bold;
        border-radius: 1.5rem;
      }
      .difficulty-dropdown {
        padding: 8px;
        border-radius: 7px;
        border: 2px solid #10b981; 
        background-color: #fff;
        color: #333;
        font-size: 16px;
      }
      .difficulty-dropdown:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
      }
      button {
        cursor: pointer;
        font-weight: 500;
        border: none;
        border-radius: 0.375rem;
      }
      .bg-blue-500 {
        background-color: #3b82f6;
        color: white;
        border-radius: 1.5rem; 
      }
      .hover\:bg-blue-600:hover {
        background-color: #2563eb;
      }
      .bg-gray-500 {
        background-color: #6b7280;
        color: white;
      }
      .hover\:bg-gray-600:hover {
        background-color: #4b5563;
      }
      .bg-purple-500 {
        background-color: #8b5cf6;
        color: white;
      }
      .hover\:bg-purple-600:hover {
        background-color: #7c3aed;
      }
      .bg-green-500 {
        background-color: #10b981;
        color: white;
      }
      .hover\:bg-green-600:hover {
        background-color: #059669;
      }
      .hover\:bg-yellow-400:hover {
        background-color: #facc15;
      }
      .hover\:bg-emerald-600:hover {
        background-color: #84cc16;
      }
      /* Layout */
      .flex {
        display: flex;
      }
      .flex-col {
        flex-direction: column;
      }
      .items-center {
        align-items: center;
      }
      .justify-center {
        justify-content: center;
      }
      .justify-between {
        justify-content: space-between;
      }
      .gap-2 {
        gap: 8px;
      }
      .gap-3 {
        gap: 12px;
      }
      .gap-4 {
        gap: 16px;
      }
      .mt-4 {
        margin-top: 16px;
      }
      .mt-6 {
        margin-top: 24px;
      }
      .mt-8 {
        margin-top: 32px;
      }
      .mb-2 {
        margin-bottom: 8px;
      }
      .mb-4 {
        margin-bottom: 16px;
      }
      .mb-6 {
        margin-bottom: 24px;
      }
      .p-2 {
        padding: 8px;
      }
      .p-4 {
        padding: 16px;
      }
      .p-6 {
        padding: 24px;
      }
      .px-4 {
        padding-left: 16px;
        padding-right: 16px;
      }
      .py-2 {
        padding-top: 8px;
        padding-bottom: 8px;
      }
      .py-3 {
        padding-top: 12px;
        padding-bottom: 12px;
      }
      .pt-4 {
        padding-top: 16px;
      }
      .rounded {
        border-radius: 0.25rem;
      }
      .rounded-lg {
        border-radius: 0.5rem;
      }
      .rounded-full {
        border-radius: 9999px;
      }
      .border {
        border-width: 1px;
        border-style: solid;
      }
      .border-t {
        border-top-width: 1px;
        border-top-style: solid;
      }
      .border-2 {
        border-width: 2px;
        border-style: solid;
      }
      .shadow-lg {
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      .shadow-xl {
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
      }
      .w-full {
        width: 100%;
      }
      .max-w-sm {
        max-width: 384px;
      }
      .max-w-md {
        max-width: 448px;
      }
      .max-w-lg {
        max-width: 512px;
      }
      .space-y-4 > * + * {
        margin-top: 16px;
      }
      .flex-1 {
        flex: 1 1 0%;
      }
      /* Texte */
      .text-center {
        text-align: center;
      }
      .text-sm {
        font-size: 0.875rem;
      }
      .text-lg {
        font-size: 1.125rem;
      }
      .text-xl {
        font-size: 1.25rem;
      }
      .text-2xl {
        font-size: 1.5rem;
      }
      .text-3xl {
        font-size: 1.875rem;
      }
      .text-4xl {
        font-size: 2.25rem;
      }
      .text-5xl {
        font-size: 3rem;
      }
      .font-medium {
        font-weight: 500;
      }
      .font-semibold {
        font-weight: 600;
      }
      .font-bold {
        font-weight: 700;
      }
      .text-red-500 {
        color: #ef4444;
      }
      .text-blue-500 {
        color: #3b82f6;
      }
      .turn-text {
        color: #1f2937;
      }
      .dark .turn-text {
        color: #ffffff;
      }
      /* Styles pour le sÃ©lecteur de langue */
      .language-selector {
        margin-bottom: 16px;
        text-align: center;
      }
      .language-dropdown {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
        background-color: #fff;
        color: #333;
        font-size: 16px;
      }
      .language-dropdown:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
      }
      @media (max-width: 512px) {
        .game-board {
          gap: 8px;
          padding: 8px;
        }
        .cell {
          width: 31px;
          height: 31px;
          font-size: 0.95rem;
          aspect-ratio: 1 / 1;
          border-radius: 3px;
        }
        .small-board {
          gap: 1px;
          padding: 1px;
          display: grid;
          grid-template-columns: repeat(3, 1fr);
        }
        .header-responsive {
          flex-direction: column;
          align-items: fixed;
        }
        .title-responsive {
          width: 70%;
          text-align: center;
          margin-top: 10px;
        }
        .text-3xl {
          font-size: 1.5rem;
        }
        .game-info-header {
          margin-bottom: 12px;
        }
        .modal-buttons {
          gap: 8px;
        }
      }
      @media (max-width: 360px) {
        .cell {
          aspect-ratio: 1 / 1;
          min-width: 18px;
          font-size: 0.75rem;
        }
        .game-board {
          gap: 4px;
          padding: 4px;
        }
        .title-responsive {
          width: 70%;
          text-align: center;
        }
      }
      @media (max-width: 400px) {
        .game-board {
          gap: 6px;
          padding: 6px;
        }
        .cell {
          width: auto;
          height: auto;
          aspect-ratio: 1 / 1;
          min-width: 20px;
          font-size: 0.875rem;
        }
        .small-board {
          gap: 0px;
          padding: 1px;
        }
        .button-grid {
          grid-template-columns: 1fr;
        }
        .modal-buttons,
        .settings-modal-buttons {
          flex-direction: column;
          align-items: center;
        }

        .modal-buttons button,
        .settings-modal-buttons button {
          width: 100%;
          max-width: none;
          margin-bottom: 10px;
        }
        .title-responsive {
          width: 70%;
          text-align: center;
        }
      }
      /* Game board styles */
      .game-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 16px;
        padding: 16px;
        max-width: 512px;
        margin: 0 auto;
        border-radius: 0.5rem;
        border: 2px solid;
        aspect-ratio: 1 / 1; 
      }
      .small-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 2px;
        border: 1px solid;
        border-radius: 0.25rem;
        padding: 2px;
        position: relative;
        overflow: hidden;
        aspect-ratio: 1 / 1; 
      }
      .small-board.active {
        transform: scale(1.03);
      }
      .small-board.won-x {
        background-color: #fecaca;
      }
      .dark .small-board.won-x {
        background-color: #7f1d1d;
      }
      .small-board.won-o {
        background-color: #bfdbfe;
      }
      .dark .small-board.won-o {
        background-color: #1e3a8a;
      }
      .small-board.draw {
        opacity: 0.5;
      }
      .cell {
        box-sizing: border-box;
        overflow: hidden;
        aspect-ratio: 1 / 1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        border-radius: 3px;
        border: 0.5px solid rgba(0, 0, 0, 0.12);
        justify-content: center;
      }
      .cell.valid {
        cursor: pointer;
      }
      .winner-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.25rem;
        font-weight: bold;
      }
      @media (min-width: 768px) {
        .cell {
          width: 40px;
          height: 40px;
        }
        .grid-cols-2 {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 12px;
        }
        .title-responsive {
          width: 70%;
          text-align: center;
        }
      }
      /* Game views */
      .game-view,
      .lobby-view,
      .rules-view,
      .credits-view {
        border-radius: 0.5rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3),
          0 10px 10px -5px rgba(0, 0, 0, 0.1);
        padding: 24px;
        margin: 0 auto;
      }
      /* Game info section */
      .game-info {
        margin-bottom: 24px;
        text-align: center;
      }
      .game-info-header {
        position: relative;
        margin-bottom: 16px;
        text-align: center;
      }
      .player-info {
        display: flex;
        justify-content: center;
        gap: 16px;
        margin-bottom: 8px;
      }
      .player-box {
        padding: 8px 16px;
        border-radius: 0.5rem;
      }
      /* Modal styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .modal-content {
        border-radius: 0.5rem;
        max-width: 384px;
        width: 100%;
        padding: 24px;
      }
      .modal-header {
        text-align: center;
        margin-bottom: 24px;
      }
      .modal-buttons {
        display: flex;
        gap: 12px;
      }
      /* Tooltip */
      .tooltip {
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        background-color: black;
        color: white;
        padding: 8px 16px;
        border-radius: 0.25rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        opacity: 0.9;
        z-index: 50;
        display: none;
      }
      /* Utilities for positioning */
      .relative {
        position: relative;
      }
      .absolute {
        position: absolute;
      }
      .right-0 {
        right: 0;
      }
      .top-0 {
        top: 0;
      }
      /* Footer glitchÃ© */
      footer {
        position: fixed;
        bottom: 0;
        width: 100%;
        color: white;
        text-align: center;
        padding: 10px 0;
        font-size: 0.875rem;
        z-index: 100;
      }
      /* Button layouts */
      .button-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      @media (min-width: 768px) {
        .button-grid {
          grid-template-columns: 1fr 1fr;
        }
      }
      @keyframes blink {
        0%,
        100% {
          opacity: 0;
        }
        50% {
          opacity: 1;
        }
      }
      .thinking-dots {
        display: inline-block;
        font-size: 24px;
        margin: 10px;
      }
      .thinking-dots span {
        display: inline-block;
        opacity: 0;
        animation: blink 1.4s infinite both;
      }
      .thinking-dots span:nth-child(1) {
        animation-delay: 0.2s;
      }
      .thinking-dots span:nth-child(2) {
        animation-delay: 0.4s;
      }
      .thinking-dots span:nth-child(3) {
        animation-delay: 0.6s;
      }
      .turn-indicator {
        display: inline-block;
        min-width: 120px;
        text-align: center;
      }
      .difficulty-selector-ar {
        display: flex;
        flex-direction: row-reverse;
        justify-content: center;
        align-items: center;
        margin-bottom: 16px;
      }
      .difficulty-selector-ar label {
        margin-left: 8px;
        font-weight: bold;
      }
    </style>
  </head>
  <body class="bg-gray-100">
    <div id="app" class="min-h-screen">
      <div class="container"></div>
      <footer class="text-gray-500">Ultimate Tic Tac Toe Â© 2025</footer>
    </div>
    <div id="tooltip" class="tooltip"></div>
    <script>
      // Ajoutez les traductions
      const translations = {
        en: {
          info: "Info",
          level: "level",
          title: "Ultimate Tic Tac Toe",
          playAgainstAI: "Play against AI",
          localMultiplayer: "Local Multiplayer",
          timedMode: "Timed Mode",
          gameRules: "Game Rules",
          settings: "Settings",
          credits: "Credits",
          creditsTitle: "Contributors ğŸ‘·â€â™‚ï¸",
          difficulty: "Difficulty",
          close: "Close",
          continue: "Continue",
          newGame: "New Game",
          backToLobby: "Back to Lobby",
          language: "Language",
          easy: "Easy",
          normal: "Normal",
          difficult: "Difficult",
          youArePlayingAs: "You are playing as",
          youGoFirst: "You go first!",
          aiGoesFirst: "AI goes first!",
          youWon: "You won.",
          aiWon: "AI won.",
          playerWon: "Player won.",
          gameEndedInDraw: "The game ended in a draw.",
          playerXRanOutOfTime: "Player X ran out of time. Player O wins!",
          playerORanOutOfTime: "Player O ran out of time. Player X wins!",
          playerXWon: "Player X won.",
          playerOWon: "Player O won.",
          gameOver: "Game Over",
          theGameIsAlreadyOver: "The game is already over!",
          youMustPlayInTheIndicatedGrid: "You must play in the indicated grid!",
          thisGridIsAlreadyWon: "This grid is already won!",
          thisCellIsAlreadyTaken: "This cell is already taken!",
          difficultyChangedTo: "Difficulty changed to",
          difficultyNames: {
            1: "Easy",
            4: "Normal",
            8: "Difficult",
          },
          yourTurn: "Your turn",
          aiIsThinking: "AI is thinking",
          rule1:
            "Ultimate Tic Tac Toe is made up of 9 smaller Tic Tac Toe boards arranged in a big 3x3 grid.",
          rule2:
            "You must play in the small board that matches where your opponent last played.",
          rule3:
            "Example: If your opponent plays in the top-right cell, you must play in the top-right grid.",
          rule4:
            "If you're sent to a board that's already won or full, you can play anywhere.",
          rule5:
            "Win a small board by getting three in a row, just like regular Tic Tac Toe.",
          rule6: "Win the game by aligning three grids.",
          youDefeatedTheAI: "You defeated the AI at",
          theAIWon: "The AI won at",
          developer: "Developer",
          translator: "Translator",
          betaTesters: "Beta Testers",
          backToSettings: "Back to Settings",
          translatorCredits:
      "- German: BarthÃ©lÃ©my<br>- English: BarthÃ©lÃ©my<br>- Spanish: Alexandre<br>- Basque: Eneko<br>- Italian: Alberico<br>- Swedish: Anton<br>- Russian: Louise<br>- Ukrainian: Louise<br>- Arabic: Roudy<br>- Japanese: Antonin<br>- French: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        fr: {
          info: "Info",
          level: "niveau",
          title: "Morpion Ultime",
          playAgainstAI: "Jouer contre l'IA",
          localMultiplayer: "Multijoueur Local",
          timedMode: "Mode ChronomÃ©trÃ©",
          gameRules: "RÃ¨gles du Jeu",
          settings: "ParamÃ¨tres",
          credits: "CrÃ©dits",
          creditsTitle: "Contributeurs ğŸ‘·â€â™‚ï¸",
          difficulty: "DifficultÃ©",
          close: "Fermer",
          continue: "Continuer",
          newGame: "Nouvelle Partie",
          backToLobby: "Retour au Lobby",
          language: "Langue",
          easy: "Facile",
          normal: "Normal",
          difficult: "Difficile",
          youArePlayingAs: "Vous jouez en tant que",
          youGoFirst: "Vous commencez!",
          aiGoesFirst: "L'IA commence!",
          youWon: "Vous avez gagnÃ©.",
          aiWon: "L'IA a gagnÃ©.",
          playerWon: "Le joueur a gagnÃ©.",
          gameEndedInDraw: "La partie s'est terminÃ©e par un match nul.",
          playerXRanOutOfTime:
            "Le joueur X a manquÃ© de temps. Le joueur O gagne!",
          playerORanOutOfTime:
            "Le joueur O a manquÃ© de temps. Le joueur X gagne!",
          playerXWon: "Le joueur X a gagnÃ©.",
          playerOWon: "Le joueur O a gagnÃ©.",
          gameOver: "Fin de la partie",
          theGameIsAlreadyOver: "La partie est dÃ©jÃ  terminÃ©e!",
          youMustPlayInTheIndicatedGrid:
            "Vous devez jouer dans la grille indiquÃ©e!",
          thisGridIsAlreadyWon: "Cette grille est dÃ©jÃ  gagnÃ©e!",
          thisCellIsAlreadyTaken: "Cette cellule est dÃ©jÃ  prise!",
          difficultyChangedTo: "DifficultÃ© changÃ©e en",
          difficultyNames: {
            1: "Facile",
            4: "Normal",
            8: "Difficile",
          },
          yourTurn: "Votre tour",
          aiIsThinking: "L'IA rÃ©flÃ©chit",
          rule1:
            "Le Morpion Ultime est composÃ© de 9 grilles de Morpion disposÃ©es en une grande grille 3x3.",
          rule2:
            "Vous devez jouer dans la grille correspondant Ã  la derniÃ¨re case jouÃ©e par votre adversaire.",
          rule3:
            "Exemple: Si votre adversaire joue dans la case en haut Ã  droite, vous devez jouer dans la grille en haut Ã  droite.",
          rule4:
            "Si vous Ãªtes dirigÃ© vers une grille dÃ©jÃ  gagnÃ©e ou pleine, vous pouvez jouer n'importe oÃ¹.",
          rule5:
            "Gagnez une petite grille en alignant trois symboles, comme au Morpion classique.",
          rule6: "Gagnez la partie en alignant trois grilles.",
          youDefeatedTheAI: "Vous avez battu l'IA au",
          theAIWon: "L'IA a gagnÃ© au",
          developer: "DÃ©veloppeur",
          translator: "Traducteur",
          betaTesters: "BÃªta Testeurs",
          backToSettings: "Retour aux ParamÃ¨tres",
          translatorCredits:
      "- Allemand: BarthÃ©lÃ©my<br>- Anglais: BarthÃ©lÃ©my<br>- Espagnol: Alexandre<br>- Basque: Eneko<br>- Italien: Alberico<br>- SuÃ©dois: Anton<br>- Russe: Louise<br>- Ukrainien: Louise<br>- Arabe: Roudy<br>- Japonais: Antonin<br>- FranÃ§ais: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        de: {
          info: "Info",
          level: "Stufe",
          title: "Ultimatives Tic Tac Toe",
          playAgainstAI: "Gegen KI spielen",
          localMultiplayer: "Lokaler Mehrspieler",
          timedMode: "Zeitmodus",
          gameRules: "Spielregeln",
          settings: "Einstellungen",
          credits: "Mitwirkende",
          creditsTitle: "Mitwirkende ğŸ‘·â€â™‚ï¸",
          difficulty: "Schwierigkeit",
          close: "SchlieÃŸen",
          continue: "Fortsetzen",
          newGame: "Neues Spiel",
          backToLobby: "ZurÃ¼ck zur Lobby",
          language: "Sprache",
          easy: "Einfach",
          normal: "Normal",
          difficult: "Schwierig",
          youArePlayingAs: "Sie spielen als",
          youGoFirst: "Sie beginnen!",
          aiGoesFirst: "Die KI beginnt!",
          youWon: "Sie haben gewonnen.",
          aiWon: "Die KI hat gewonnen.",
          playerWon: "Der Spieler hat gewonnen.",
          gameEndedInDraw: "Das Spiel endete unentschieden.",
          playerXRanOutOfTime:
            "Spieler X hat keine Zeit mehr. Spieler O gewinnt!",
          playerORanOutOfTime:
            "Spieler O hat keine Zeit mehr. Spieler X gewinnt!",
          playerXWon: "Spieler X hat gewonnen.",
          playerOWon: "Spieler O hat gewonnen.",
          gameOver: "Spiel vorbei",
          theGameIsAlreadyOver: "Das Spiel ist bereits vorbei!",
          youMustPlayInTheIndicatedGrid:
            "Sie mÃ¼ssen im angegebenen Feld spielen!",
          thisGridIsAlreadyWon: "Dieses Feld ist bereits gewonnen!",
          thisCellIsAlreadyTaken: "Diese Zelle ist bereits belegt!",
          difficultyChangedTo: "Schwierigkeit geÃ¤ndert zu",
          difficultyNames: {
            1: "Einfach",
            4: "Normal",
            8: "Schwierig",
          },
          yourTurn: "Ihr Zug",
          aiIsThinking: "Die KI denkt nach",
          rule1:
            "Ultimatives Tic Tac Toe besteht aus 9 kleinen Tic Tac Toe-Rastern, die ein groÃŸes Raster bilden.",
          rule2:
            "Sie mÃ¼ssen in dem kleinen Raster spielen, das der zuletzt gespielten Zelle Ihres Gegners entspricht.",
          rule3:
            "Beispiel: Wenn Ihr Gegner in der oberen rechten Zelle spielt, mÃ¼ssen Sie im oberen rechten kleinen Raster spielen.",
          rule4:
            "Wenn Sie zu einem bereits gewonnenen oder vollen Raster geschickt werden, kÃ¶nnen Sie Ã¼berall spielen.",
          rule5:
            "Gewinnen Sie ein kleines Raster, indem Sie drei in einer Reihe bekommen, genau wie beim normalen Tic Tac Toe.",
          rule6:
            "Gewinnen Sie das Spiel, indem Sie drei Raster in einer Reihe ausrichten.",
          youDefeatedTheAI: "Sie haben die KI auf",
          theAIWon: "Die KI hat auf",
          developer: "Entwickler",
          translator: "Ãœbersetzer",
          betaTesters: "Beta-Tester",
          backToSettings: "ZurÃ¼ck zu den Einstellungen",
          translatorCredits:
      "- Deutsch: BarthÃ©lÃ©my<br>- Englisch: BarthÃ©lÃ©my<br>- Spanisch: Alexandre<br>- Baskisch: Eneko<br>- Italienisch: Alberico<br>- Schwedisch: Anton<br>- Russisch: Louise<br>- Ukrainisch: Louise<br>- Arabisch: Roudy<br>- Japanisch: Antonin<br>- FranzÃ¶sisch: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        it: {
          info: "Info",
          level: "livello",
          title: "Tris Ultimo",
          playAgainstAI: "Gioca contro l'IA",
          localMultiplayer: "Multigiocatore Locale",
          timedMode: "ModalitÃ  Cronometrata",
          gameRules: "Regole del Gioco",
          settings: "Impostazioni",
          credits: "Contributori",
          creditsTitle: "Contributori ğŸ‘·â€â™‚ï¸",
          difficulty: "DifficoltÃ ",
          close: "Chiudi",
          continue: "Continua",
          newGame: "Nuova Partita",
          backToLobby: "Torna alla Lobby",
          language: "Lingua",
          easy: "Facile",
          normal: "Normale",
          difficult: "Difficile",
          youArePlayingAs: "Stai giocando come",
          youGoFirst: "Inizi tu!",
          aiGoesFirst: "L'IA inizia!",
          youWon: "Hai vinto.",
          aiWon: "L'IA ha vinto.",
          playerWon: "Il giocatore ha vinto.",
          gameEndedInDraw: "La partita Ã¨ finita in paritÃ .",
          playerXRanOutOfTime:
            "Il giocatore X ha finito il tempo. Il giocatore O vince!",
          playerORanOutOfTime:
            "Il giocatore O ha finito il tempo. Il giocatore X vince!",
          playerXWon: "Il giocatore X ha vinto.",
          playerOWon: "Il giocatore O ha vinto.",
          gameOver: "Partita finita",
          theGameIsAlreadyOver: "La partita Ã¨ giÃ  finita!",
          youMustPlayInTheIndicatedGrid: "Devi giocare nella griglia indicata!",
          thisGridIsAlreadyWon: "Questa griglia Ã¨ giÃ  stata vinta!",
          thisCellIsAlreadyTaken: "Questa cella Ã¨ giÃ  occupata!",
          difficultyChangedTo: "DifficoltÃ  cambiata in",
          difficultyNames: {
            1: "Facile",
            4: "Normale",
            8: "Difficile",
          },
          yourTurn: "Il tuo turno",
          aiIsThinking: "L'IA sta pensando",
          rule1:
            "Tris Ultimo consiste in 9 piccole griglie di Tris, che formano una grande griglia.",
          rule2:
            "Devi giocare nella griglia corrispondente all'ultima cella giocata dal tuo avversario.",
          rule3:
            "Esempio: Se il tuo avversario gioca nella cella in alto a destra, devi giocare nella griglia in alto a destra.",
          rule4:
            "Se sei indirizzato a una griglia giÃ  vinta o piena, puoi giocare ovunque.",
          rule5:
            "Vinci una piccola griglia ottenendo tre in fila, proprio come nel Tris normale.",
          rule6: "Vinci la partita allineando tre griglie.",
          youDefeatedTheAI: "Hai sconfitto l'IA al",
          theAIWon: "L'IA ha vinto al",
          developer: "Sviluppatore",
          translator: "Traduttore",
          betaTesters: "Beta Tester",
          backToSettings: "Torna alle Impostazioni",
          translatorCredits:
      "- Tedesco: BarthÃ©lÃ©my<br>- Inglese: BarthÃ©lÃ©my<br>- Spagnolo: Alexandre<br>- Basco: Eneko<br>- Italiano: Alberico<br>- Svedese: Anton<br>- Russo: Louise<br>- Ucraino: Louise<br>- Arabo: Roudy<br>- Giapponese: Antonin<br>- Francese: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        es: {
          info: "Info",
          level: "nivel",
          title: "Tres en Raya Ultimate",
          playAgainstAI: "Jugar contra la IA",
          localMultiplayer: "Multijugador Local",
          timedMode: "Modo Cronometrado",
          gameRules: "Reglas del Juego",
          settings: "ConfiguraciÃ³n",
          credits: "Contribuyentes",
          creditsTitle: "Contribuyentes ğŸ‘·â€â™‚ï¸",
          difficulty: "Dificultad",
          close: "Cerrar",
          continue: "Continuar",
          newGame: "Nuevo Juego",
          backToLobby: "Volver al Lobby",
          language: "Idioma",
          easy: "FÃ¡cil",
          normal: "Normal",
          difficult: "DifÃ­cil",
          youArePlayingAs: "EstÃ¡s jugando como",
          youGoFirst: "Â¡TÃº empiezas!",
          aiGoesFirst: "Â¡La IA empieza!",
          youWon: "Has ganado.",
          aiWon: "La IA ha ganado.",
          playerWon: "El jugador ha ganado.",
          gameEndedInDraw: "El juego terminÃ³ en empate.",
          playerXRanOutOfTime:
            "El jugador X se quedÃ³ sin tiempo. Â¡El jugador O gana!",
          playerORanOutOfTime:
            "El jugador O se quedÃ³ sin tiempo. Â¡El jugador X gana!",
          playerXWon: "El jugador X ha ganado.",
          playerOWon: "El jugador O ha ganado.",
          gameOver: "Juego terminado",
          theGameIsAlreadyOver: "Â¡El juego ya ha terminado!",
          youMustPlayInTheIndicatedGrid:
            "Â¡Debes jugar en la cuadrÃ­cula indicada!",
          thisGridIsAlreadyWon: "Â¡Esta cuadrÃ­cula ya ha sido ganada!",
          thisCellIsAlreadyTaken: "Â¡Esta celda ya estÃ¡ ocupada!",
          difficultyChangedTo: "Dificultad cambiada a",
          difficultyNames: {
            1: "FÃ¡cil",
            4: "Normal",
            8: "DifÃ­cil",
          },
          yourTurn: "Tu turno",
          aiIsThinking: "La IA estÃ¡ pensando",
          rule1:
            "El Tres en Raya Ultimate consiste en 9 pequeÃ±as cuadrÃ­culas de Tres en Raya, que forman una cuadrÃ­cula grande.",
          rule2:
            "Debes jugar en la cuadrÃ­cula que corresponde a la Ãºltima celda jugada por tu oponente.",
          rule3:
            "Ejemplo: Si tu oponente juega en la celda superior derecha, debes jugar en la cuadrÃ­cula superior derecha.",
          rule4:
            "Si eres enviado a una cuadrÃ­cula que ya ha sido ganada o estÃ¡ llena, puedes jugar en cualquier lugar.",
          rule5:
            "Gana una pequeÃ±a cuadrÃ­cula obteniendo tres en lÃ­nea, justo como en el Tres en Raya regular.",
          rule6: "Gana el juego alineando tres cuadrÃ­culas.",
          youDefeatedTheAI: "Has derrotado a la IA en el",
          theAIWon: "La IA ganÃ³ en el",
          developer: "Desarrollador",
          translator: "Traductor",
          betaTesters: "Beta Testers",
          backToSettings: "Volver a ConfiguraciÃ³n",
          translatorCredits:
      "- AlemÃ¡n: BarthÃ©lÃ©my<br>- InglÃ©s: BarthÃ©lÃ©my<br>- EspaÃ±ol: Alexandre<br>- Vasco: Eneko<br>- Italiano: Alberico<br>- Sueco: Anton<br>- Ruso: Louise<br>- Ucraniano: Louise<br>- Ãrabe: Roudy<br>- JaponÃ©s: Antonin<br>- FrancÃ©s: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        ar: {
          info: "Ù…Ø¹Ù„ÙˆÙ…Ø§Øª",
          level: "Ù…Ø³ØªÙˆÙ‰",
          title: "ØªÙŠÙƒ ØªØ§Ùƒ ØªÙˆ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ",
          playAgainstAI: "Ø§Ù„Ø¹Ø¨ Ø¶Ø¯ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
          localMultiplayer: "Ø§Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ Ø§Ù„Ù…Ø­Ù„ÙŠ",
          timedMode: "Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¤Ù‚Øª",
          gameRules: "Ù‚ÙˆØ§Ù†ÙŠÙ† Ø§Ù„Ù„Ø¹Ø¨Ø©",
          settings: "Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
          credits: "Ø§Ù„Ù…Ø³Ø§Ù‡Ù…ÙˆÙ†",
          creditsTitle: "Ø§Ù„Ù…Ø³Ø§Ù‡Ù…ÙˆÙ† ğŸ‘·â€â™‚ï¸",
          difficulty: "Ø§Ù„ØµØ¹ÙˆØ¨Ø©",
          close: "Ø¥ØºÙ„Ø§Ù‚",
          continue: "Ø§Ø³ØªÙ…Ø±Ø§Ø±",
          newGame: "Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©",
          backToLobby: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù„ÙˆØ¨ÙŠ",
          language: "Ø§Ù„Ù„ØºØ©",
          easy: "Ø³Ù‡Ù„",
          normal: "Ø¹Ø§Ø¯ÙŠ",
          difficult: "ØµØ¹Ø¨",
          youArePlayingAs: "Ø£Ù†Øª ØªÙ„Ø¹Ø¨ Ùƒ",
          youGoFirst: "Ø£Ù†Øª ØªØ¨Ø¯Ø£!",
          aiGoesFirst: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙŠØ¨Ø¯Ø£!",
          youWon: "Ù„Ù‚Ø¯ ÙØ§Ø²Øª.",
          aiWon: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙØ§Ø².",
          playerWon: "Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙØ§Ø².",
          gameEndedInDraw: "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø§Ù„ØªØ¹Ø§Ø¯Ù„.",
          playerXRanOutOfTime: "Ù†ÙØ¯ Ø§Ù„ÙˆÙ‚Øª Ù…Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ X. Ø§Ù„Ù„Ø§Ø¹Ø¨ O ÙŠÙÙˆØ²!",
          playerORanOutOfTime: "Ù†ÙØ¯ Ø§Ù„ÙˆÙ‚Øª Ù…Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ O. Ø§Ù„Ù„Ø§Ø¹Ø¨ X ÙŠÙÙˆØ²!",
          playerXWon: "Ø§Ù„Ù„Ø§Ø¹Ø¨ X ÙØ§Ø².",
          playerOWon: "Ø§Ù„Ù„Ø§Ø¹Ø¨ O ÙØ§Ø².",
          gameOver: "Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©",
          theGameIsAlreadyOver: "Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù†ØªÙ‡Øª Ø¨Ø§Ù„ÙØ¹Ù„!",
          youMustPlayInTheIndicatedGrid: "ÙŠØ¬Ø¨ Ø£Ù† ØªÙ„Ø¹Ø¨ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©!",
          thisGridIsAlreadyWon: "Ù‡Ø°Ù‡ Ø§Ù„Ø´Ø¨ÙƒØ© Ù‚Ø¯ ÙØ§Ø²Øª Ø¨Ø§Ù„ÙØ¹Ù„!",
          thisCellIsAlreadyTaken: "Ù‡Ø°Ù‡ Ø§Ù„Ø®Ù„ÙŠØ© Ù…Ø´ØºÙˆÙ„Ø© Ø¨Ø§Ù„ÙØ¹Ù„!",
          difficultyChangedTo: "ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„ØµØ¹ÙˆØ¨Ø© Ø¥Ù„Ù‰",
          difficultyNames: {
            1: "Ø³Ù‡Ù„",
            4: "Ø¹Ø§Ø¯ÙŠ",
            8: "ØµØ¹Ø¨",
          },
          yourTurn: "Ø¯ÙˆØ±Ùƒ",
          aiIsThinking: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙŠÙÙƒØ±",
          rule1:
            "ØªÙŠÙƒ ØªØ§Ùƒ ØªÙˆ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ÙŠØªÙƒÙˆÙ† Ù…Ù† 9 Ø´Ø¨ÙƒØ§Øª ØµØºÙŠØ±Ø© Ù…Ù† ØªÙŠÙƒ ØªØ§Ùƒ ØªÙˆØŒ ØªØ´ÙƒÙ„ Ø´Ø¨ÙƒØ© ÙƒØ¨ÙŠØ±Ø©.",
          rule2: "ÙŠØ¬Ø¨ Ø£Ù† ØªÙ„Ø¹Ø¨ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„ØªÙŠ ØªØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø¢Ø®Ø± Ø®Ù„ÙŠØ© Ù„Ø¹Ø¨Ù‡Ø§ Ø®ØµÙ…Ùƒ.",
          rule3:
            "Ù…Ø«Ø§Ù„: Ø¥Ø°Ø§ Ù„Ø¹Ø¨ Ø®ØµÙ…Ùƒ ÙÙŠ Ø§Ù„Ø®Ù„ÙŠØ© Ø§Ù„Ø¹Ù„ÙˆÙŠØ© Ø§Ù„ÙŠÙ…Ù†Ù‰ØŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙ„Ø¹Ø¨ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹Ù„ÙˆÙŠØ© Ø§Ù„ÙŠÙ…Ù†Ù‰.",
          rule4:
            "Ø¥Ø°Ø§ ØªÙ… Ø¥Ø±Ø³Ø§Ù„Ùƒ Ø¥Ù„Ù‰ Ø´Ø¨ÙƒØ© ÙØ§Ø²Øª Ø¨Ø§Ù„ÙØ¹Ù„ Ø£Ùˆ Ù…Ù…ØªÙ„Ø¦Ø©ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ù„Ø¹Ø¨ ÙÙŠ Ø£ÙŠ Ù…ÙƒØ§Ù†.",
          rule5:
            "Ø§ÙÙˆØ² Ø¨Ø´Ø¨ÙƒØ© ØµØºÙŠØ±Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø«Ù„Ø§Ø«Ø© ÙÙŠ ØµÙØŒ Ù…Ø«Ù„ ØªÙŠÙƒ ØªØ§Ùƒ ØªÙˆ Ø§Ù„Ø¹Ø§Ø¯ÙŠ.",
          rule6: "Ø§ÙÙˆØ² Ø¨Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ù…Ø­Ø§Ø°Ø§Ø© Ø«Ù„Ø§Ø« Ø´Ø¨ÙƒØ§Øª.",
          youDefeatedTheAI: "Ù„Ù‚Ø¯ Ù‡Ø²Ù…Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙÙŠ",
          theAIWon: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙØ§Ø² ÙÙŠ",
          developer: "Ø§Ù„Ù…Ø·ÙˆØ±",
          translator: "Ø§Ù„Ù…ØªØ±Ø¬Ù…",
          betaTesters: "Ù…Ø®ØªØ¨Ø±ÙŠ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ©",
          backToSettings: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
          translatorCredits:
      "- Ø§Ù„Ø£Ù„Ù…Ø§Ù†ÙŠØ©: Ø¨Ø§Ø±Ø«Ù„ÙŠÙ…ÙŠ<br>- Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©: Ø¨Ø§Ø±Ø«Ù„ÙŠÙ…ÙŠ<br>- Ø§Ù„Ø¥Ø³Ø¨Ø§Ù†ÙŠØ©: Ø£Ù„ÙƒØ³Ù†Ø¯Ø±<br>- Ø§Ù„Ø¨Ø§Ø³ÙƒÙŠØ©: Ø¥Ù†ÙŠÙƒÙˆ<br>- Ø§Ù„Ø¥ÙŠØ·Ø§Ù„ÙŠØ©: Ø£Ù„Ø¨Ø±ÙŠÙƒÙˆ<br>- Ø§Ù„Ø³ÙˆÙŠØ¯ÙŠØ©: Ø£Ù†Ø·ÙˆÙ†<br>- Ø§Ù„Ø±ÙˆØ³ÙŠØ©: Ù„ÙˆÙŠØ²<br>- Ø§Ù„Ø£ÙˆÙƒØ±Ø§Ù†ÙŠØ©: Ù„ÙˆÙŠØ²<br>- Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©: Ø±ÙˆØ¯ÙŠ<br>- Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠØ©: Ø£Ù†Ø·ÙˆØ§Ù†<br>- Ø§Ù„ÙØ±Ù†Ø³ÙŠØ©: Ø¨Ø§Ø±Ø«Ù„ÙŠÙ…ÙŠ",
    betaTestersCredits: "- Ø¥Ø³Ù…ÙŠ<br>- ØµØ§Ù…ÙˆÙŠÙ„<br>- Ø£Ù…ÙŠØ¯ÙŠ",
        },
        zh: {
          info: "ä¿¡æ¯",
          level: "çº§åˆ«",
          title: "ç»ˆæäº•å­—æ£‹",
          playAgainstAI: "ä¸AIå¯¹æˆ˜",
          localMultiplayer: "æœ¬åœ°å¤šäººæ¸¸æˆ",
          timedMode: "è®¡æ—¶æ¨¡å¼",
          gameRules: "æ¸¸æˆè§„åˆ™",
          settings: "è®¾ç½®",
          credits: "è´¡çŒ®è€…",
          creditsTitle: "è´¡çŒ®è€… ğŸ‘·â€â™‚ï¸",
          difficulty: "éš¾åº¦",
          close: "å…³é—­",
          continue: "ç»§ç»­",
          newGame: "æ–°æ¸¸æˆ",
          backToLobby: "è¿”å›å¤§å…",
          language: "è¯­è¨€",
          easy: "ç®€å•",
          normal: "æ™®é€š",
          difficult: "å›°éš¾",
          youArePlayingAs: "ä½ æ­£åœ¨æ‰®æ¼”",
          youGoFirst: "ä½ å…ˆèµ°ï¼",
          aiGoesFirst: "AIå…ˆèµ°ï¼",
          youWon: "ä½ èµ¢äº†ã€‚",
          aiWon: "AIèµ¢äº†ã€‚",
          playerWon: "ç©å®¶èµ¢äº†ã€‚",
          gameEndedInDraw: "æ¸¸æˆä»¥å¹³å±€ç»“æŸã€‚",
          playerXRanOutOfTime: "ç©å®¶Xæ—¶é—´ç”¨å®Œã€‚ç©å®¶Oèµ¢ï¼",
          playerORanOutOfTime: "ç©å®¶Oæ—¶é—´ç”¨å®Œã€‚ç©å®¶Xèµ¢ï¼",
          playerXWon: "ç©å®¶Xèµ¢äº†ã€‚",
          playerOWon: "ç©å®¶Oèµ¢äº†ã€‚",
          gameOver: "æ¸¸æˆç»“æŸ",
          theGameIsAlreadyOver: "æ¸¸æˆå·²ç»ç»“æŸï¼",
          youMustPlayInTheIndicatedGrid: "ä½ å¿…é¡»åœ¨æŒ‡å®šçš„ç½‘æ ¼ä¸­ç©ï¼",
          thisGridIsAlreadyWon: "è¿™ä¸ªç½‘æ ¼å·²ç»èµ¢äº†ï¼",
          thisCellIsAlreadyTaken: "è¿™ä¸ªå•å…ƒæ ¼å·²ç»è¢«å ç”¨ï¼",
          difficultyChangedTo: "éš¾åº¦æ›´æ”¹ä¸º",
          difficultyNames: {
            1: "ç®€å•",
            4: "æ™®é€š",
            8: "å›°éš¾",
          },
          yourTurn: "ä½ çš„å›åˆ",
          aiIsThinking: "AIæ­£åœ¨æ€è€ƒ",
          rule1: "ç»ˆæäº•å­—æ£‹ç”±9ä¸ªå°äº•å­—æ£‹ç½‘æ ¼ç»„æˆï¼Œå½¢æˆä¸€ä¸ªå¤§ç½‘æ ¼ã€‚",
          rule2: "ä½ å¿…é¡»åœ¨å¯¹åº”äºå¯¹æ‰‹æœ€åä¸€æ¬¡ç§»åŠ¨çš„ç½‘æ ¼ä¸­ç©ã€‚",
          rule3:
            "ä¾‹å¦‚ï¼Œå¦‚æœå¯¹æ‰‹åœ¨å…¶å³ä¸Šè§’å•å…ƒæ ¼ç§»åŠ¨ï¼Œä½ å¿…é¡»åœ¨å¤§ç½‘æ ¼çš„å³ä¸Šè§’ç½‘æ ¼ä¸­ç§»åŠ¨ã€‚",
          rule4: "å¦‚æœä½ è¢«å‘é€åˆ°ä¸€ä¸ªå·²ç»èµ¢æˆ–å·²æ»¡çš„ç½‘æ ¼ï¼Œä½ å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ç©ã€‚",
          rule5: "é€šè¿‡è·å¾—ä¸‰ä¸ªè¿æˆä¸€çº¿æ¥èµ¢å¾—ä¸€ä¸ªå°ç½‘æ ¼ï¼Œå°±åƒæ™®é€šäº•å­—æ£‹ä¸€æ ·ã€‚",
          rule6: "é€šè¿‡å¯¹é½ä¸‰ä¸ªç½‘æ ¼æ¥èµ¢å¾—æ¸¸æˆã€‚",
          youDefeatedTheAI: "ä½ åœ¨çº§åˆ«ä¸Šå‡»è´¥äº†AI",
          theAIWon: "AIåœ¨çº§åˆ«ä¸Šèµ¢äº†",
          developer: "å¼€å‘è€…",
          translator: "ç¿»è¯‘",
          betaTesters: "æµ‹è¯•äººå‘˜",
          backToSettings: "è¿”å›è®¾ç½®",
          translatorCredits:
      "- å¾·è¯­: å·´ç‰¹å‹’ç±³<br>- è‹±è¯­: å·´ç‰¹å‹’ç±³<br>- è¥¿ç­ç‰™è¯­: äºšå†å±±å¤§<br>- å·´æ–¯å…‹è¯­: åŸƒå†…ç§‘<br>- æ„å¤§åˆ©è¯­: é˜¿å°”è´é‡Œç§‘<br>- ç‘å…¸è¯­: å®‰ä¸œ<br>- ä¿„è¯­: è·¯æ˜“ä¸<br>- ä¹Œå…‹å…°è¯­: è·¯æ˜“ä¸<br>- é˜¿æ‹‰ä¼¯è¯­: é²è¿ª<br>- æ—¥è¯­: å®‰æ‰˜ä¸‡<br>- æ³•è¯­: å·´ç‰¹å‹’ç±³",
    betaTestersCredits: "- åŸƒæ–¯æ¢…<br>- å¡ç¼ªå°”<br>- é˜¿æ¢…å¾·",
        },
        ja: {
          info: "æƒ…å ±",
          level: "ãƒ¬ãƒ™ãƒ«",
          title: "æœ€é›£é–¢ãƒ‘ã‚ºãƒ«",
          playAgainstAI: "AIã¨å¯¾æˆ¦",
          localMultiplayer: "ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
          timedMode: "ã‚¿ã‚¤ãƒ ãƒ¢ãƒ¼ãƒ‰",
          gameRules: "ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«",
          settings: "è¨­å®š",
          credits: "è²¢çŒ®è€…",
          creditsTitle: "è²¢çŒ®è€… ğŸ‘·â€â™‚ï¸",
          difficulty: "é›£æ˜“åº¦",
          close: "é–‰ã˜ã‚‹",
          continue: "ç¶šã‘ã‚‹",
          newGame: "æ–°ã—ã„ã‚²ãƒ¼ãƒ ",
          backToLobby: "ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹",
          language: "è¨€èª",
          easy: "ç°¡å˜",
          normal: "æ™®é€š",
          difficult: "é›£ã—ã„",
          youArePlayingAs: "ã‚ãªãŸã¯ã¨ã—ã¦ãƒ—ãƒ¬ã‚¤ã—ã¦ã„ã¾ã™",
          youGoFirst: "ã‚ãªãŸãŒå…ˆã«è¡Œãã¾ã™ï¼",
          aiGoesFirst: "AIãŒå…ˆã«è¡Œãã¾ã™ï¼",
          youWon: "ã‚ãªãŸã®å‹ã¡ã§ã™ã€‚",
          aiWon: "AIã®å‹ã¡ã§ã™ã€‚",
          playerWon: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹ã¡ã§ã™ã€‚",
          gameEndedInDraw: "ã‚²ãƒ¼ãƒ ã¯å¼•ãåˆ†ã‘ã§çµ‚äº†ã—ã¾ã—ãŸã€‚",
          playerXRanOutOfTime: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Xã®æ™‚é–“åˆ‡ã‚Œã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Oã®å‹ã¡ï¼",
          playerORanOutOfTime: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Oã®æ™‚é–“åˆ‡ã‚Œã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Xã®å‹ã¡ï¼",
          playerXWon: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Xã®å‹ã¡ã§ã™ã€‚",
          playerOWon: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Oã®å‹ã¡ã§ã™ã€‚",
          gameOver: "ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼",
          theGameIsAlreadyOver: "ã‚²ãƒ¼ãƒ ã¯æ—¢ã«çµ‚äº†ã—ã¦ã„ã¾ã™ï¼",
          youMustPlayInTheIndicatedGrid:
            "æŒ‡å®šã•ã‚ŒãŸã‚°ãƒªãƒƒãƒ‰ã§ãƒ—ãƒ¬ã‚¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼",
          thisGridIsAlreadyWon: "ã“ã®ã‚°ãƒªãƒƒãƒ‰ã¯æ—¢ã«å‹ã£ã¦ã„ã¾ã™ï¼",
          thisCellIsAlreadyTaken: "ã“ã®ã‚»ãƒ«ã¯æ—¢ã«å–ã‚‰ã‚Œã¦ã„ã¾ã™ï¼",
          difficultyChangedTo: "é›£æ˜“åº¦ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸ",
          difficultyNames: {
            1: "ç°¡å˜",
            4: "æ™®é€š",
            8: "é›£ã—ã„",
          },
          yourTurn: "ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³",
          aiIsThinking: "AIãŒè€ƒãˆã¦ã„ã¾ã™",
          rule1:
            "ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆä¸‰ç›®ä¸¦ã¹ã¯ã€9ã¤ã®å°ã•ãªä¸‰ç›®ä¸¦ã¹ã‚°ãƒªãƒƒãƒ‰ã§æ§‹æˆã•ã‚Œã€1ã¤ã®å¤§ããªã‚°ãƒªãƒƒãƒ‰ã‚’å½¢æˆã—ã¾ã™ã€‚",
          rule2:
            "ã‚ãªãŸã¯ã€ç›¸æ‰‹ãŒæœ€å¾Œã«ãƒ—ãƒ¬ã‚¤ã—ãŸã‚»ãƒ«ã«å¯¾å¿œã™ã‚‹ã‚°ãƒªãƒƒãƒ‰ã§ãƒ—ãƒ¬ã‚¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚",
          rule3:
            "ä¾‹ãˆã°ã€ç›¸æ‰‹ãŒå³ä¸Šã®ã‚»ãƒ«ã§ãƒ—ãƒ¬ã‚¤ã—ãŸå ´åˆã€ã‚ãªãŸã¯å¤§ããªã‚°ãƒªãƒƒãƒ‰ã®å³ä¸Šã®ã‚°ãƒªãƒƒãƒ‰ã§ãƒ—ãƒ¬ã‚¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚",
          rule4:
            "æ—¢ã«å‹ã£ã¦ã„ã‚‹ã‹æº€ãŸã•ã‚Œã¦ã„ã‚‹ã‚°ãƒªãƒƒãƒ‰ã«é€ã‚‰ã‚ŒãŸå ´åˆã€ã‚ãªãŸã¯ã©ã“ã§ã‚‚ãƒ—ãƒ¬ã‚¤ã§ãã¾ã™ã€‚",
          rule5:
            "å°ã•ãªã‚°ãƒªãƒƒãƒ‰ã«å‹ã¤ãŸã‚ã«ã€é€šå¸¸ã®ä¸‰ç›®ä¸¦ã¹ã®ã‚ˆã†ã«3ã¤ã®ã‚·ãƒ³ãƒœãƒ«ã‚’æƒãˆã¾ã™ã€‚",
          rule6: "ã‚²ãƒ¼ãƒ ã«å‹ã¤ãŸã‚ã«ã€3ã¤ã®ã‚°ãƒªãƒƒãƒ‰ã‚’æƒãˆã¾ã™ã€‚",
          youDefeatedTheAI: "ã‚ãªãŸã¯ãƒ¬ãƒ™ãƒ«ã§AIã«å‹åˆ©ã—ã¾ã—ãŸ",
          theAIWon: "AIã¯ãƒ¬ãƒ™ãƒ«ã§å‹ã¡ã¾ã—ãŸ",
          developer: "é–‹ç™ºè€…",
          translator: "ç¿»è¨³è€…",
          betaTesters: "ãƒ™ãƒ¼ã‚¿ãƒ†ã‚¹ã‚¿ãƒ¼",
          backToSettings: "è¨­å®šã«æˆ»ã‚‹",
          translatorCredits:
      "- ãƒ‰ã‚¤ãƒ„èª: ãƒãƒ«ãƒ†ãƒŸãƒ¼<br>- è‹±èª: ãƒãƒ«ãƒ†ãƒŸãƒ¼<br>- ã‚¹ãƒšã‚¤ãƒ³èª: ã‚¢ãƒ¬ã‚¯ã‚µãƒ³ãƒ‰ãƒ«<br>- ãƒã‚¹ã‚¯èª: ã‚¨ãƒã‚³<br>- ã‚¤ã‚¿ãƒªã‚¢èª: ã‚¢ãƒ«ãƒ™ãƒªã‚³<br>- ã‚¹ã‚¦ã‚§ãƒ¼ãƒ‡ãƒ³èª: ã‚¢ãƒ³ãƒˆãƒ³<br>- ãƒ­ã‚·ã‚¢èª: ãƒ«ã‚¤ãƒ¼ã‚º<br>- ã‚¦ã‚¯ãƒ©ã‚¤ãƒŠèª: ãƒ«ã‚¤ãƒ¼ã‚º<br>- ã‚¢ãƒ©ãƒ“ã‚¢èª: ãƒ«ãƒ‡ã‚£<br>- æ—¥æœ¬èª: ã‚¢ãƒ³ãƒˆãƒŠãƒ³<br>- ãƒ•ãƒ©ãƒ³ã‚¹èª: ãƒãƒ«ãƒ†ãƒŸãƒ¼",
    betaTestersCredits: "- ã‚¨ã‚¹ãƒ¡<br>- ã‚µãƒŸãƒ¥ã‚¨ãƒ«<br>- ã‚¢ãƒ¡ãƒ‡",
        },
        ru: {
          info: "Ğ˜Ğ½Ñ„Ğ¾",
          level: "ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ",
          title: "Ğ£Ğ»ÑŒÑ‚Ğ¸Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ĞºÑ€ĞµÑÑ‚Ğ¸ĞºĞ¸-Ğ½Ğ¾Ğ»Ğ¸ĞºĞ¸",
          playAgainstAI: "Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ² Ğ˜Ğ˜",
          localMultiplayer: "Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»ĞµĞµÑ€",
          timedMode: "Ğ ĞµĞ¶Ğ¸Ğ¼ Ñ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ¾Ğ¼",
          gameRules: "ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ¸Ğ³Ñ€Ñ‹",
          settings: "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸",
          credits: "Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸",
          creditsTitle: "Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ ğŸ‘·â€â™‚ï¸",
          difficulty: "Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ",
          close: "Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
          continue: "ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ",
          newGame: "ĞĞ¾Ğ²Ğ°Ñ Ğ¸Ğ³Ñ€Ğ°",
          backToLobby: "Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ² Ğ»Ğ¾Ğ±Ğ±Ğ¸",
          language: "Ğ¯Ğ·Ñ‹Ğº",
          easy: "Ğ›ĞµĞ³ĞºĞ¾",
          normal: "ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾",
          difficult: "Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾",
          youArePlayingAs: "Ğ’Ñ‹ Ğ¸Ğ³Ñ€Ğ°ĞµÑ‚Ğµ Ğ·Ğ°",
          youGoFirst: "Ğ’Ñ‹ Ñ…Ğ¾Ğ´Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼Ğ¸!",
          aiGoesFirst: "Ğ˜Ğ˜ Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼!",
          youWon: "Ğ’Ñ‹ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ»Ğ¸.",
          aiWon: "Ğ˜Ğ˜ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ».",
          playerWon: "Ğ˜Ğ³Ñ€Ğ¾Ğº Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ».",
          gameEndedInDraw: "Ğ˜Ğ³Ñ€Ğ° Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ°ÑÑŒ Ğ²Ğ½Ğ¸Ñ‡ÑŒÑ.",
          playerXRanOutOfTime:
            "Ğ£ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ° X Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ¾ÑÑŒ Ğ²Ñ€ĞµĞ¼Ñ. Ğ˜Ğ³Ñ€Ğ¾Ğº O Ğ¿Ğ¾Ğ±ĞµĞ¶Ğ´Ğ°ĞµÑ‚!",
          playerORanOutOfTime:
            "Ğ£ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ° O Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ¾ÑÑŒ Ğ²Ñ€ĞµĞ¼Ñ. Ğ˜Ğ³Ñ€Ğ¾Ğº X Ğ¿Ğ¾Ğ±ĞµĞ¶Ğ´Ğ°ĞµÑ‚!",
          playerXWon: "Ğ˜Ğ³Ñ€Ğ¾Ğº X Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ğ».",
          playerOWon: "Ğ˜Ğ³Ñ€Ğ¾Ğº O Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ğ».",
          gameOver: "Ğ˜Ğ³Ñ€Ğ° Ğ¾ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ°",
          theGameIsAlreadyOver: "Ğ˜Ğ³Ñ€Ğ° ÑƒĞ¶Ğµ Ğ·Ğ°ĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ°!",
          youMustPlayInTheIndicatedGrid: "Ğ’Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ² ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ¹ ÑĞµÑ‚ĞºĞµ!",
          thisGridIsAlreadyWon: "Ğ­Ñ‚Ğ° ÑĞµÑ‚ĞºĞ° ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ½Ğ°!",
          thisCellIsAlreadyTaken: "Ğ­Ñ‚Ğ° ĞºĞ»ĞµÑ‚ĞºĞ° ÑƒĞ¶Ğµ Ğ·Ğ°Ğ½ÑÑ‚Ğ°!",
          difficultyChangedTo: "Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ° Ğ½Ğ°",
          difficultyNames: {
            1: "Ğ›ĞµĞ³ĞºĞ¾",
            4: "ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾",
            8: "Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾",
          },
          yourTurn: "Ğ’Ğ°Ñˆ Ñ…Ğ¾Ğ´",
          aiIsThinking: "Ğ˜Ğ˜ Ğ´ÑƒĞ¼Ğ°ĞµÑ‚",
          rule1:
            "Ğ£Ğ»ÑŒÑ‚Ğ¸Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ĞºÑ€ĞµÑÑ‚Ğ¸ĞºĞ¸-Ğ½Ğ¾Ğ»Ğ¸ĞºĞ¸ ÑĞ¾ÑÑ‚Ğ¾ÑÑ‚ Ğ¸Ğ· 9 Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ñ… ÑĞµÑ‚Ğ¾Ğº ĞºÑ€ĞµÑÑ‚Ğ¸ĞºĞ¾Ğ²-Ğ½Ğ¾Ğ»Ğ¸ĞºĞ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ·ÑƒÑÑ‚ Ğ¾Ğ´Ğ½Ñƒ Ğ±Ğ¾Ğ»ÑŒÑˆÑƒÑ ÑĞµÑ‚ĞºÑƒ.",
          rule2:
            "Ğ’Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ² ÑĞµÑ‚ĞºĞµ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ ĞºĞ»ĞµÑ‚ĞºĞµ, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€ÑƒÑ ÑÑ‹Ğ³Ñ€Ğ°Ğ» Ğ²Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸Ğº.",
          rule3:
            "ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: ĞµÑĞ»Ğ¸ Ğ²Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸Ğº Ğ¸Ğ³Ñ€Ğ°ĞµÑ‚ Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¹ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¹ ĞºĞ»ĞµÑ‚ĞºĞµ, Ğ²Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¹ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¹ ÑĞµÑ‚ĞºĞµ.",
          rule4:
            "Ğ•ÑĞ»Ğ¸ Ğ²Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑÑ‚ Ğ² ÑĞµÑ‚ĞºÑƒ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ½Ğ° Ğ¸Ğ»Ğ¸ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°, Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ² Ğ»ÑĞ±Ğ¾Ğ¹ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¾Ğ¹ ÑĞµÑ‚ĞºĞµ.",
          rule5:
            "Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºÑƒÑ ÑĞµÑ‚ĞºÑƒ, Ğ²Ñ‹ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ 3 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ° Ğ² Ñ€ÑĞ´, ĞºĞ°Ğº Ğ² ĞºĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ñ… ĞºÑ€ĞµÑÑ‚Ğ¸ĞºĞ°Ñ…-Ğ½Ğ¾Ğ»Ğ¸ĞºĞ°Ñ….",
          rule6: "Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ¸Ğ³Ñ€Ñƒ, Ğ²Ñ‹ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ 3 ÑĞµÑ‚ĞºĞ¸ Ğ² Ñ€ÑĞ´.",
          youDefeatedTheAI: "Ğ’Ñ‹ Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ğ»Ğ¸ Ğ˜Ğ˜ Ğ½Ğ°",
          theAIWon: "Ğ˜Ğ˜ Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ğ» Ğ½Ğ°",
          developer: "Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº",
          translator: "ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´Ñ‡Ğ¸Ğº",
          betaTesters: "Ğ‘ĞµÑ‚Ğ°-Ñ‚ĞµÑÑ‚ĞµÑ€Ñ‹",
          backToSettings: "Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğº Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ğ¼",
          translatorCredits:
      "- ĞĞµĞ¼ĞµÑ†ĞºĞ¸Ğ¹: Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ğ¸<br>- ĞĞ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğ¹: Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ğ¸<br>- Ğ˜ÑĞ¿Ğ°Ğ½ÑĞºĞ¸Ğ¹: ĞĞ»ĞµĞºÑĞ°Ğ½Ğ´Ñ€<br>- Ğ‘Ğ°ÑĞºÑĞºĞ¸Ğ¹: Ğ­Ğ½ĞµĞºĞ¾<br>- Ğ˜Ñ‚Ğ°Ğ»ÑŒÑĞ½ÑĞºĞ¸Ğ¹: ĞĞ»ÑŒĞ±ĞµÑ€Ğ¸ĞºĞ¾<br>- Ğ¨Ğ²ĞµĞ´ÑĞºĞ¸Ğ¹: ĞĞ½Ñ‚Ğ¾Ğ½<br>- Ğ ÑƒÑÑĞºĞ¸Ğ¹: Ğ›ÑƒĞ¸Ğ·Ğ°<br>- Ğ£ĞºÑ€Ğ°Ğ¸Ğ½ÑĞºĞ¸Ğ¹: Ğ›ÑƒĞ¸Ğ·Ğ°<br>- ĞÑ€Ğ°Ğ±ÑĞºĞ¸Ğ¹: Ğ ÑƒĞ´Ğ¸<br>- Ğ¯Ğ¿Ğ¾Ğ½ÑĞºĞ¸Ğ¹: ĞĞ½Ñ‚ÑƒĞ°Ğ½<br>- Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑĞºĞ¸Ğ¹: Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ğ¸",
    betaTestersCredits: "- Ğ­ÑĞ¼Ğµ<br>- Ğ¡Ğ°Ğ¼ÑƒÑĞ»ÑŒ<br>- ĞĞ¼ĞµĞ´Ğµ",
        },
        sv: {
          info: "Info",
          level: "nivÃ¥",
          title: "Ultimate Tic Tac Toe",
          playAgainstAI: "Spela mot AI",
          localMultiplayer: "Lokal Multiplayer",
          timedMode: "TidsbegrÃ¤nsat LÃ¤ge",
          gameRules: "Spelregler",
          settings: "InstÃ¤llningar",
          credits: "Bidragsgivare",
          creditsTitle: "Bidragsgivare ğŸ‘·â€â™‚ï¸",
          difficulty: "SvÃ¥righetsgrad",
          close: "StÃ¤ng",
          continue: "FortsÃ¤tt",
          newGame: "Nytt Spel",
          backToLobby: "Tillbaka till Lobby",
          language: "SprÃ¥k",
          easy: "LÃ¤tt",
          normal: "Normal",
          difficult: "SvÃ¥r",
          youArePlayingAs: "Du spelar som",
          youGoFirst: "Du bÃ¶rjar!",
          aiGoesFirst: "AI bÃ¶rjar!",
          youWon: "Du vann.",
          aiWon: "AI vann.",
          playerWon: "Spelaren vann.",
          gameEndedInDraw: "Spelet slutade oavgjort.",
          playerXRanOutOfTime: "Spelare X tog slut pÃ¥ tid. Spelare O vinner!",
          playerORanOutOfTime: "Spelare O tog slut pÃ¥ tid. Spelare X vinner!",
          playerXWon: "Spelare X vann.",
          playerOWon: "Spelare O vann.",
          gameOver: "Spel slut",
          theGameIsAlreadyOver: "Spelet Ã¤r redan Ã¶ver!",
          youMustPlayInTheIndicatedGrid: "Du mÃ¥ste spela i den angivna rutan!",
          thisGridIsAlreadyWon: "Den hÃ¤r rutan Ã¤r redan vunnen!",
          thisCellIsAlreadyTaken: "Den hÃ¤r cellen Ã¤r redan tagen!",
          difficultyChangedTo: "SvÃ¥righetsgrad Ã¤ndrad till",
          difficultyNames: {
            1: "LÃ¤tt",
            4: "Normal",
            8: "SvÃ¥r",
          },
          yourTurn: "Din tur",
          aiIsThinking: "AI tÃ¤nker",
          rule1:
            "Ultimate Tic Tac Toe bestÃ¥r av 9 mindre Tic Tac Toe-brÃ¤dor arrangerade i ett stort 3x3-rutnÃ¤t.",
          rule2:
            "Du mÃ¥ste spela i den lilla brÃ¤det som matchar var din motstÃ¥ndare senast spelade.",
          rule3:
            "Exempel: Om din motstÃ¥ndare spelar i den Ã¶vre hÃ¶gra cellen, mÃ¥ste du spela i det Ã¶vre hÃ¶gra lilla brÃ¤det.",
          rule4:
            "Om du skickas till ett brÃ¤de som redan Ã¤r vunnet eller fullt, kan du spela var som helst.",
          rule5:
            "Vinn ett litet brÃ¤de genom att fÃ¥ tre i rad, precis som vanligt Tic Tac Toe.",
          rule6: "Vinn spelet genom att radera upp tre brÃ¤dor.",
          youDefeatedTheAI: "Du besegrade AI pÃ¥",
          theAIWon: "AI vann pÃ¥",
          developer: "Utvecklare",
          translator: "Ã–versÃ¤ttare",
          betaTesters: "Betatestare",
          backToSettings: "Tillbaka till InstÃ¤llningar",
          translatorCredits:
      "- Tyska: BarthÃ©lÃ©my<br>- Engelska: BarthÃ©lÃ©my<br>- Spanska: Alexandre<br>- Baskiska: Eneko<br>- Italienska: Alberico<br>- Svenska: Anton<br>- Ryska: Louise<br>- Ukrainska: Louise<br>- Arabiska: Roudy<br>- Japanska: Antonin<br>- Franska: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        hi: {
          info: "à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€",
          level: "à¤¸à¥à¤¤à¤°",
          title: "à¤…à¤²à¥à¤Ÿà¤¿à¤®à¥‡à¤Ÿ à¤Ÿà¤¿à¤• à¤Ÿà¥ˆà¤• à¤Ÿà¥‹",
          playAgainstAI: "à¤à¤†à¤ˆ à¤•à¥‡ à¤–à¤¿à¤²à¤¾à¤« à¤–à¥‡à¤²à¥‡à¤‚",
          localMultiplayer: "à¤²à¥‹à¤•à¤² à¤®à¤²à¥à¤Ÿà¥€à¤ªà¥à¤²à¥‡à¤¯à¤°",
          timedMode: "à¤¸à¤®à¤¯à¤¬à¤¦à¥à¤§ à¤®à¥‹à¤¡",
          gameRules: "à¤—à¥‡à¤® à¤¨à¤¿à¤¯à¤®",
          settings: "à¤¸à¥‡à¤Ÿà¤¿à¤‚à¤—à¥à¤¸",
          credits: "à¤¯à¥‹à¤—à¤¦à¤¾à¤¨à¤•à¤°à¥à¤¤à¤¾",
          creditsTitle: "à¤¯à¥‹à¤—à¤¦à¤¾à¤¨à¤•à¤°à¥à¤¤à¤¾ ğŸ‘·â€â™‚ï¸",
          difficulty: "à¤•à¤ à¤¿à¤¨à¤¾à¤ˆ",
          close: "à¤¬à¤‚à¤¦ à¤•à¤°à¥‡à¤‚",
          continue: "à¤œà¤¾à¤°à¥€ à¤°à¤–à¥‡à¤‚",
          newGame: "à¤¨à¤¯à¤¾ à¤–à¥‡à¤²",
          backToLobby: "à¤²à¥‰à¤¬à¥€ à¤ªà¤° à¤µà¤¾à¤ªà¤¸",
          language: "à¤­à¤¾à¤·à¤¾",
          easy: "à¤†à¤¸à¤¾à¤¨",
          normal: "à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯",
          difficult: "à¤•à¤ à¤¿à¤¨",
          youArePlayingAs: "à¤†à¤ª à¤–à¥‡à¤² à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚",
          youGoFirst: "à¤†à¤ª à¤ªà¤¹à¤²à¥‡ à¤œà¤¾à¤¤à¥‡ à¤¹à¥ˆà¤‚!",
          aiGoesFirst: "à¤à¤†à¤ˆ à¤ªà¤¹à¤²à¥‡ à¤œà¤¾à¤¤à¤¾ à¤¹à¥ˆ!",
          youWon: "à¤†à¤ª à¤œà¥€à¤¤ à¤—à¤à¥¤",
          aiWon: "à¤à¤†à¤ˆ à¤œà¥€à¤¤ à¤—à¤¯à¤¾à¥¤",
          playerWon: "à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ à¤œà¥€à¤¤ à¤—à¤¯à¤¾à¥¤",
          gameEndedInDraw: "à¤—à¥‡à¤® à¤¡à¥à¤°à¥‰ à¤ªà¤° à¤¸à¤®à¤¾à¤ªà¥à¤¤ à¤¹à¥à¤†à¥¤",
          playerXRanOutOfTime:
            "à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ X à¤•à¤¾ à¤¸à¤®à¤¯ à¤¸à¤®à¤¾à¤ªà¥à¤¤ à¤¹à¥‹ à¤—à¤¯à¤¾à¥¤ à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ O à¤œà¥€à¤¤à¤¤à¤¾ à¤¹à¥ˆ!",
          playerORanOutOfTime:
            "à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ O à¤•à¤¾ à¤¸à¤®à¤¯ à¤¸à¤®à¤¾à¤ªà¥à¤¤ à¤¹à¥‹ à¤—à¤¯à¤¾à¥¤ à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ X à¤œà¥€à¤¤à¤¤à¤¾ à¤¹à¥ˆ!",
          playerXWon: "à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ X à¤œà¥€à¤¤ à¤—à¤¯à¤¾à¥¤",
          playerOWon: "à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ O à¤œà¥€à¤¤ à¤—à¤¯à¤¾à¥¤",
          gameOver: "à¤—à¥‡à¤® à¤–à¤¤à¥à¤®",
          theGameIsAlreadyOver: "à¤—à¥‡à¤® à¤ªà¤¹à¤²à¥‡ à¤¹à¥€ à¤–à¤¤à¥à¤® à¤¹à¥‹ à¤šà¥à¤•à¤¾ à¤¹à¥ˆ!",
          youMustPlayInTheIndicatedGrid:
            "à¤†à¤ªà¤•à¥‹ à¤¨à¤¿à¤°à¥à¤¦à¤¿à¤·à¥à¤Ÿ à¤—à¥à¤°à¤¿à¤¡ à¤®à¥‡à¤‚ à¤–à¥‡à¤²à¤¨à¤¾ à¤šà¤¾à¤¹à¤¿à¤!",
          thisGridIsAlreadyWon: "à¤¯à¤¹ à¤—à¥à¤°à¤¿à¤¡ à¤ªà¤¹à¤²à¥‡ à¤¹à¥€ à¤œà¥€à¤¤ à¤šà¥à¤•à¤¾ à¤¹à¥ˆ!",
          thisCellIsAlreadyTaken: "à¤¯à¤¹ à¤¸à¥‡à¤² à¤ªà¤¹à¤²à¥‡ à¤¹à¥€ à¤²à¤¿à¤¯à¤¾ à¤œà¤¾ à¤šà¥à¤•à¤¾ à¤¹à¥ˆ!",
          difficultyChangedTo: "à¤•à¤ à¤¿à¤¨à¤¾à¤ˆ à¤¬à¤¦à¤²à¤•à¤°",
          difficultyNames: {
            1: "à¤†à¤¸à¤¾à¤¨",
            4: "à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯",
            8: "à¤•à¤ à¤¿à¤¨",
          },
          yourTurn: "à¤†à¤ªà¤•à¥€ à¤¬à¤¾à¤°à¥€",
          aiIsThinking: "à¤à¤†à¤ˆ à¤¸à¥‹à¤š à¤°à¤¹à¤¾ à¤¹à¥ˆ",
          rule1:
            "à¤…à¤²à¥à¤Ÿà¤¿à¤®à¥‡à¤Ÿ à¤Ÿà¤¿à¤• à¤Ÿà¥ˆà¤• à¤Ÿà¥‹ 9 à¤›à¥‹à¤Ÿà¥‡ à¤Ÿà¤¿à¤• à¤Ÿà¥ˆà¤• à¤Ÿà¥‹ à¤¬à¥‹à¤°à¥à¤¡à¥‹à¤‚ à¤¸à¥‡ à¤¬à¤¨à¤¾ à¤¹à¥‹à¤¤à¤¾ à¤¹à¥ˆ à¤œà¥‹ à¤à¤• à¤¬à¤¡à¤¼à¥‡ 3x3 à¤—à¥à¤°à¤¿à¤¡ à¤®à¥‡à¤‚ à¤µà¥à¤¯à¤µà¤¸à¥à¤¥à¤¿à¤¤ à¤¹à¥‹à¤¤à¥‡ à¤¹à¥ˆà¤‚à¥¤",
          rule2:
            "à¤†à¤ªà¤•à¥‹ à¤‰à¤¸ à¤—à¥à¤°à¤¿à¤¡ à¤®à¥‡à¤‚ à¤–à¥‡à¤²à¤¨à¤¾ à¤šà¤¾à¤¹à¤¿à¤ à¤œà¥‹ à¤†à¤ªà¤•à¥‡ à¤ªà¥à¤°à¤¤à¤¿à¤¦à¥à¤µà¤‚à¤¦à¥à¤µà¥€ à¤•à¥‡ à¤…à¤‚à¤¤à¤¿à¤® à¤–à¥‡à¤²à¥‡ à¤—à¤ à¤¸à¥à¤¥à¤¾à¤¨ à¤¸à¥‡ à¤®à¥‡à¤² à¤–à¤¾à¤¤à¤¾ à¤¹à¥‹à¥¤",
          rule3:
            "à¤‰à¤¦à¤¾à¤¹à¤°à¤£: à¤¯à¤¦à¤¿ à¤†à¤ªà¤•à¤¾ à¤ªà¥à¤°à¤¤à¤¿à¤¦à¥à¤µà¤‚à¤¦à¥à¤µà¥€ à¤Šà¤ªà¤° à¤¦à¤¾à¤à¤‚ à¤•à¥‹à¤¨à¥‡ à¤•à¥€ à¤¸à¥‡à¤² à¤®à¥‡à¤‚ à¤–à¥‡à¤²à¤¤à¤¾ à¤¹à¥ˆ, à¤¤à¥‹ à¤†à¤ªà¤•à¥‹ à¤Šà¤ªà¤° à¤¦à¤¾à¤à¤‚ à¤—à¥à¤°à¤¿à¤¡ à¤®à¥‡à¤‚ à¤–à¥‡à¤²à¤¨à¤¾ à¤šà¤¾à¤¹à¤¿à¤à¥¤",
          rule4:
            "à¤¯à¤¦à¤¿ à¤†à¤ªà¤•à¥‹ à¤à¤• à¤à¤¸à¥‡ à¤—à¥à¤°à¤¿à¤¡ à¤ªà¤° à¤­à¥‡à¤œà¤¾ à¤œà¤¾à¤¤à¤¾ à¤¹à¥ˆ à¤œà¥‹ à¤ªà¤¹à¤²à¥‡ à¤¸à¥‡ à¤œà¥€à¤¤ à¤šà¥à¤•à¤¾ à¤¹à¥ˆ à¤¯à¤¾ à¤­à¤° à¤šà¥à¤•à¤¾ à¤¹à¥ˆ, à¤¤à¥‹ à¤†à¤ª à¤•à¤¹à¥€à¤‚ à¤­à¥€ à¤–à¥‡à¤² à¤¸à¤•à¤¤à¥‡ à¤¹à¥ˆà¤‚à¥¤",
          rule5:
            "à¤à¤• à¤›à¥‹à¤Ÿà¥‡ à¤¬à¥‹à¤°à¥à¤¡ à¤•à¥‹ à¤œà¥€à¤¤à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤, à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤Ÿà¤¿à¤• à¤Ÿà¥ˆà¤• à¤Ÿà¥‹ à¤•à¥€ à¤¤à¤°à¤¹ à¤¤à¥€à¤¨ à¤ªà¤‚à¤•à¥à¤¤à¤¿à¤¯à¥‹à¤‚ à¤®à¥‡à¤‚ à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¤°à¥‡à¤‚à¥¤",
          rule6: "à¤¬à¤¡à¤¼à¥‡ à¤¬à¥‹à¤°à¥à¤¡ à¤ªà¤° à¤¤à¥€à¤¨ à¤—à¥à¤°à¤¿à¤¡à¥‹à¤‚ à¤•à¥‹ à¤¸à¤‚à¤°à¥‡à¤–à¤¿à¤¤ à¤•à¤°à¤•à¥‡ à¤–à¥‡à¤² à¤œà¥€à¤¤à¥‡à¤‚à¥¤",
          youDefeatedTheAI: "à¤†à¤ªà¤¨à¥‡ à¤¸à¥à¤¤à¤° à¤ªà¤° à¤à¤†à¤ˆ à¤•à¥‹ à¤¹à¤°à¤¾à¤¯à¤¾",
          theAIWon: "à¤à¤†à¤ˆ à¤¨à¥‡ à¤¸à¥à¤¤à¤° à¤ªà¤° à¤œà¥€à¤¤ à¤¹à¤¾à¤¸à¤¿à¤² à¤•à¥€",
          developer: "à¤¡à¥‡à¤µà¤²à¤ªà¤°",
          translator: "à¤…à¤¨à¥à¤µà¤¾à¤¦à¤•",
          betaTesters: "à¤¬à¥€à¤Ÿà¤¾ à¤ªà¤°à¥€à¤•à¥à¤·à¤•",
          backToSettings: "à¤¸à¥‡à¤Ÿà¤¿à¤‚à¤—à¥à¤¸ à¤ªà¤° à¤µà¤¾à¤ªà¤¸ à¤œà¤¾à¤à¤‚",
          translatorCredits:
      "- à¤œà¤°à¥à¤®à¤¨: à¤¬à¤¾à¤°à¥à¤¥à¥‡à¤²à¤®à¥€<br>- à¤…à¤‚à¤—à¥à¤°à¥‡à¤œà¥€: à¤¬à¤¾à¤°à¥à¤¥à¥‡à¤²à¤®à¥€<br>- à¤¸à¥à¤ªà¥‡à¤¨à¤¿à¤¶: à¤…à¤²à¥‡à¤•à¥à¤œà¥‡à¤‚à¤¡à¥à¤°à¥‡<br>- à¤¬à¤¾à¤¸à¥à¤•: à¤à¤¨à¥‡à¤•à¥‹<br>- à¤‡à¤Ÿà¤¾à¤²à¤¿à¤¯à¤¨: à¤…à¤²à¥à¤¬à¥‡à¤°à¤¿à¤•à¥‹<br>- à¤¸à¥à¤µà¥€à¤¡à¤¿à¤¶: à¤à¤‚à¤Ÿà¥‹à¤¨<br>- à¤°à¥‚à¤¸à¥€: à¤²à¥à¤ˆà¤¸<br>- à¤¯à¥‚à¤•à¥à¤°à¥‡à¤¨à¥€: à¤²à¥à¤ˆà¤¸<br>- à¤…à¤°à¤¬à¥€: à¤°à¥‚à¤¡à¥€<br>- à¤œà¤¾à¤ªà¤¾à¤¨à¥€: à¤à¤‚à¤Ÿà¥‹à¤¨à¤¿à¤¨<br>- à¤«à¥à¤°à¥‡à¤‚à¤š: à¤¬à¤¾à¤°à¥à¤¥à¥‡à¤²à¤®à¥€",
    betaTestersCredits: "- à¤à¤¸à¥à¤®à¥€<br>- à¤¸à¥ˆà¤®à¥à¤…à¤²<br>- à¤…à¤®à¥‡à¤¡à¥€",
        },
        pt: {
          info: "Info",
          level: "nÃ­vel",
          title: "Jogo da Velha Ultimate",
          playAgainstAI: "Jogar contra a IA",
          localMultiplayer: "Multijogador Local",
          timedMode: "Modo Cronometrado",
          gameRules: "Regras do Jogo",
          settings: "ConfiguraÃ§Ãµes",
          credits: "CrÃ©ditos",
          creditsTitle: "Contribuidores ğŸ‘·â€â™‚ï¸",
          difficulty: "Dificuldade",
          close: "Fechar",
          continue: "Continuar",
          newGame: "Novo Jogo",
          backToLobby: "Voltar ao Lobby",
          language: "Idioma",
          easy: "FÃ¡cil",
          normal: "Normal",
          difficult: "DifÃ­cil",
          youArePlayingAs: "VocÃª estÃ¡ jogando como",
          youGoFirst: "VocÃª comeÃ§a!",
          aiGoesFirst: "A IA comeÃ§a!",
          youWon: "VocÃª ganhou.",
          aiWon: "A IA ganhou.",
          playerWon: "O jogador ganhou.",
          gameEndedInDraw: "O jogo terminou em empate.",
          playerXRanOutOfTime:
            "O jogador X ficou sem tempo. O jogador O ganha!",
          playerORanOutOfTime:
            "O jogador O ficou sem tempo. O jogador X ganha!",
          playerXWon: "O jogador X ganhou.",
          playerOWon: "O jogador O ganhou.",
          gameOver: "Fim de Jogo",
          theGameIsAlreadyOver: "O jogo jÃ¡ terminou!",
          youMustPlayInTheIndicatedGrid: "VocÃª deve jogar na grade indicada!",
          thisGridIsAlreadyWon: "Esta grade jÃ¡ foi vencida!",
          thisCellIsAlreadyTaken: "Esta cÃ©lula jÃ¡ estÃ¡ ocupada!",
          difficultyChangedTo: "Dificuldade alterada para",
          difficultyNames: {
            1: "FÃ¡cil",
            4: "Normal",
            8: "DifÃ­cil",
          },
          yourTurn: "Sua vez",
          aiIsThinking: "A IA estÃ¡ pensando",
          rule1:
            "O Jogo da Velha Ultimate Ã© composto por 9 tabuleiros menores de Jogo da Velha, formando um grande tabuleiro 3x3.",
          rule2:
            "VocÃª deve jogar no tabuleiro que corresponde Ã  Ãºltima jogada do seu oponente.",
          rule3:
            "Exemplo: Se o seu oponente jogar na cÃ©lula superior direita, vocÃª deve jogar no tabuleiro superior direito.",
          rule4:
            "Se vocÃª for enviado a um tabuleiro que jÃ¡ foi vencido ou estÃ¡ cheio, vocÃª pode jogar em qualquer lugar.",
          rule5:
            "Ganhe um tabuleiro pequeno alinhando trÃªs sÃ­mbolos, como no Jogo da Velha clÃ¡ssico.",
          rule6: "Ganhe o jogo alinhando trÃªs tabuleiros.",
          youDefeatedTheAI: "VocÃª derrotou a IA no",
          theAIWon: "A IA venceu no",
          developer: "Desenvolvedor",
          translator: "Tradutor",
          betaTesters: "Testadores Beta",
          backToSettings: "Voltar para ConfiguraÃ§Ãµes",
          translatorCredits:
      "- AlemÃ£o: BarthÃ©lÃ©my<br>- InglÃªs: BarthÃ©lÃ©my<br>- Espanhol: Alexandre<br>- Basco: Eneko<br>- Italiano: Alberico<br>- Sueco: Anton<br>- Russo: Louise<br>- Ucraniano: Louise<br>- Ãrabe: Roudy<br>- JaponÃªs: Antonin<br>- FrancÃªs: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        eu: {
          info: "Informazioa",
          level: "maila",
          title: "Hiru Lerroren Joko Goratua",
          playAgainstAI: "AIaren aurka jolastu",
          localMultiplayer: "Jokalari Anitz Lokala",
          timedMode: "Denbora Mugatuko Modua",
          gameRules: "Joko Arauak",
          settings: "Ezarpenak",
          credits: "Ekintzaileak",
          creditsTitle: "Ekintzaileak ğŸ‘·â€â™‚ï¸",
          difficulty: "Zailtasuna",
          close: "Itxi",
          continue: "Jarraitu",
          newGame: "Joko Berria",
          backToLobby: "Itzuli Lobira",
          language: "Hizkuntza",
          easy: "Erraza",
          normal: "Normala",
          difficult: "Zaila",
          youArePlayingAs: "Honekin jokatzen ari zara",
          youGoFirst: "Zuk hasten du!",
          aiGoesFirst: "AIak hasten du!",
          youWon: "Zuk irabazi duzu.",
          aiWon: "AIak irabazi du.",
          playerWon: "Jokalariak irabazi du.",
          gameEndedInDraw: "Jokoa berdinketa batean amaitu da.",
          playerXRanOutOfTime:
            "X jokalariak denbora agortu du. O jokalariak irabazten du!",
          playerORanOutOfTime:
            "O jokalariak denbora agortu du. X jokalariak irabazten du!",
          playerXWon: "X jokalariak irabazi du.",
          playerOWon: "O jokalariak irabazi du.",
          gameOver: "Jokoa Amaitua",
          theGameIsAlreadyOver: "Jokoa jada amaituta dago!",
          youMustPlayInTheIndicatedGrid:
            "Indikatutako taulan jolastu behar duzu!",
          thisGridIsAlreadyWon: "Taula hau jada irabazita dago!",
          thisCellIsAlreadyTaken: "Kasila hau jada hartuta dago!",
          difficultyChangedTo: "Zailtasun maila hauetara aldatu da",
          difficultyNames: {
            1: "Erraza",
            4: "Normala",
            8: "Zaila",
          },
          yourTurn: "Zure txanda",
          aiIsThinking: "AIak pentsatzen ari da",
          rule1:
            "Hiru Lerroren Joko Goratua 3x3 sare handi batean antolatutako 9 Hiru Lerroren Joko txikiz osatuta dago.",
          rule2:
            "Aurreko jokalariak bere taula txikian egindako azken mugimenduaren arabera, zure mugimendua egin behar duzu taula txiki horretara.",
          rule3:
            "Adibidea: aurkariak bere taula txikian goiko eskuineko kasillan jokatzen badu, zuek taula handiaren goiko eskuineko taula txikian jokatuko duzue.",
          rule4:
            "Iada irabazita edo beteta dagoen taula batera bidalita bazaraude, edozein taula libretan jolastu dezakezu.",
          rule5:
            "Taula txiki bat irabazteko, hiru sinbolo lerroan jarri behar dituzu, Hiru Lerroren Joko klasikoan bezala.",
          rule6:
            "Jokoa irabazteko, zure hiru taula txiki irabazitakoak lerroan jarri behar dituzu taula handian.",
          youDefeatedTheAI: "Zuk AIa garaitu duzu maila",
          theAIWon: "AIak irabazi du maila",
          developer: "Garilea",
          translator: "Itzultzailea",
          betaTesters: "Beta Probatzaileak",
          backToSettings: "Itzuli Ezarpenetara",
          translatorCredits:
      "- Alemaniera: BarthÃ©lÃ©my<br>- Ingelesa: BarthÃ©lÃ©my<br>- Gaztelania: Alexandre<br>- Euskara: Eneko<br>- Italiera: Alberico<br>- Suediera: Anton<br>- Errusiera: Louise<br>- Ukrainera: Louise<br>- Arabiera: Roudy<br>- Japoniera: Antonin<br>- Frantsesa: BarthÃ©lÃ©my",
    betaTestersCredits: "- EsmÃ©e<br>- Samuel<br>- AmÃ©dÃ©e",
        },
        uk: {
          info: "Ğ†Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ",
          level: "Ñ€Ñ–Ğ²ĞµĞ½ÑŒ",
          title: "Ğ£Ğ»ÑŒÑ‚Ğ¸Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ– Ñ…Ñ€ĞµÑÑ‚Ğ¸ĞºĞ¸-Ğ½ÑƒĞ»Ğ¸ĞºĞ¸",
          playAgainstAI: "Ğ“Ñ€Ğ°Ñ‚Ğ¸ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸ Ğ¨Ğ†",
          localMultiplayer: "Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»ĞµÑ”Ñ€",
          timedMode: "Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ· Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ¾Ğ¼",
          gameRules: "ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ³Ñ€Ğ¸",
          settings: "ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ",
          credits: "Ğ£Ñ‡Ğ°ÑĞ½Ğ¸ĞºĞ¸",
          creditsTitle: "Ğ£Ñ‡Ğ°ÑĞ½Ğ¸ĞºĞ¸ ğŸ‘·â€â™‚ï¸",
          difficulty: "Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ",
          close: "Ğ—Ğ°ĞºÑ€Ğ¸Ñ‚Ğ¸",
          continue: "ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ñ‚Ğ¸",
          newGame: "ĞĞ¾Ğ²Ğ° Ğ³Ñ€Ğ°",
          backToLobby: "ĞŸĞ¾Ğ²ĞµÑ€Ğ½ÑƒÑ‚Ğ¸ÑÑ Ğ´Ğ¾ Ğ»Ğ¾Ğ±Ñ–",
          language: "ĞœĞ¾Ğ²Ğ°",
          easy: "Ğ›ĞµĞ³ĞºĞ¾",
          normal: "ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾",
          difficult: "Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ğ¾",
          youArePlayingAs: "Ğ’Ğ¸ Ğ³Ñ€Ğ°Ñ”Ñ‚Ğµ Ğ·Ğ°",
          youGoFirst: "Ğ’Ğ¸ Ñ…Ğ¾Ğ´Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¼Ğ¸!",
          aiGoesFirst: "Ğ¨Ğ† Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¼!",
          youWon: "Ğ’Ğ¸ Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ»Ğ¸.",
          aiWon: "Ğ¨Ğ† Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ².",
          playerWon: "Ğ“Ñ€Ğ°Ğ²ĞµÑ†ÑŒ Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ².",
          gameEndedInDraw: "Ğ“Ñ€Ğ° Ğ·Ğ°ĞºÑ–Ğ½Ñ‡Ğ¸Ğ»Ğ°ÑÑŒ Ğ²Ğ½Ñ–Ñ‡Ğ¸Ñ.",
          playerXRanOutOfTime:
            "Ğ£ Ğ³Ñ€Ğ°Ğ²Ñ†Ñ X Ğ·Ğ°ĞºÑ–Ğ½Ñ‡Ğ¸Ğ²ÑÑ Ñ‡Ğ°Ñ. Ğ“Ñ€Ğ°Ğ²ĞµÑ†ÑŒ O Ğ¿ĞµÑ€ĞµĞ¼Ğ°Ğ³Ğ°Ñ”!",
          playerORanOutOfTime:
            "Ğ£ Ğ³Ñ€Ğ°Ğ²Ñ†Ñ O Ğ·Ğ°ĞºÑ–Ğ½Ñ‡Ğ¸Ğ²ÑÑ Ñ‡Ğ°Ñ. Ğ“Ñ€Ğ°Ğ²ĞµÑ†ÑŒ X Ğ¿ĞµÑ€ĞµĞ¼Ğ°Ğ³Ğ°Ñ”!",
          playerXWon: "Ğ“Ñ€Ğ°Ğ²ĞµÑ†ÑŒ X Ğ¿ĞµÑ€ĞµĞ¼Ñ–Ğ³.",
          playerOWon: "Ğ“Ñ€Ğ°Ğ²ĞµÑ†ÑŒ O Ğ¿ĞµÑ€ĞµĞ¼Ñ–Ğ³.",
          gameOver: "Ğ“Ñ€Ğ° Ğ·Ğ°ĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ°",
          theGameIsAlreadyOver: "Ğ“Ñ€Ğ° Ğ²Ğ¶Ğµ Ğ·Ğ°ĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ°!",
          youMustPlayInTheIndicatedGrid: "Ğ’Ğ¸ Ğ¿Ğ¾Ğ²Ğ¸Ğ½Ğ½Ñ– Ğ³Ñ€Ğ°Ñ‚Ğ¸ Ñƒ Ğ²ĞºĞ°Ğ·Ğ°Ğ½Ñ–Ğ¹ ÑÑ–Ñ‚Ñ†Ñ–!",
          thisGridIsAlreadyWon: "Ğ¦Ñ ÑÑ–Ñ‚ĞºĞ° Ğ²Ğ¶Ğµ Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ½Ğ°!",
          thisCellIsAlreadyTaken: "Ğ¦Ñ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ° Ğ²Ğ¶Ğµ Ğ·Ğ°Ğ¹Ğ½ÑÑ‚Ğ°!",
          difficultyChangedTo: "Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ Ğ·Ğ¼Ñ–Ğ½ĞµĞ½Ğ° Ğ½Ğ°",
          difficultyNames: {
            1: "Ğ›ĞµĞ³ĞºĞ¾",
            4: "ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾",
            8: "Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ğ¾",
          },
          yourTurn: "Ğ’Ğ°Ñˆ Ñ…Ñ–Ğ´",
          aiIsThinking: "Ğ¨Ğ† Ğ´ÑƒĞ¼Ğ°Ñ”",
          rule1:
            "Ğ£Ğ»ÑŒÑ‚Ğ¸Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ– Ñ…Ñ€ĞµÑÑ‚Ğ¸ĞºĞ¸-Ğ½ÑƒĞ»Ğ¸ĞºĞ¸ ÑĞºĞ»Ğ°Ğ´Ğ°ÑÑ‚ÑŒÑÑ Ğ· 9 Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ñ… ÑÑ–Ñ‚Ğ¾Ğº Ñ…Ñ€ĞµÑÑ‚Ğ¸ĞºÑ–Ğ²-Ğ½ÑƒĞ»Ğ¸ĞºÑ–Ğ², Ñ‰Ğ¾ ÑƒÑ‚Ğ²Ğ¾Ñ€ÑÑÑ‚ÑŒ Ğ¾Ğ´Ğ½Ñƒ Ğ²ĞµĞ»Ğ¸ĞºÑƒ ÑÑ–Ñ‚ĞºÑƒ.",
          rule2:
            "Ğ’Ğ¸ Ğ¿Ğ¾Ğ²Ğ¸Ğ½Ğ½Ñ– Ğ³Ñ€Ğ°Ñ‚Ğ¸ Ğ² ÑÑ–Ñ‚Ñ†Ñ–, ÑĞºĞ° Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ñ” Ğ¾ÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ñ†Ñ–, Ğ² ÑĞºÑƒ Ğ·Ñ–Ğ³Ñ€Ğ°Ğ² Ğ²Ğ°Ñˆ ÑÑƒĞ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸Ğº.",
          rule3:
            "ĞŸÑ€Ğ¸ĞºĞ»Ğ°Ğ´: ÑĞºÑ‰Ğ¾ Ğ²Ğ°Ñˆ ÑÑƒĞ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸Ğº Ğ³Ñ€Ğ°Ñ” Ñƒ Ğ¿Ñ€Ğ°Ğ²Ñ–Ğ¹ Ğ²ĞµÑ€Ñ…Ğ½Ñ–Ğ¹ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ñ†Ñ–, Ğ²Ğ¸ Ğ¿Ğ¾Ğ²Ğ¸Ğ½Ğ½Ñ– Ğ³Ñ€Ğ°Ñ‚Ğ¸ Ñƒ Ğ¿Ñ€Ğ°Ğ²Ñ–Ğ¹ Ğ²ĞµÑ€Ñ…Ğ½Ñ–Ğ¹ ÑÑ–Ñ‚Ñ†Ñ–.",
          rule4:
            "Ğ¯ĞºÑ‰Ğ¾ Ğ²Ğ°Ñ Ğ²Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ² ÑÑ–Ñ‚ĞºÑƒ, ÑĞºĞ° Ğ²Ğ¶Ğµ Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ½Ğ° Ğ°Ğ±Ğ¾ Ğ·Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ°, Ğ²Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ³Ñ€Ğ°Ñ‚Ğ¸ Ğ² Ğ±ÑƒĞ´ÑŒ-ÑĞºÑ–Ğ¹ Ğ²Ñ–Ğ´ĞºÑ€Ğ¸Ñ‚Ñ–Ğ¹ ÑÑ–Ñ‚Ñ†Ñ–.",
          rule5:
            "Ğ©Ğ¾Ğ± Ğ²Ğ¸Ğ³Ñ€Ğ°Ñ‚Ğ¸ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºÑƒ ÑÑ–Ñ‚ĞºÑƒ, Ğ²Ğ¸Ğ±ÑƒĞ´Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ 3 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¸ Ğ² Ñ€ÑĞ´, ÑĞº Ñƒ ĞºĞ»Ğ°ÑĞ¸Ñ‡Ğ½Ğ¸Ñ… Ñ…Ñ€ĞµÑÑ‚Ğ¸ĞºĞ°Ñ…-Ğ½ÑƒĞ»Ğ¸ĞºĞ°Ñ….",
          rule6: "Ğ©Ğ¾Ğ± Ğ²Ğ¸Ğ³Ñ€Ğ°Ñ‚Ğ¸ Ğ³Ñ€Ñƒ, Ğ²Ğ¸Ğ±ÑƒĞ´Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ 3 ÑÑ–Ñ‚ĞºĞ¸ Ğ² Ñ€ÑĞ´.",
          youDefeatedTheAI: "Ğ’Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼Ğ¾Ğ³Ğ»Ğ¸ Ğ¨Ğ† Ğ½Ğ°",
          theAIWon: "Ğ¨Ğ† Ğ¿ĞµÑ€ĞµĞ¼Ñ–Ğ³ Ğ½Ğ°",
          developer: "Ğ Ğ¾Ğ·Ñ€Ğ¾Ğ±Ğ½Ğ¸Ğº",
          translator: "ĞŸĞµÑ€ĞµĞºĞ»Ğ°Ğ´Ğ°Ñ‡",
          betaTesters: "Ğ‘ĞµÑ‚Ğ°-Ñ‚ĞµÑÑ‚ÑƒĞ²Ğ°Ğ»ÑŒĞ½Ğ¸ĞºĞ¸",
          backToSettings: "ĞŸĞ¾Ğ²ĞµÑ€Ğ½ÑƒÑ‚Ğ¸ÑÑ Ğ´Ğ¾ Ğ½Ğ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½ÑŒ",
          translatorCredits:
      "- ĞÑ–Ğ¼ĞµÑ†ÑŒĞºĞ°: Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ñ–<br>- ĞĞ½Ğ³Ğ»Ñ–Ğ¹ÑÑŒĞºĞ°: Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ñ–<br>- Ğ†ÑĞ¿Ğ°Ğ½ÑÑŒĞºĞ°: ĞĞ»ĞµĞºÑĞ°Ğ½Ğ´Ñ€<br>- Ğ‘Ğ°ÑĞºÑÑŒĞºĞ°: Ğ•Ğ½ĞµĞºĞ¾<br>- Ğ†Ñ‚Ğ°Ğ»Ñ–Ğ¹ÑÑŒĞºĞ°: ĞĞ»ÑŒĞ±ĞµÑ€Ñ–ĞºĞ¾<br>- Ğ¨Ğ²ĞµĞ´ÑÑŒĞºĞ°: ĞĞ½Ñ‚Ğ¾Ğ½<br>- Ğ Ğ¾ÑÑ–Ğ¹ÑÑŒĞºĞ°: Ğ›ÑƒÑ—Ğ·Ğ°<br>- Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°: Ğ›ÑƒÑ—Ğ·Ğ°<br>- ĞÑ€Ğ°Ğ±ÑÑŒĞºĞ°: Ğ ÑƒĞ´Ñ–<br>- Ğ¯Ğ¿Ğ¾Ğ½ÑÑŒĞºĞ°: ĞĞ½Ñ‚ÑƒĞ°Ğ½<br>- Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑŒĞºĞ°: Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ñ–",
    betaTestersCredits: "- Ğ•ÑĞ¼Ğµ<br>- Ğ¡Ğ°Ğ¼ÑƒĞµĞ»ÑŒ<br>- ĞĞ¼ĞµĞ´Ğµ",
        },
      };
      const developerNames = {
  en: "BarthÃ©lÃ©my",
  fr: "BarthÃ©lÃ©my",
  de: "BarthÃ©lÃ©my",
  it: "BarthÃ©lÃ©my",
  es: "BarthÃ©lÃ©my",
  ar: "Ø¨Ø§Ø±ØªÙ„ÙŠÙ…ÙŠ",
  zh: "å·´æ‰˜æ´›æ¢…",
  ja: "ãƒãƒ«ãƒ†ãƒ¬ãƒŸãƒ¼",
  ru: "Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ğ¸",
  sv: "BarthÃ©lÃ©my",
  hi: "à¤¬à¤¾à¤°à¥à¤¥à¥‡à¤²à¥à¤®à¥€",
  pt: "BarthÃ©lÃ©my",
  eu: "BarthÃ©lÃ©my",
  uk: "Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ñ–"
};
      // Constantes pour la rÃ©utilisation
      const INITIAL_GAME_STATE = {
        view: "lobby",
        playerId: `player_${Math.random().toString(36).substring(2, 9)}`,
        playerSymbol: null,
        currentTurn: "X",
        activeBoard: null,
        boardStates: Array(9)
          .fill()
          .map(() => Array(9).fill(null)),
        smallBoardWinners: Array(9).fill(null),
        gameWinner: null,
        tooltipMessage: "",
        tooltipVisible: false,
        gameMode: "ai",
        playerTimes: {
          X: 60,
          O: 60,
        },
        activeTimer: null,
        darkMode: false,
        difficulty: "medium",
        language: "en",
      };
      const WIN_PATTERNS = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6],
      ];
      let gameState = { ...INITIAL_GAME_STATE };
      let aiWorker;
      // Helper functions
      function checkWinSmallBoard(board) {
        return WIN_PATTERNS.some(
          ([a, b, c]) =>
            board[a] && board[a] === board[b] && board[a] === board[c]
        );
      }
      function checkWinBigBoard(winners) {
        return WIN_PATTERNS.some(
          ([a, b, c]) =>
            winners[a] &&
            winners[a] !== "draw" &&
            winners[a] === winners[b] &&
            winners[a] === winners[c]
        );
      }
      function applyFadeInAnimation(element) {
        element.classList.add("fade-in");
        setTimeout(() => {
          element.classList.remove("fade-in");
        }, 300); 
      }
      function applyFadeInAnimation(element) {
        if (element) {
          element.classList.add("fade-in");
          setTimeout(() => {
            element.classList.remove("fade-in");
          }, 500); 
        }
      }
      function isBoardFull(board) {
        return board.every((cell) => cell !== null);
      }
      function isBigBoardFull(winners, boardStates) {
        if (winners.every((winner) => winner !== null)) return true;
        return !boardStates.some(
          (board, i) =>
            winners[i] === null && board.some((cell) => cell === null)
        );
      }
      function adjustGameBoardSize() {
        const viewportWidth = window.innerWidth;
        const gameBoard = document.querySelector(".game-board");
        if (!gameBoard) return;
        if (viewportWidth < 360) {
          gameBoard.style.maxWidth = "270px";
        } else if (viewportWidth < 400) {
          gameBoard.style.maxWidth = "310px";
        } else if (viewportWidth < 500) {
          gameBoard.style.maxWidth = "390px";
        } else {
          gameBoard.style.maxWidth = "512px";
        }
        const cells = document.querySelectorAll(".cell");
        const smallBoards = document.querySelectorAll(".small-board");
        if (viewportWidth < 360) {
          smallBoards.forEach((board) => {
            board.style.gap = "0px";
            board.style.padding = "1px";
          });
        } else if (viewportWidth < 400) {
          smallBoards.forEach((board) => {
            board.style.gap = "1px";
            board.style.padding = "1px";
          });
        }
      }
      function postRenderAdjustments() {
        adjustGameBoardSize();
        const smallBoards = document.querySelectorAll(".small-board");
        smallBoards.forEach((board, index) => {
          if (
            gameState.activeBoard === index &&
            gameState.smallBoardWinners[index] === null
          ) {
            const viewportWidth = window.innerWidth;
            if (viewportWidth < 400) {
              board.style.transform = "scale(1.02)";
              board.style.boxShadow = "0 0 0 2px #fbbf24";
            }
          }
        });
        ensureSquareCells();
      }
      function ensureSquareCells() {
        const cells = document.querySelectorAll(".cell");
        cells.forEach((cell) => {
          const width = cell.offsetWidth;
          cell.style.height = `${width}px`;
        });
      }
      function showTooltip(message) {
        const lang = gameState.language;
        const translatedMessage = translations[lang][message] || message;
        gameState.tooltipMessage = translatedMessage;
        gameState.tooltipVisible = true;
        const tooltip = document.getElementById("tooltip");
        tooltip.textContent = translatedMessage;
        tooltip.style.display = "block";
        tooltip.classList.remove("exit");
        tooltip.classList.add("tooltip");
        // Appliquer l'animation de fondu
        applyFadeInAnimation(tooltip);
        setTimeout(() => {
          gameState.tooltipVisible = false;
          tooltip.style.display = "none";
        }, 2000);
      }
      function toggleDarkMode() {
        gameState.darkMode = !gameState.darkMode;
        document.body.classList.toggle("dark", gameState.darkMode);
        document.body.classList.toggle("bg-gray-100", !gameState.darkMode);
        renderView();
      }
      function startNewGame(mode = "ai") {
        const difficultyDropdown = document.getElementById("difficulty");
        const difficulty =
          mode === "timed"
            ? "4"
            : difficultyDropdown
            ? difficultyDropdown.value
            : gameState.difficulty;
        const darkMode = gameState.darkMode;
        gameState = { ...INITIAL_GAME_STATE };
        gameState.darkMode = darkMode;
        gameState.view = "game";
        gameState.gameMode = mode;
        gameState.difficulty = difficulty;
        gameState.playerSymbol = "X";
        gameState.currentTurn = Math.random() < 0.5 ? "X" : "O";
        if (mode === "timed") {
          gameState.playerTimes = {
            X: 60,
            O: 60,
          };
        }
        renderView();
        // Appliquer l'animation de fondu
        const gameContainer = document.querySelector("#app .container");
        applyFadeInAnimation(gameContainer);
        if (mode === "ai" || mode === "timed") {
          const modal = renderFirstPlayerModal();
          document.body.appendChild(modal);
        }
      }
      function showRules() {
        gameState.view = "rules";
        renderView();
      }
      function showCredits() {
        gameState.view = "credits";
        renderView();
      }
      function backToLobby() {
        if (gameState.activeTimer) {
          clearInterval(gameState.activeTimer);
          gameState.activeTimer = null;
        }
        gameState.playerTimes = {
          X: 60,
          O: 60,
        };
        const darkMode = gameState.darkMode;
        gameState = { ...INITIAL_GAME_STATE };
        gameState.view = "lobby";
        gameState.preventAIMove = true;
        gameState.darkMode = darkMode;
        // Restaurer la langue depuis localStorage
        const savedLanguage = localStorage.getItem("selectedLanguage");
        if (savedLanguage) {
          gameState.language = savedLanguage;
        }
        renderView();
        // Appliquer l'animation de fondu
        const lobbyContainer = document.querySelector("#app .container");
        applyFadeInAnimation(lobbyContainer);
      }
      function startTimer(player) {
        if (gameState.activeTimer) {
          clearInterval(gameState.activeTimer);
          gameState.activeTimer = null;
        }
        gameState.activeTimer = setInterval(() => {
          if (gameState.playerTimes[player] > 0 && !gameState.gameWinner) {
            gameState.playerTimes[player]--;
            renderView();
          } else {
            clearInterval(gameState.activeTimer);
            if (!gameState.gameWinner) {
              gameState.gameWinner = player === "X" ? "O" : "X";
            }
            renderView();
          }
        }, 1000);
      }
      function pauseTimer() {
        if (gameState.activeTimer) {
          clearInterval(gameState.activeTimer);
          gameState.activeTimer = null;
        }
      }
      function handleSquareClick(bigIndex, smallIndex) {
        const {
          gameWinner,
          gameMode,
          currentTurn,
          playerSymbol,
          activeBoard,
          smallBoardWinners,
          boardStates,
        } = gameState;
        if (gameWinner) {
          showTooltip("theGameIsAlreadyOver");
          return;
        }
        if (activeBoard !== null && activeBoard !== bigIndex) {
          showTooltip("youMustPlayInTheIndicatedGrid");
          return;
        }
        if (smallBoardWinners[bigIndex] !== null) {
          showTooltip("thisGridIsAlreadyWon");
          return;
        }
        if (boardStates[bigIndex][smallIndex] !== null) {
          showTooltip("thisCellIsAlreadyTaken");
          return;
        }
        const newBoardStates = JSON.parse(JSON.stringify(boardStates));
        newBoardStates[bigIndex][smallIndex] = currentTurn;
        const newSmallBoardWinners = [...gameState.smallBoardWinners];
        if (checkWinSmallBoard(newBoardStates[bigIndex])) {
          newSmallBoardWinners[bigIndex] = currentTurn;
        } else if (isBoardFull(newBoardStates[bigIndex])) {
          newSmallBoardWinners[bigIndex] = "draw";
        }
        let nextActiveBoard = smallIndex;
        if (newSmallBoardWinners[smallIndex] !== null) {
          nextActiveBoard = null;
        }
        let newGameWinner = null;
        if (checkWinBigBoard(newSmallBoardWinners)) {
          newGameWinner = currentTurn;
        } else if (isBigBoardFull(newSmallBoardWinners, newBoardStates)) {
          newGameWinner = "draw";
        }
        gameState = {
          ...gameState,
          boardStates: newBoardStates,
          smallBoardWinners: newSmallBoardWinners,
          currentTurn: currentTurn === "X" ? "O" : "X",
          activeBoard: nextActiveBoard,
          gameWinner: newGameWinner,
          lastMove: { bigIndex, smallIndex },
        };
        renderView();
        if (gameMode === "timed") {
          pauseTimer();
          if (!newGameWinner) {
            startTimer(gameState.currentTurn);
          }
        }
        if (
          (gameMode === "ai" || gameMode === "timed") &&
          !newGameWinner &&
          gameState.currentTurn !== playerSymbol
        ) {
          setTimeout(() => simulateOpponentMove(), 1000);
        }
      }
      function simulateOpponentMove() {
        if (gameState.preventAIMove) {
          return;
        }
        const {
          activeBoard,
          boardStates,
          smallBoardWinners,
          currentTurn,
          difficulty,
          gameMode,
        } = gameState;
        const opponentSymbol = currentTurn;
        const playerSymbol = opponentSymbol === "X" ? "O" : "X";
        let maxDepth;
        switch (difficulty) {
          case "1":
            maxDepth = 1;
            break;
          case "4":
            maxDepth = 4;
            break;
          case "8":
            maxDepth = 8;
            break;
          default:
            maxDepth = 4;
        }
        const isFirstMove = boardStates.every((board) =>
          board.every((cell) => cell === null)
        );
        if (isFirstMove) {
          const validMoves = findValidMoves(
            activeBoard,
            boardStates,
            smallBoardWinners
          );
          if (validMoves.length > 0) {
            const [bigIndex, smallIndex] =
              validMoves[Math.floor(Math.random() * validMoves.length)];
            const delay = gameMode === "timed" ? 900 : 0;
            setTimeout(() => handleSquareClick(bigIndex, smallIndex), delay);
            return;
          }
        }
        // Check if AI can win in one move
        const winningMove = findWinningMove(
          activeBoard,
          boardStates,
          smallBoardWinners,
          opponentSymbol
        );
        if (winningMove) {
          const delay = gameMode === "timed" ? 900 : 0;
          setTimeout(
            () => handleSquareClick(winningMove[0], winningMove[1]),
            delay
          );
          return;
        }
        // Check if the player can win in the next move and block them
        const blockingMove = findBlockingMove(
          activeBoard,
          boardStates,
          smallBoardWinners,
          playerSymbol
        );
        if (blockingMove) {
          const delay = gameMode === "timed" ? 900 : 0;
          setTimeout(
            () => handleSquareClick(blockingMove[0], blockingMove[1]),
            delay
          );
          return;
        }
        // If no immediate win or block, use minimax
        if (!aiWorker) {
          aiWorker = new Worker("aiWorker.js");
        }
        aiWorker.onmessage = function (e) {
          const bestMove = e.data;
          if (bestMove) {
            const delay = gameMode === "timed" ? 900 : 0;
            setTimeout(
              () => handleSquareClick(bestMove[0], bestMove[1]),
              delay
            );
          } else {
            const validMoves = findValidMoves(
              activeBoard,
              boardStates,
              smallBoardWinners
            );
            if (validMoves.length > 0) {
              const [bigIndex, smallIndex] =
                validMoves[Math.floor(Math.random() * validMoves.length)];
              const delay = gameMode === "timed" ? 900 : 0;
              setTimeout(() => handleSquareClick(bigIndex, smallIndex), delay);
            }
          }
        };
        aiWorker.postMessage({
          activeBoard,
          boardStates,
          smallBoardWinners,
          aiSymbol: opponentSymbol,
          playerSymbol,
          depth: maxDepth,
        });
      }
      function findWinningMove(
        activeBoard,
        boardStates,
        smallBoardWinners,
        symbol
      ) {
        const validMoves = findValidMoves(
          activeBoard,
          boardStates,
          smallBoardWinners
        );
        for (const [bigIndex, smallIndex] of validMoves) {
          const newBoardStates = JSON.parse(JSON.stringify(boardStates));
          newBoardStates[bigIndex][smallIndex] = symbol;
          if (checkWinSmallBoard(newBoardStates[bigIndex])) {
            return [bigIndex, smallIndex];
          }
        }
        return null;
      }
      function findBlockingMove(
        activeBoard,
        boardStates,
        smallBoardWinners,
        symbol
      ) {
        const validMoves = findValidMoves(
          activeBoard,
          boardStates,
          smallBoardWinners
        );
        for (const [bigIndex, smallIndex] of validMoves) {
          const newBoardStates = JSON.parse(JSON.stringify(boardStates));
          newBoardStates[bigIndex][smallIndex] = symbol;
          if (checkWinSmallBoard(newBoardStates[bigIndex])) {
            return [bigIndex, smallIndex];
          }
        }
        return null;
      }
      function findValidMoves(activeBoard, boardStates, smallBoardWinners) {
        const validMoves = [];
        if (activeBoard === null || smallBoardWinners[activeBoard] !== null) {
          for (let i = 0; i < 9; i++) {
            if (smallBoardWinners[i] === null) {
              for (let j = 0; j < 9; j++) {
                if (boardStates[i][j] === null) {
                  validMoves.push([i, j]);
                }
              }
            }
          }
        } else {
          for (let j = 0; j < 9; j++) {
            if (boardStates[activeBoard][j] === null) {
              validMoves.push([activeBoard, j]);
            }
          }
        }
        return validMoves;
      }
      function renderCell(bigIndex, smallIndex) {
        const {
          boardStates,
          gameMode,
          currentTurn,
          activeBoard,
          smallBoardWinners,
          darkMode,
          lastMove,
        } = gameState;
        const value = boardStates[bigIndex][smallIndex];
        const theme = darkMode ? "dark" : "light";
        let cellClass = "cell ";
        if (value === null) {
          const isInteractive =
            ((gameMode === "ai" || gameMode === "timed") &&
              "X" === currentTurn) ||
            gameMode === "local";
          const isValidTarget =
            (activeBoard === null || activeBoard === bigIndex) &&
            smallBoardWinners[bigIndex] === null;
          cellClass += theme === "dark" ? "bg-gray-800 " : "bg-white ";
          if (isInteractive && isValidTarget) {
            cellClass +=
              theme === "dark" ? "hover:bg-gray-600 " : "hover:bg-blue-100 ";
            cellClass += "valid";
          }
        } else {
          cellClass += theme === "dark" ? "bg-gray-800 " : "bg-white ";
        }
        const cell = document.createElement("div");
        cell.className = cellClass;
        if (value) {
          const symbol = document.createElement("span");
          symbol.className = `symbol ${
            value === "X" ? "text-red-500 font-bold" : "text-blue-500 font-bold"
          } ${
            lastMove &&
            lastMove.bigIndex === bigIndex &&
            lastMove.smallIndex === smallIndex
              ? "enhanced-bounce"
              : ""
          }`;
          symbol.textContent = value;
          if (
            lastMove &&
            lastMove.bigIndex === bigIndex &&
            lastMove.smallIndex === smallIndex
          ) {
            setTimeout(() => {
              symbol.classList.remove("enhanced-bounce");
            }, 700);
          }
          cell.appendChild(symbol);
        }
        const columnPosition = smallIndex % 3;
        cell.dataset.column = columnPosition;
        cell.dataset.row = Math.floor(smallIndex / 3);
        if (cellClass.includes("valid")) {
          cell.addEventListener("click", () =>
            handleSquareClick(bigIndex, smallIndex)
          );
        }
        return cell;
      }
      function renderSmallBoard(index) {
        const { activeBoard, smallBoardWinners, darkMode } = gameState;
        const winner = smallBoardWinners[index];
        const theme = darkMode ? "dark" : "light";
        const viewportWidth = window.innerWidth;
        const boardDiv = document.createElement("div");
        boardDiv.className = `small-board ${
          theme === "dark" ? "border-gray-700" : "border-gray-300"
        }`;
        boardDiv.style.display = "grid";
        boardDiv.style.gridTemplateColumns = "repeat(3, 1fr)";
        boardDiv.style.gridTemplateRows = "repeat(3, 1fr)";
        if (activeBoard === index && winner === null) {
          boardDiv.classList.add("active");
          if (viewportWidth < 400) {
            boardDiv.style.transform = "scale(1.02)";
            boardDiv.style.boxShadow = `0 0 0 2px ${
              theme === "dark" ? "#f59e0b" : "#fbbf24"
            }`;
          } else {
            boardDiv.style.boxShadow = `0 0 0 4px ${
              theme === "dark" ? "#f59e0b" : "#fbbf24"
            }`;
          }
        }
        if (winner !== null) {
          if (winner === "draw") {
            boardDiv.classList.add("draw");
          } else {
            boardDiv.classList.add(winner === "X" ? "won-x" : "won-o");
          }
        }
        if (winner !== null && winner !== "draw") {
          const winnerOverlay = document.createElement("div");
          winnerOverlay.className = "winner-overlay";
          const symbol = document.createElement("span");
          symbol.className = winner === "X" ? "text-red-500" : "text-blue-500";
          symbol.textContent = winner;
          winnerOverlay.appendChild(symbol);
          boardDiv.appendChild(winnerOverlay);
        } else {
          for (let i = 0; i < 9; i++) {
            boardDiv.appendChild(renderCell(index, i));
          }
        }
        return boardDiv;
      }
      function renderGameBoard() {
        const { darkMode } = gameState;
        const theme = darkMode ? "dark" : "light";
        const boardContainer = document.createElement("div");
        boardContainer.className = `game-board ${
          theme === "dark"
            ? "bg-gray-900 border-gray-700"
            : "bg-gray-100 border-gray-300"
        }`;
        boardContainer.style.display = "grid";
        boardContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
        boardContainer.style.gridTemplateRows = "repeat(3, 1fr)";
        const viewportWidth = window.innerWidth;
        if (viewportWidth < 360) {
          boardContainer.style.gap = "4px";
          boardContainer.style.padding = "4px";
        } else if (viewportWidth < 400) {
          boardContainer.style.gap = "6px";
          boardContainer.style.padding = "6px";
        } else if (viewportWidth < 512) {
          boardContainer.style.gap = "8px";
          boardContainer.style.padding = "8px";
        } else {
          boardContainer.style.gap = "16px";
          boardContainer.style.padding = "16px";
        }
        for (let i = 0; i < 9; i++) {
          boardContainer.appendChild(renderSmallBoard(i));
        }
        return boardContainer;
      }
      function renderGameInfo() {
        const { gameMode, currentTurn, darkMode, playerTimes, language } =
          gameState;
        const theme = darkMode ? "dark" : "light";
        const lang = language;
        const infoDiv = document.createElement("div");
        infoDiv.className = `game-info ${
          theme === "dark" ? "text-white" : "text-gray-900"
        }`;
        const header = document.createElement("div");
        header.className = "game-info-header header-responsive";
        const modeTitleContainer = document.createElement("div");
        modeTitleContainer.className = "mode-title-container";
        modeTitleContainer.style.padding = "8px";
        modeTitleContainer.style.borderRadius = "8px";
        modeTitleContainer.style.display = "inline-block";
        modeTitleContainer.style.backgroundColor = darkMode
          ? "#4b5563"
          : "#d1d5db";
        const modeTitle = document.createElement("h2");
        modeTitle.className = "text-2xl font-bold";
        modeTitle.textContent =
          gameMode === "ai"
            ? translations[lang].playAgainstAI
            : gameMode === "local"
            ? translations[lang].localMultiplayer
            : translations[lang].timedMode;
        modeTitleContainer.appendChild(modeTitle);
        const settingsBtn = document.createElement("button");
        settingsBtn.className = "p-2 rounded-full";
        settingsBtn.style.position = "absolute";
        settingsBtn.style.left = "0";
        settingsBtn.style.backgroundColor = darkMode ? "#374151" : "#e5e7eb";
        settingsBtn.style.color = darkMode ? "#e5e7eb" : "#1f2937";
        settingsBtn.textContent = "âš™ï¸";
        settingsBtn.addEventListener("click", () => {
          const modal = renderSettingsModal();
          document.body.appendChild(modal);
        });
        const toggleBtn = document.createElement("button");
        toggleBtn.className = "p-2 rounded-full";
        toggleBtn.style.position = "absolute";
        toggleBtn.style.right = "0";
        toggleBtn.style.backgroundColor = darkMode ? "#374151" : "#e5e7eb";
        toggleBtn.style.color = darkMode ? "#e5e7eb" : "#1f2937";
        toggleBtn.textContent = darkMode ? "â˜€ï¸" : "ğŸŒ™";
        toggleBtn.addEventListener("click", toggleDarkMode);
        header.appendChild(settingsBtn);
        header.appendChild(modeTitleContainer);
        header.appendChild(toggleBtn);
        infoDiv.appendChild(header);
        if (gameMode === "timed") {
          const timers = document.createElement("div");
          timers.className = "player-info";
          const timerXContainer = document.createElement("div");
          timerXContainer.className = `player-box ${
            currentTurn === "X"
              ? theme === "dark"
                ? "bg-blue-900 zoom"
                : "bg-blue-100 zoom"
              : theme === "dark"
              ? "bg-gray-700"
              : "bg-gray-100"
          }`;
          timerXContainer.innerHTML = `<span class="text-red-500 font-bold">ğŸ‘¤ X : ${playerTimes.X}s</span>`;
          const timerOContainer = document.createElement("div");
          timerOContainer.className = `player-box ${
            currentTurn === "O"
              ? theme === "dark"
                ? "bg-blue-900 zoom"
                : "bg-blue-100 zoom"
              : theme === "dark"
              ? "bg-gray-700"
              : "bg-gray-100"
          }`;
          timerOContainer.innerHTML = `<span class="text-blue-500 font-bold">ğŸ¤– O : ${playerTimes.O}s</span>`;
          timers.appendChild(timerXContainer);
          timers.appendChild(timerOContainer);
          infoDiv.appendChild(timers);
        } else if (gameMode === "local") {
          const playerInfo = document.createElement("div");
          playerInfo.className = "player-info";
          const playerX = document.createElement("div");
          playerX.className = `player-box ${
            currentTurn === "X"
              ? theme === "dark"
                ? "bg-blue-900 zoom"
                : "bg-blue-100 zoom"
              : theme === "dark"
              ? "bg-gray-700"
              : "bg-gray-100"
          }`;
          playerX.innerHTML = `<span class="text-red-500 font-bold">X</span>${
            currentTurn === "X" ? " - " + translations[lang].yourTurn : ""
          }`;
          const playerO = document.createElement("div");
          playerO.className = `player-box ${
            currentTurn === "O"
              ? theme === "dark"
                ? "bg-blue-900 zoom"
                : "bg-blue-100 zoom"
              : theme === "dark"
              ? "bg-gray-700"
              : "bg-gray-100"
          }`;
          playerO.innerHTML = `<span class="text-blue-500 font-bold">O</span>${
            currentTurn === "O" ? " - " + translations[lang].yourTurn : ""
          }`;
          playerInfo.appendChild(playerX);
          playerInfo.appendChild(playerO);
          infoDiv.appendChild(playerInfo);
        } else if (gameMode === "ai") {
          const playerInfo = document.createElement("div");
          playerInfo.className = "player-info";
          const playerSymbolElement = document.createElement("div");
          playerSymbolElement.className = `player-box ${
            currentTurn === "X"
              ? theme === "dark"
                ? "bg-blue-900 zoom"
                : "bg-blue-100 zoom"
              : theme === "dark"
              ? "bg-gray-700"
              : "bg-gray-100"
          }`;
          playerSymbolElement.innerHTML = `<span class="text-red-500 font-bold">ğŸ‘¤ X</span>${
            currentTurn === "X" ? " - " + translations[lang].yourTurn : ""
          }`;
          const aiSymbolElement = document.createElement("div");
          aiSymbolElement.className = `player-box ${
            currentTurn === "O"
              ? theme === "dark"
                ? "bg-blue-900 zoom"
                : "bg-blue-100 zoom"
              : theme === "dark"
              ? "bg-gray-700"
              : "bg-gray-100"
          }`;
          aiSymbolElement.innerHTML = `<span class="text-blue-500 font-bold">ğŸ¤– O</span>${
            currentTurn === "O" ? " - " + translations[lang].aiIsThinking : ""
          }`;
          playerInfo.appendChild(playerSymbolElement);
          playerInfo.appendChild(aiSymbolElement);
          infoDiv.appendChild(playerInfo);
        }
        const controls = document.createElement("div");
        controls.className = "mt-4 flex justify-center gap-2";
        const newGameBtn = document.createElement("button");
        newGameBtn.className =
          "bg-blue-500 text-white px-4 py-2 rounded-button hover:bg-blue-600";
        newGameBtn.textContent = translations[lang].newGame;
        newGameBtn.addEventListener("click", () => {
          if (gameState.gameMode === "timed") {
            pauseTimer();
          }
          startNewGame(gameState.gameMode);
        });
        const lobbyBtn = document.createElement("button");
        lobbyBtn.className =
          "bg-gray-500 text-white px-4 py-2 rounded-button hover:bg-gray-600";
        lobbyBtn.textContent = translations[lang].backToLobby;
        lobbyBtn.addEventListener("click", backToLobby);
        controls.appendChild(newGameBtn);
        controls.appendChild(lobbyBtn);
        infoDiv.appendChild(controls);
        return infoDiv;
      }
      function renderTurnIndicator() {
        return document.createElement("div");
      }
      function renderGameOverModal() {
        const {
          gameWinner,
          gameMode,
          darkMode,
          difficulty,
          playerTimes,
          language,
        } = gameState;
        if (!gameWinner) return null;
        const theme = darkMode ? "dark" : "light";
        const lang = language;
        let message = "";
        let iconSymbol = "";
        let additionalInfo = "";
        const difficultyName =
          translations[lang].difficultyNames[difficulty] ||
          translations[lang].difficult;
        if (gameWinner === "draw") {
          message = translations[lang].gameEndedInDraw;
          iconSymbol = "ğŸ¤";
          additionalInfo = "";
        } else if (gameMode === "ai") {
          message =
            gameWinner === "X"
              ? translations[lang].youWon
              : translations[lang].aiWon;
          iconSymbol = gameWinner === "X" ? "ğŸ‘¤" : "ğŸ¤–";
          additionalInfo =
            gameWinner === "X"
              ? `${translations[lang].youDefeatedTheAI} ${translations[lang].level} ${difficultyName}.`
              : `${translations[lang].theAIWon} ${translations[lang].level} ${difficultyName}.`;
        } else if (gameMode === "timed") {
          if (playerTimes.X <= 0 || playerTimes.O <= 0) {
            message =
              gameWinner === "X"
                ? translations[lang].playerORanOutOfTime
                : translations[lang].playerXRanOutOfTime;
            iconSymbol = gameWinner === "X" ? "ğŸ‘¤" : "ğŸ¤–";
          } else {
            message =
              gameWinner === "X"
                ? translations[lang].youWon
                : translations[lang].aiWon;
            iconSymbol = gameWinner === "X" ? "ğŸ‘¤" : "ğŸ¤–";
          }
          additionalInfo = "";
        } else {
          message =
            gameWinner === "X"
              ? translations[lang].playerXWon
              : translations[lang].playerOWon;
          iconSymbol = gameWinner === "X" ? "ğŸ‘¤" : "ğŸ¤–";
          additionalInfo = "";
        }
        const overlay = document.createElement("div");
        overlay.className = "modal-overlay";
        const modal = document.createElement("div");
        modal.className = `modal-content ${
          theme === "dark"
            ? "bg-gray-800 text-white border-gray-700"
            : "bg-white text-gray-900 border-gray-300"
        } border`;
        const header = document.createElement("div");
        header.className = "modal-header";
        const icon = document.createElement("div");
        icon.className = "text-5xl mb-4";
        icon.textContent = iconSymbol;
        const title = document.createElement("h2");
        title.className = "text-2xl font-bold mb-2";
        title.textContent = message;
        const info = document.createElement("p");
        info.className = "text-lg mb-4";
        info.textContent = additionalInfo;
        header.appendChild(icon);
        header.appendChild(title);
        header.appendChild(info);
        const buttons = document.createElement("div");
        buttons.className =
          window.innerWidth < 400
            ? "modal-buttons flex flex-col gap-2"
            : "modal-buttons flex gap-2";
        const newGameBtn = document.createElement("button");
        newGameBtn.className =
          "bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1";
        newGameBtn.textContent = translations[lang].newGame;
        newGameBtn.addEventListener("click", () => {
          closeMessage(overlay);
          startNewGame(gameMode);
        });
        const lobbyBtn = document.createElement("button");
        lobbyBtn.className =
          "bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 flex-1";
        lobbyBtn.textContent = translations[lang].backToLobby;
        lobbyBtn.addEventListener("click", () => {
          closeMessage(overlay);
          backToLobby();
        });
        buttons.appendChild(newGameBtn);
        buttons.appendChild(lobbyBtn);
        modal.appendChild(header);
        modal.appendChild(buttons);
        overlay.appendChild(modal);
        return overlay;
      }
      function renderLobbyView() {
        const { darkMode, language } = gameState;
        const theme = darkMode ? "dark" : "light";
        const lang = language;
        const lobby = document.createElement("div");
        lobby.className = `lobby-view ${
          theme === "dark" ? "bg-gray-800 text-white" : "bg-white text-gray-900"
        }`;
        const header = document.createElement("div");
        header.className = "header-responsive mb-4";
        const title = document.createElement("h1");
        title.className = "text-2xl font-bold title-responsive";
        title.textContent = translations[lang].title;
        const settingsBtn = document.createElement("button");
        settingsBtn.className = "p-2 rounded-full";
        settingsBtn.style.position = "absolute";
        settingsBtn.style.left = "0";
        settingsBtn.style.backgroundColor = darkMode ? "#374151" : "#e5e7eb";
        settingsBtn.style.color = darkMode ? "#e5e7eb" : "#1f2937";
        settingsBtn.textContent = "âš™ï¸";
        settingsBtn.addEventListener("click", () => {
          const modal = renderSettingsModal();
          document.body.appendChild(modal);
        });
        const toggleBtn = document.createElement("button");
        toggleBtn.className = "p-2 rounded-full";
        toggleBtn.style.position = "absolute";
        toggleBtn.style.right = "0";
        toggleBtn.style.backgroundColor = darkMode ? "#374151" : "#e5e7eb";
        toggleBtn.style.color = darkMode ? "#e5e7eb" : "#1f2937";
        toggleBtn.textContent = darkMode ? "â˜€ï¸" : "ğŸŒ™";
        toggleBtn.addEventListener("click", toggleDarkMode);
        header.appendChild(settingsBtn);
        header.appendChild(title);
        header.appendChild(toggleBtn);
        lobby.appendChild(header);
        const buttonContainer = document.createElement("div");
        buttonContainer.className = "flex flex-col gap-4";
        const firstRow = document.createElement("div");
        firstRow.className = "flex flex-col gap-4";
        const aiBtn = document.createElement("button");
        aiBtn.className =
          "lobby-button bg-green-500 text-white hover:bg-green-600";
        aiBtn.innerHTML = "<span>ğŸ¤–</span> " + translations[lang].playAgainstAI;
        aiBtn.addEventListener("click", () => startNewGame("ai"));
        const difficultySelector = document.createElement("div");
        if (lang === "ar") {
          difficultySelector.className = "difficulty-selector-ar";
          difficultySelector.innerHTML = `
    <label for="difficulty">${translations[lang].difficulty}</label>
    <select id="difficulty" class="difficulty-dropdown">
      <option value="1">${translations[lang].easy}</option>
      <option value="4" selected>${translations[lang].normal}</option>
      <option value="8">${translations[lang].difficult}</option>
    </select>
  `;
        } else {
          difficultySelector.className = "difficulty-selector";
          difficultySelector.innerHTML = `
      <label for="difficulty">${translations[lang].difficulty}</label>
      <select id="difficulty" class="difficulty-dropdown">
        <option value="1">${translations[lang].easy}</option>
        <option value="4" selected>${translations[lang].normal}</option>
        <option value="8">${translations[lang].difficult}</option>
      </select>
    `;
        }
        firstRow.appendChild(aiBtn);
        firstRow.appendChild(difficultySelector);
        const secondRow = document.createElement("div");
        secondRow.className = "flex flex-col gap-4";
        const multiplayerBtn = document.createElement("button");
        multiplayerBtn.className =
          "lobby-button bg-purple-500 text-white hover:bg-purple-600";
        multiplayerBtn.innerHTML =
          "<span>ğŸ‘¥</span> " + translations[lang].localMultiplayer;
        multiplayerBtn.addEventListener("click", () => startNewGame("local"));
        const timedBtn = document.createElement("button");
        timedBtn.className =
          "lobby-button bg-purple-500 text-white hover:bg-purple-600";
        timedBtn.innerHTML = "<span>â±ï¸</span> " + translations[lang].timedMode;
        timedBtn.addEventListener("click", () => startNewGame("timed"));
        secondRow.appendChild(multiplayerBtn);
        secondRow.appendChild(timedBtn);
        const separator = document.createElement("div");
        separator.className = "separator";
        const leftLine = document.createElement("div");
        leftLine.className = "separator-line";
        const infoText = document.createElement("span");
        infoText.className = "separator-text";
        infoText.textContent = "ğŸ“ " + translations[lang].info;
        const rightLine = document.createElement("div");
        rightLine.className = "separator-line";
        separator.appendChild(leftLine);
        separator.appendChild(infoText);
        separator.appendChild(rightLine);
        const rulesBtn = document.createElement("button");
        rulesBtn.className = `lobby-button ${
          theme === "dark"
            ? "bg-gray-700 text-gray-200 hover:bg-gray-600"
            : "bg-gray-200 text-gray-800 hover:bg-gray-300"
        }`;
        rulesBtn.innerHTML = "ğŸ“– " + translations[lang].gameRules;
        rulesBtn.addEventListener("click", showRules);
        const creditsBtn = document.createElement("button");
        creditsBtn.className = `lobby-button ${
          theme === "dark"
            ? "bg-gray-700 text-gray-200 hover:bg-gray-600"
            : "bg-gray-200 text-gray-800 hover:bg-gray-300"
        }`;
        creditsBtn.innerHTML = "âœ’ï¸ " + translations[lang].credits;
        creditsBtn.addEventListener("click", showCredits);
        buttonContainer.appendChild(firstRow);
        buttonContainer.appendChild(secondRow);
        buttonContainer.appendChild(separator);
        buttonContainer.appendChild(rulesBtn);
        buttonContainer.appendChild(creditsBtn);
        lobby.appendChild(buttonContainer);
        const difficultyDropdown = document.getElementById("difficulty");
        if (difficultyDropdown) {
          difficultyDropdown.addEventListener("change", function () {
            gameState.difficulty = this.value;
            showTooltip(
              `${translations[lang].difficultyChangedTo} ${this.value}`
            );
          });
        }
        return lobby;
      }
      function renderSettingsModal() {
        const { darkMode, language } = gameState;
        const theme = darkMode ? "dark" : "light";
        const lang = language;
        const overlay = document.createElement("div");
        overlay.className = "settings-modal-overlay";
        const modal = document.createElement("div");
        modal.className = `settings-modal-content ${
          theme === "dark"
            ? "bg-gray-800 text-white border-gray-700"
            : "bg-white text-gray-900 border-gray-300"
        } border`;
        // Appliquer l'animation de fondu
        applyFadeInAnimation(modal);
        const header = document.createElement("div");
        header.className = "settings-modal-header";
        const title = document.createElement("h2");
        title.className = "text-2xl font-bold mb-2";
        title.textContent = translations[lang].settings;
        const settingsContent = document.createElement("div");
        settingsContent.className = "mb-4";
        const languageSelector = document.createElement("div");
        languageSelector.className = "language-selector";
        const languageLabel = document.createElement("label");
        languageLabel.setAttribute("for", "language");
        languageLabel.textContent = translations[lang].language + " ";
        const languageDropdown = document.createElement("select");
        languageDropdown.id = "language";
        languageDropdown.className = "language-dropdown";
        const languages = [
          { code: "ar", name: "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Arabic)" },
          { code: "de", name: "Deutsch (German)" },
          { code: "en", name: "English" },
          { code: "es", name: "EspaÃ±ol (Spanish)" },
          { code: "eu", name: "Euskara (Basque)" },
          { code: "fr", name: "FranÃ§ais (French)" },
          { code: "hi", name: "à¤¹à¤¿à¤¨à¥à¤¦à¥€ (Hindi)" },
          { code: "it", name: "Italiano (Italian)" },
          { code: "ja", name: "æ—¥æœ¬èª (Japanese)" },
          { code: "pt", name: "PortuguÃªs (Portuguese)" },
          { code: "ru", name: "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (Russian)" },
          { code: "sv", name: "Svenska (Swedish)" },
          { code: "uk", name: "Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° (Ukrainian)" },
          { code: "zh", name: "ä¸­æ–‡ (Chinese)" },
        ];
        languages.sort((a, b) => a.name.localeCompare(b.name));
        languages.forEach((langOption) => {
          const option = document.createElement("option");
          option.value = langOption.code;
          option.textContent = langOption.name;
          if (langOption.code === language) {
            option.selected = true;
          }
          languageDropdown.appendChild(option);
        });
        languageDropdown.addEventListener("change", function () {
          gameState.language = this.value;
          localStorage.setItem("selectedLanguage", this.value);
          renderView();
        });
        languageSelector.appendChild(languageLabel);
        languageSelector.appendChild(languageDropdown);
        settingsContent.appendChild(languageSelector);
        header.appendChild(title);
        modal.appendChild(header);
        modal.appendChild(settingsContent);
        const buttons = document.createElement("div");
        buttons.className = "settings-modal-buttons";
        const closeBtn = document.createElement("button");
        closeBtn.className =
          "bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1";
        closeBtn.textContent = translations[lang].close;
        closeBtn.addEventListener("click", () => {
          closeMessage(overlay);
        });
        buttons.appendChild(closeBtn);
        modal.appendChild(buttons);
        overlay.appendChild(modal);
        return overlay;
      }
      function renderRulesView() {
    const { darkMode, language } = gameState;
    const theme = darkMode ? "dark" : "light";
    const lang = language;

    const rulesView = document.createElement("div");
    rulesView.className = `rules-view ${theme === "dark" ? "bg-gray-800 text-white" : "bg-white text-gray-900"}`;

    setTimeout(() => {
        rulesView.classList.add("fade-in");
    }, 10);

    const header = document.createElement("div");
    header.className = "relative mb-4";

    const title = document.createElement("h1");
    title.className = "text-xl font-bold text-center";
    title.textContent = translations[lang].gameRules + "  ğŸ“–";
    header.appendChild(title);

    rulesView.appendChild(header);

    const separatorLine = document.createElement("hr");
    separatorLine.className = theme === "dark" ? "separator-line" : "separator-line-light";
    rulesView.appendChild(separatorLine);

    const rulesList = document.createElement("div");
    rulesList.className = "space-y-4 mb-6 pt-4";

    const rules = [
        translations[lang].rule1,
        translations[lang].rule2,
        translations[lang].rule3,
        translations[lang].rule4,
        translations[lang].rule5,
        translations[lang].rule6,
    ];

    rules.forEach((rule, index) => {
        const ruleItem = document.createElement("div");
        ruleItem.className = "flex gap-3";

        const number = document.createElement("div");
        number.className = "text-2xl";
        number.textContent = `${index + 1}ï¸âƒ£`;

        const text = document.createElement("p");
        text.textContent = rule;

        ruleItem.appendChild(number);
        ruleItem.appendChild(text);
        rulesList.appendChild(ruleItem);
    });

    rulesView.appendChild(rulesList);

    const backBtn = document.createElement("button");
    backBtn.className = "bg-blue-500 text-white px-4 py-2 rounded-button hover:bg-blue-600 w-full";
    backBtn.textContent = translations[lang].backToLobby;
    backBtn.addEventListener("click", backToLobby);

    rulesView.appendChild(backBtn);

    return rulesView;
}

      function renderCreditsView() {
        const { darkMode, language } = gameState;
        const theme = darkMode ? "dark" : "light";
        const lang = language;
        const creditsView = document.createElement("div");
        creditsView.className = `credits-view ${
          theme === "dark" ? "bg-gray-800 text-white" : "bg-white text-gray-900"
        } fade-in`;
        applyFadeInAnimation(creditsView);
        const header = document.createElement("div");
        header.className = "relative mb-4";
        const title = document.createElement("h1");
        title.className = "text-xl font-bold text-center";
        title.textContent = translations[lang].creditsTitle;
        header.appendChild(title);
        creditsView.appendChild(header);
        const separatorLine = document.createElement("hr");
        separatorLine.className =
          theme === "dark" ? "separator-line" : "separator-line-light";
        creditsView.appendChild(separatorLine);
        const creditsContent = document.createElement("div");
        creditsContent.className = "space-y-4 mb-6 pt-4";
        const developerSection = document.createElement("div");
        developerSection.className = "flex flex-col gap-2";
        const developerTitle = document.createElement("h2");
        developerTitle.className = "text-lg font-bold";
        developerTitle.textContent = translations[lang].developer + ":";
        const developerName = document.createElement("p");
        developerName.textContent = developerNames[lang]
        developerSection.appendChild(developerTitle);
        developerSection.appendChild(developerName);
        const translatorSection = document.createElement("div");
        translatorSection.className = "flex flex-col gap-2";
        const translatorTitle = document.createElement("h2");
        translatorTitle.className = "text-lg font-bold";
        translatorTitle.textContent = translations[lang].translator + ":";
        const translatorNames = document.createElement("div");
        translatorNames.innerHTML = translations[lang].translatorCredits;
        translatorSection.appendChild(translatorTitle);
        translatorSection.appendChild(translatorNames);
        const betaTestersSection = document.createElement("div");
        betaTestersSection.className = "flex flex-col gap-2";
        const betaTestersTitle = document.createElement("h2");
        betaTestersTitle.className = "text-lg font-bold";
        betaTestersTitle.textContent = translations[lang].betaTesters + ":";
        const betaTestersNames = document.createElement("div");
        betaTestersNames.innerHTML = translations[lang].betaTestersCredits;
        betaTestersSection.appendChild(betaTestersTitle);
        betaTestersSection.appendChild(betaTestersNames);
        creditsContent.appendChild(developerSection);
        creditsContent.appendChild(translatorSection);
        creditsContent.appendChild(betaTestersSection);
        creditsView.appendChild(creditsContent);
        const backToSettingsBtn = document.createElement("button");
        backToSettingsBtn.className =
          "bg-blue-500 text-white px-4 py-2 rounded-button hover:bg-blue-600 w-full";
        backToSettingsBtn.textContent = translations[lang].backToLobby;
        backToSettingsBtn.addEventListener("click", () => {
          gameState.view = "lobby";
          renderView();
          const lobbyContainer = document.querySelector("#app .container");
          applyFadeInAnimation(lobbyContainer);
        });
        creditsView.appendChild(backToSettingsBtn);
        return creditsView;
      }
      function renderGameView() {
        const container = document.createElement("div");
        container.appendChild(renderGameInfo());
        container.appendChild(renderGameBoard());
        container.appendChild(renderTurnIndicator());
        const modal = renderGameOverModal();
        if (modal && !document.querySelector(".modal-overlay")) {
          container.appendChild(modal);
        }
        return container;
      }
      function renderFirstPlayerModal() {
        const { currentTurn, darkMode, language } = gameState;
        const theme = darkMode ? "dark" : "light";
        const lang = language;
        const overlay = document.createElement("div");
        overlay.className = "modal-overlay";
        const modal = document.createElement("div");
        modal.className = `modal-content ${
          theme === "dark"
            ? "bg-gray-800 text-white border-gray-700"
            : "bg-white text-gray-900 border-gray-300"
        } border`;
        const header = document.createElement("div");
        header.className = "modal-header";
        const icon = document.createElement("div");
        icon.className = "text-5xl mb-4";
        if (currentTurn === "X") {
          // Create a styled cross for the X symbol
          const cross = document.createElement("div");
          cross.style.position = "relative";
          cross.style.width = "50px";
          cross.style.height = "50px";
          cross.style.margin = "0 auto";
          const crossLine1 = document.createElement("div");
          crossLine1.style.position = "absolute";
          crossLine1.style.width = "100%";
          crossLine1.style.height = "10px"; // Increased thickness
          crossLine1.style.backgroundColor = "#ef4444"; // Red color
          crossLine1.style.top = "50%";
          crossLine1.style.left = "0";
          crossLine1.style.transform = "rotate(45deg)";
          crossLine1.style.transformOrigin = "center";
          crossLine1.style.borderRadius = "5px";
          const crossLine2 = document.createElement("div");
          crossLine2.style.position = "absolute";
          crossLine2.style.width = "100%";
          crossLine2.style.height = "10px"; // Increased thickness
          crossLine2.style.backgroundColor = "#ef4444"; // Red color
          crossLine2.style.top = "50%";
          crossLine2.style.left = "0";
          crossLine2.style.transform = "rotate(-45deg)";
          crossLine2.style.transformOrigin = "center";
          crossLine2.style.borderRadius = "5px";
          cross.appendChild(crossLine1);
          cross.appendChild(crossLine2);
          icon.appendChild(cross);
        } else {
          // Create a styled circle for the O symbol
          const circle = document.createElement("div");
          circle.style.width = "50px";
          circle.style.height = "50px";
          circle.style.borderRadius = "50%";
          circle.style.border = "10px solid #3b82f6"; // Increased thickness
          circle.style.margin = "0 auto";
          icon.appendChild(circle);
        }
        const title = document.createElement("h2");
        title.className = "text-xl font-bold mb-2";
        title.textContent =
          currentTurn === "X"
            ? translations[lang].youGoFirst
            : translations[lang].aiGoesFirst;
        header.appendChild(icon);
        header.appendChild(title);
        const buttons = document.createElement("div");
        buttons.className = "modal-buttons flex gap-2";
        const continueBtn = document.createElement("button");
        continueBtn.className =
          "bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1";
        continueBtn.textContent = translations[lang].continue;
        continueBtn.addEventListener("click", () => {
          closeMessage(overlay);
          if (currentTurn === "O") {
            setTimeout(() => simulateOpponentMove(), 1000);
          } else if (gameState.gameMode === "timed") {
            if (gameState.activeTimer) {
              clearInterval(gameState.activeTimer);
              gameState.activeTimer = null;
            }
            startTimer(currentTurn);
          }
        });
        buttons.appendChild(continueBtn);
        modal.appendChild(header);
        modal.appendChild(buttons);
        overlay.appendChild(modal);
        return overlay;
      }
      function closeMessage(element) {
        element.classList.add("exit");
        setTimeout(() => {
          element.remove();
        }, 300); // Assurez-vous que cela correspond Ã  la durÃ©e de votre animation de sortie
      }
      function renderView() {
        const appContainer = document.querySelector("#app .container");
        appContainer.innerHTML = "";
        // Restaurer la langue depuis localStorage
        const savedLanguage = localStorage.getItem("selectedLanguage");
        if (savedLanguage) {
          gameState.language = savedLanguage;
        }
        document.body.classList.toggle("dark", gameState.darkMode);
        switch (gameState.view) {
          case "lobby":
            appContainer.appendChild(renderLobbyView());
            break;
          case "rules":
            appContainer.appendChild(renderRulesView());
            break;
          case "credits":
            appContainer.appendChild(renderCreditsView());
            break;
          case "game":
            appContainer.appendChild(renderGameView());
            setTimeout(postRenderAdjustments, 0);
            break;
        }
      }
      document.addEventListener("DOMContentLoaded", () => {
        const savedLanguage = localStorage.getItem("selectedLanguage");
        if (savedLanguage) {
          gameState.language = savedLanguage;
        }
        renderView();
        adjustGameBoardSize();
        window.addEventListener("resize", () => {
          adjustGameBoardSize();
        });
      });
    </script>
  </body>
</html>
