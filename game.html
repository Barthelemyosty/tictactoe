<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Tic Tac Toe</title>
    <style>
        /* Styles globaux */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* Animation de rebond */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.2);
            }
            60% {
                transform: scale(0.9);
            }
        }

        /* Animation d'entrée */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInlayout {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        /* Animation de sortie */
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        @keyframes zoom {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .zoom {
            animation: zoom 1s infinite;
        }

        /* Animation d'entrée aux layouts */
        .lobby-view, .game-view, .rules-view {
            animation: fadeInlayout 0.3s ease-in-out;
        }

        /* Animation de sortie aux layouts */
        .lobby-view.exit, .game-view.exit, .rules-view.exit {
            animation: fadeOut 0.3s ease-in-out;
        }

        /* Animation d'entrée aux messages */
        .tooltip, .modal-content {
            animation: fadeIn 0.3s ease-in-out;
        }

        /* Animation de sortie aux messages */
        .tooltip.exit, .modal-content.exit {
            animation: fadeOut 0.3s ease-in-out;
        }

        /* Transition pour le changement de thème */
        body, div, button, p, h1, h2, footer {
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        /* Effet de survol pour les cases valides */
        .cell.valid {
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }

        .cell.valid:hover {
            transform: scale(1.13);
            background-color: #dbeafe;
        }

        /* Assurez-vous que l'effet est visible en mode sombre */
        .dark .cell.valid:hover {
            background-color: #4b5563;
        }

        /* Ajoutez ce style pour la modal de paramètres */
        .settings-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .settings-modal-content {
            border-radius: 0.5rem;
            max-width: 384px;
            width: 100%;
            padding: 24px;
        }

        .settings-modal-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .settings-modal-buttons {
            display: flex;
            gap: 12px;
        }

        /* Assurez-vous que le conteneur d'en-tête est correctement configuré */
        .header-responsive {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .title-responsive {
            text-align: center;
        }

        /* Conteneurs principaux */
        .container {
            width: 100%;
            max-width: 512px;
            margin: 0 auto;
            padding: 0 16px;
        }

        .min-h-screen {
            min-height: 100vh;
            padding: 32px 16px;
        }

        /* Light mode */
        .bg-gray-100 {
            background-color: #f3f4f6;
        }
        .bg-white {
            background-color: #ffffff;
        }
        .text-gray-900 {
            color: #111827;
        }
        .text-gray-600 {
            color: #4b5563;
        }
        .border-gray-300 {
            border-color: #d1d5db;
        }
        .bg-gray-200 {
            background-color: #e5e7eb;
        }
        .text-gray-800 {
            color: #1f2937;
        }
        .hover\:bg-gray-300:hover {
            background-color: #d1d5db;
        }
        .bg-blue-100 {
            background-color: #dbeafe;
        }
        .bg-red-200 {
            background-color: #fecaca;
        }
        .bg-blue-200 {
            background-color: #bfdbfe;
        }
        .ring-yellow-400 {
            box-shadow: 0 0 0 4px #fbbf24;
        }
        .text-gray-500 {
            color: #6b7280;
        }
        .bg-gray-100 {
            background-color: #f3f4f6;
        }

        /* Theme classes - Dark mode */
        .dark .bg-gray-900 {
            background-color: #111827;
        }
        .dark .bg-gray-800 {
            background-color: #1f2937;
        }
        .dark .text-white {
            color: #ffffff;
        }
        .dark .text-gray-300 {
            color: #d1d5db;
        }
        .dark .border-gray-700 {
            border-color: #374151;
        }
        .dark .bg-gray-700 {
            background-color: #374151;
        }
        .dark .bg-blue-900 {
            background-color: #1e3a8a;
        }
        .dark .text-gray-200 {
            color: #e5e7eb;
        }
        .dark .hover\:bg-gray-600:hover {
            background-color: #4b5563;
        }
        .dark .bg-gray-600 {
            background-color: #4b5563;
        }
        .dark .bg-red-900 {
            background-color: #7f1d1d;
        }
        .dark .ring-yellow-500 {
            box-shadow: 0 0 0 4px #f59e0b;
        }
        .dark .text-gray-400 {
            color: #9ca3af;
        }

        /* Common button styles */
        .difficulty-selector {
            margin-bottom: 16px;
            text-align: center;
        }

        .difficulty-selector label {
            margin-right: 8px;
            font-weight: bold;
        }

        .difficulty-dropdown {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
            font-size: 16px;
        }

        .difficulty-dropdown:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        button {
            cursor: pointer;
            font-weight: 500;
            border: none;
            border-radius: 0.375rem;
        }

        .bg-blue-500 {
            background-color: #3b82f6;
            color: white;
        }
        .hover\:bg-blue-600:hover {
            background-color: #2563eb;
        }

        .bg-gray-500 {
            background-color: #6b7280;
            color: white;
        }
        .hover\:bg-gray-600:hover {
            background-color: #4b5563;
        }

        .bg-purple-500 {
            background-color: #8b5cf6;
            color: white;
        }
        .hover\:bg-purple-600:hover {
            background-color: #7c3aed;
        }

        .bg-green-500 {
            background-color: #10b981;
            color: white;
        }
        .hover\:bg-green-600:hover {
            background-color: #059669;
        }

        .hover\:bg-yellow-400:hover {
            background-color: #facc15;
        }
        .hover\:bg-emerald-600:hover {
            background-color: #84cc16;
        }

        /* Layout */
        .flex {
            display: flex;
        }
        .flex-col {
            flex-direction: column;
        }
        .items-center {
            align-items: center;
        }
        .justify-center {
            justify-content: center;
        }
        .justify-between {
            justify-content: space-between;
        }
        .gap-2 {
            gap: 8px;
        }
        .gap-3 {
            gap: 12px;
        }
        .gap-4 {
            gap: 16px;
        }
        .mt-4 {
            margin-top: 16px;
        }
        .mt-6 {
            margin-top: 24px;
        }
        .mt-8 {
            margin-top: 32px;
        }
        .mb-2 {
            margin-bottom: 8px;
        }
        .mb-4 {
            margin-bottom: 16px;
        }
        .mb-6 {
            margin-bottom: 24px;
        }
        .p-2 {
            padding: 8px;
        }
        .p-4 {
            padding: 16px;
        }
        .p-6 {
            padding: 24px;
        }
        .px-4 {
            padding-left: 16px;
            padding-right: 16px;
        }
        .py-2 {
            padding-top: 8px;
            padding-bottom: 8px;
        }
        .py-3 {
            padding-top: 12px;
            padding-bottom: 12px;
        }
        .pt-4 {
            padding-top: 16px;
        }
        .rounded {
            border-radius: 0.25rem;
        }
        .rounded-lg {
            border-radius: 0.5rem;
        }
        .rounded-full {
            border-radius: 9999px;
        }
        .border {
            border-width: 1px;
            border-style: solid;
        }
        .border-t {
            border-top-width: 1px;
            border-top-style: solid;
        }
        .border-2 {
            border-width: 2px;
            border-style: solid;
        }
        .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .shadow-xl {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .w-full {
            width: 100%;
        }
        .max-w-sm {
            max-width: 384px;
        }
        .max-w-md {
            max-width: 448px;
        }
        .max-w-lg {
            max-width: 512px;
        }
        .space-y-4 > * + * {
            margin-top: 16px;
        }
        .flex-1 {
            flex: 1 1 0%;
        }

        /* Texte */
        .text-center {
            text-align: center;
        }
        .text-sm {
            font-size: 0.875rem;
        }
        .text-lg {
            font-size: 1.125rem;
        }
        .text-xl {
            font-size: 1.25rem;
        }
        .text-2xl {
            font-size: 1.5rem;
        }
        .text-3xl {
            font-size: 1.875rem;
        }
        .text-4xl {
            font-size: 2.25rem;
        }
        .text-5xl {
            font-size: 3rem;
        }
        .font-medium {
            font-weight: 500;
        }
        .font-semibold {
            font-weight: 600;
        }
        .font-bold {
            font-weight: 700;
        }
        .text-red-500 {
            color: #ef4444;
        }
        .text-blue-500 {
            color: #3b82f6;
        }

        .turn-text {
            color: #1f2937;
        }

        .dark .turn-text {
            color: #ffffff;
        }

        /* Styles pour le sélecteur de langue */
        .language-selector {
            margin-bottom: 16px;
            text-align: center;
        }

        .language-dropdown {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
            font-size: 16px;
        }

        .language-dropdown:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        @media (max-width: 512px) {
            .game-board {
                gap: 8px;
                padding: 8px;
            }

            .cell {
                width: 28px;
                height: 28px;
                font-size: 0.95rem;
                aspect-ratio: 1 / 1;
            }

            .small-board {
                gap: 1px;
                padding: 1px;
                display: grid;
                grid-template-columns: repeat(3, 1fr);
            }

            .header-responsive {
                flex-direction: column;
                align-items: fixed;
            }

            .title-responsive {
                width: 70%;
                text-align: center;
                margin-top: 10px;
            }
        }

        @media (max-width: 360px) {
            .cell {
                aspect-ratio: 1 / 1;
                min-width: 18px;
                font-size: 0.75rem;
            }

            .game-board {
                gap: 4px;
                padding: 4px;
            }
        }

        @media (max-width: 400px) {
            .game-board {
                gap: 6px;
                padding: 6px;
            }

            .cell {
                width: auto;
                height: auto;
                aspect-ratio: 1 / 1;
                min-width: 20px;
                font-size: 0.875rem;
            }

            .small-board {
                gap: 0px;
                padding: 1px;
            }

            .button-grid {
                grid-template-columns: 1fr;
            }

            .modal-buttons {
                flex-direction: column;
            }
        }

        /* Game board styles */
        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            padding: 16px;
            max-width: 512px;
            margin: 0 auto;
            border-radius: 0.5rem;
            border-width: 2px;
            border-style: solid;
        }

        .small-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            border-width: 1px;
            border-style: solid;
            border-radius: 0.25rem;
            padding: 2px;
            position: relative;
            overflow: hidden;
        }

        .small-board.active {
            transform: scale(1.03);
        }

        .small-board.won-x {
            background-color: #fecaca;
        }
        .dark .small-board.won-x {
            background-color: #7f1d1d;
        }

        .small-board.won-o {
            background-color: #bfdbfe;
        }
        .dark .small-board.won-o {
            background-color: #1e3a8a;
        }

        .small-board.draw {
            opacity: 0.5;
        }

        .cell {
            box-sizing: border-box;
            overflow: hidden;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
        }

        .cell.valid {
            cursor: pointer;
        }

        .winner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem;
            font-weight: bold;
        }

        @media (min-width: 768px) {
            .cell {
                width: 40px;
                height: 40px;
            }
            .grid-cols-2 {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        /* Game views */
        .game-view, .lobby-view, .rules-view {
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 24px;
            margin: 0 auto;
        }

        /* Game info section */
        .game-info {
            margin-bottom: 24px;
            text-align: center;
        }

        .game-info-header {
            position: relative;
            margin-bottom: 16px;
            text-align: center;
        }

        .player-info {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 8px;
        }

        .player-box {
            padding: 8px 16px;
            border-radius: 0.5rem;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .modal-content {
            border-radius: 0.5rem;
            max-width: 384px;
            width: 100%;
            padding: 24px;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background-color: black;
            color: white;
            padding: 8px 16px;
            border-radius: 0.25rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            opacity: 0.9;
            z-index: 50;
            display: none;
        }

        /* Utilities for positioning */
        .relative {
            position: relative;
        }

        .absolute {
            position: absolute;
        }

        .right-0 {
            right: 0;
        }

        .top-0 {
            top: 0;
        }

        /* Footer glitché */
        footer {
            position: fixed;
            bottom: 0;
            width: 100%;
            color: white;
            text-align: center;
            padding: 10px 0;
            font-size: 0.875rem;
            z-index: 100;
        }

        /* Button layouts */
        .button-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        @media (min-width: 768px) {
            .button-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @keyframes blink {
            0%, 100% {
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
        }

        .thinking-dots {
            display: inline-block;
            font-size: 24px;
            margin: 10px;
        }

        .thinking-dots span {
            display: inline-block;
            opacity: 0;
            animation: blink 1.4s infinite both;
        }

        .thinking-dots span:nth-child(1) {
            animation-delay: 0.2s;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: 0.4s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0.6s;
        }

        .turn-indicator {
            display: inline-block;
            min-width: 120px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="app" class="min-h-screen">
        <div class="container">
        </div>
        <footer class="text-gray-500">
            Ultimate Tic Tac Toe © 2025
        </footer>
    </div>
    <div id="tooltip" class="tooltip"></div>
    <script>
        // Ajoutez les traductions
        const translations = {
            en: {
                title: "Ultimate Tic Tac Toe",
                playAgainstAI: "Play against AI",
                localMultiplayer: "Local Multiplayer",
                timedMode: "Timed Mode",
                gameRules: "Game Rules",
                settings: "Settings",
                difficulty: "Difficulty",
                close: "Close",
                continue: "Continue",
                newGame: "New Game",
                backToLobby: "Back to Lobby",
                language: "Language",
                easy: "Easy",
                normal: "Normal",
                difficult: "Difficult",
                impossible: "Impossible",
                youArePlayingAs: "You are playing as",
                youGoFirst: "You go first!",
                aiGoesFirst: "AI goes first!",
                youWon: "You won.",
                aiWon: "AI won.",
                playerWon: "Player won.",
                gameEndedInDraw: "The game ended in a draw.",
                playerXRanOutOfTime: "Player X ran out of time. Player O wins!",
                playerORanOutOfTime: "Player O ran out of time. Player X wins!",
                playerXWon: "Player X won.",
                playerOWon: "Player O won.",
                gameOver: "Game Over",
                theGameIsAlreadyOver: "The game is already over!",
                youMustPlayInTheIndicatedGrid: "You must play in the indicated grid!",
                thisGridIsAlreadyWon: "This grid is already won!",
                thisCellIsAlreadyTaken: "This cell is already taken!",
                difficultyChangedTo: "Difficulty changed to:",
                difficultyNames: {
                    '1': 'Easy',
                    '4': 'Normal',
                    '6': 'Difficult',
                    '9': 'Impossible'
                },
                yourTurn: "Your turn",
                aiIsThinking: "AI is thinking",
                rule1: "Ultimate Tic Tac Toe consists of 9 small Tic Tac Toe grids, forming one large grid.",
                rule2: "On each turn, you must play in the small grid corresponding to the cell played by your opponent in their small grid.",
                rule3: "For example, if your opponent plays in the top-right cell of their small grid, you must play in the top-right small grid of the large grid.",
                rule4: "If you are sent to a grid that is already won or full, you can play in any open grid.",
                rule5: "To win a small grid, align 3 symbols as in classic Tic Tac Toe.",
                rule6: "To win the game, align 3 won small grids."
            },
            fr: {
                title: "Morpion Ultime",
                playAgainstAI: "Jouer contre l'IA",
                localMultiplayer: "Multijoueur Local",
                timedMode: "Mode Chronométré",
                gameRules: "Règles du Jeu",
                settings: "Paramètres",
                difficulty: "Difficulté",
                close: "Fermer",
                continue: "Continuer",
                newGame: "Nouvelle Partie",
                backToLobby: "Retour au Lobby",
                language: "Langue",
                easy: "Facile",
                normal: "Normal",
                difficult: "Difficile",
                impossible: "Impossible",
                youArePlayingAs: "Vous jouez en tant que",
                youGoFirst: "Vous commencez!",
                aiGoesFirst: "L'IA commence!",
                youWon: "Vous avez gagné.",
                aiWon: "L'IA a gagné.",
                playerWon: "Le joueur a gagné.",
                gameEndedInDraw: "La partie s'est terminée par un match nul.",
                playerXRanOutOfTime: "Le joueur X a manqué de temps. Le joueur O gagne!",
                playerORanOutOfTime: "Le joueur O a manqué de temps. Le joueur X gagne!",
                playerXWon: "Le joueur X a gagné.",
                playerOWon: "Le joueur O a gagné.",
                gameOver: "Fin de la partie",
                theGameIsAlreadyOver: "La partie est déjà terminée!",
                youMustPlayInTheIndicatedGrid: "Vous devez jouer dans la grille indiquée!",
                thisGridIsAlreadyWon: "Cette grille est déjà gagnée!",
                thisCellIsAlreadyTaken: "Cette cellule est déjà prise!",
                difficultyChangedTo: "Difficulté changée en:",
                difficultyNames: {
                    '1': 'Facile',
                    '4': 'Normal',
                    '6': 'Difficile',
                    '9': 'Impossible'
                },
                yourTurn: "Votre tour",
                aiIsThinking: "L'IA réfléchit",
                rule1: "Le Morpion Ultime est composé de 9 petites grilles de Morpion, formant une grande grille.",
                rule2: "À chaque tour, vous devez jouer dans la petite grille correspondant à la cellule jouée par votre adversaire dans leur petite grille.",
                rule3: "Par exemple, si votre adversaire joue dans la cellule en haut à droite de leur petite grille, vous devez jouer dans la petite grille en haut à droite de la grande grille.",
                rule4: "Si vous êtes envoyé vers une grille déjà gagnée ou pleine, vous pouvez jouer dans n'importe quelle grille ouverte.",
                rule5: "Pour gagner une petite grille, alignez 3 symboles comme dans le Morpion classique.",
                rule6: "Pour gagner la partie, alignez 3 petites grilles gagnées."
            },
            de: {
                title: "Ultimatives Tic Tac Toe",
                playAgainstAI: "Gegen KI spielen",
                localMultiplayer: "Lokaler Mehrspieler",
                timedMode: "Zeitmodus",
                gameRules: "Spielregeln",
                settings: "Einstellungen",
                difficulty: "Schwierigkeit",
                close: "Schließen",
                continue: "Fortsetzen",
                newGame: "Neues Spiel",
                backToLobby: "Zurück zur Lobby",
                language: "Sprache",
                easy: "Einfach",
                normal: "Normal",
                difficult: "Schwierig",
                impossible: "Unmöglich",
                youArePlayingAs: "Sie spielen als",
                youGoFirst: "Sie beginnen!",
                aiGoesFirst: "Die KI beginnt!",
                youWon: "Sie haben gewonnen.",
                aiWon: "Die KI hat gewonnen.",
                playerWon: "Der Spieler hat gewonnen.",
                gameEndedInDraw: "Das Spiel endete unentschieden.",
                playerXRanOutOfTime: "Spieler X hat keine Zeit mehr. Spieler O gewinnt!",
                playerORanOutOfTime: "Spieler O hat keine Zeit mehr. Spieler X gewinnt!",
                playerXWon: "Spieler X hat gewonnen.",
                playerOWon: "Spieler O hat gewonnen.",
                gameOver: "Spiel vorbei",
                theGameIsAlreadyOver: "Das Spiel ist bereits vorbei!",
                youMustPlayInTheIndicatedGrid: "Sie müssen im angegebenen Feld spielen!",
                thisGridIsAlreadyWon: "Dieses Feld ist bereits gewonnen!",
                thisCellIsAlreadyTaken: "Diese Zelle ist bereits belegt!",
                difficultyChangedTo: "Schwierigkeit geändert zu:",
                difficultyNames: {
                    '1': 'Einfach',
                    '4': 'Normal',
                    '6': 'Schwierig',
                    '9': 'Unmöglich'
                },
                yourTurn: "Ihr Zug",
                aiIsThinking: "Die KI denkt nach",
                rule1: "Ultimatives Tic Tac Toe besteht aus 9 kleinen Tic Tac Toe-Rastern, die ein großes Raster bilden.",
                rule2: "In jeder Runde müssen Sie in dem kleinen Raster spielen, das der Zelle entspricht, die Ihr Gegner in ihrem kleinen Raster gespielt hat.",
                rule3: "Wenn Ihr Gegner zum Beispiel in der oberen rechten Zelle ihres kleinen Rasters spielt, müssen Sie im oberen rechten kleinen Raster des großen Rasters spielen.",
                rule4: "Wenn Sie zu einem Raster geschickt werden, das bereits gewonnen oder voll ist, können Sie in jedem offenen Raster spielen.",
                rule5: "Um ein kleines Raster zu gewinnen, richten Sie 3 Symbole wie beim klassischen Tic Tac Toe aus.",
                rule6: "Um das Spiel zu gewinnen, richten Sie 3 gewonnene kleine Raster aus."
            },
            it: {
                title: "Tris Ultimo",
                playAgainstAI: "Gioca contro l'IA",
                localMultiplayer: "Multigiocatore Locale",
                timedMode: "Modalità Cronometrata",
                gameRules: "Regole del Gioco",
                settings: "Impostazioni",
                difficulty: "Difficoltà",
                close: "Chiudi",
                continue: "Continua",
                newGame: "Nuova Partita",
                backToLobby: "Torna alla Lobby",
                language: "Lingua",
                easy: "Facile",
                normal: "Normale",
                difficult: "Difficile",
                impossible: "Impossibile",
                youArePlayingAs: "Stai giocando come",
                youGoFirst: "Inizi tu!",
                aiGoesFirst: "L'IA inizia!",
                youWon: "Hai vinto.",
                aiWon: "L'IA ha vinto.",
                playerWon: "Il giocatore ha vinto.",
                gameEndedInDraw: "La partita è finita in parità.",
                playerXRanOutOfTime: "Il giocatore X ha finito il tempo. Il giocatore O vince!",
                playerORanOutOfTime: "Il giocatore O ha finito il tempo. Il giocatore X vince!",
                playerXWon: "Il giocatore X ha vinto.",
                playerOWon: "Il giocatore O ha vinto.",
                gameOver: "Partita finita",
                theGameIsAlreadyOver: "La partita è già finita!",
                youMustPlayInTheIndicatedGrid: "Devi giocare nella griglia indicata!",
                thisGridIsAlreadyWon: "Questa griglia è già stata vinta!",
                thisCellIsAlreadyTaken: "Questa cella è già occupata!",
                difficultyChangedTo: "Difficoltà cambiata in:",
                difficultyNames: {
                    '1': 'Facile',
                    '4': 'Normale',
                    '6': 'Difficile',
                    '9': 'Impossibile'
                },
                yourTurn: "Il tuo turno",
                aiIsThinking: "L'IA sta pensando",
                rule1: "Tris Ultimo consiste in 9 piccole griglie di Tris, che formano una grande griglia.",
                rule2: "Ad ogni turno, devi giocare nella piccola griglia corrispondente alla cella giocata dal tuo avversario nella loro piccola griglia.",
                rule3: "Ad esempio, se il tuo avversario gioca nella cella in alto a destra della loro piccola griglia, devi giocare nella piccola griglia in alto a destra della grande griglia.",
                rule4: "Se vieni inviato a una griglia già vinta o piena, puoi giocare in qualsiasi griglia aperta.",
                rule5: "Per vincere una piccola griglia, allinea 3 simboli come nel classico Tris.",
                rule6: "Per vincere la partita, allinea 3 piccole griglie vinte."
            },
            sv: {
                title: "Ultimate Tic Tac Toe",
                playAgainstAI: "Spela mot AI",
                localMultiplayer: "Lokal Multiplayer",
                timedMode: "Tidläge",
                gameRules: "Spelregler",
                settings: "Inställningar",
                difficulty: "Svårighetsgrad",
                close: "Stäng",
                continue: "Fortsätt",
                newGame: "Nytt Spel",
                backToLobby: "Tillbaka till Lobby",
                language: "Språk",
                easy: "Lätt",
                normal: "Normal",
                difficult: "Svår",
                impossible: "Omöjlig",
                youArePlayingAs: "Du spelar som",
                youGoFirst: "Du börjar!",
                aiGoesFirst: "AI börjar!",
                youWon: "Du vann.",
                aiWon: "AI vann.",
                playerWon: "Spelaren vann.",
                gameEndedInDraw: "Spelet slutade oavgjort.",
                playerXRanOutOfTime: "Spelare X tog slut på tid. Spelare O vinner!",
                playerORanOutOfTime: "Spelare O tog slut på tid. Spelare X vinner!",
                playerXWon: "Spelare X vann.",
                playerOWon: "Spelare O vann.",
                gameOver: "Spel slut",
                theGameIsAlreadyOver: "Spelet är redan över!",
                youMustPlayInTheIndicatedGrid: "Du måste spela i den angivna rutan!",
                thisGridIsAlreadyWon: "Den här rutan är redan vunnen!",
                thisCellIsAlreadyTaken: "Den här cellen är redan tagen!",
                difficultyChangedTo: "Svårighetsgrad ändrad till:",
                difficultyNames: {
                    '1': 'Lätt',
                    '4': 'Normal',
                    '6': 'Svår',
                    '9': 'Omöjlig'
                },
                yourTurn: "Din tur",
                aiIsThinking: "AI tänker",
                rule1: "Ultimate Tic Tac Toe består av 9 små Tic Tac Toe-rutor som bildar ett stort rutnät.",
                rule2: "På varje tur måste du spela i den lilla rutan som motsvarar cellen som din motståndare spelade i deras lilla rutnät.",
                rule3: "Om din motståndare till exempel spelar i den övre högra cellen i deras lilla rutnät, måste du spela i den övre högra lilla rutan i det stora rutnätet.",
                rule4: "Om du skickas till en ruta som redan är vunnen eller full, kan du spela i vilken öppen ruta som helst.",
                rule5: "För att vinna en liten ruta, justera 3 symboler som i klassiskt Tic Tac Toe.",
                rule6: "För att vinna spelet, justera 3 vunna små rutnät."
            }
        };

        // Constantes pour la réutilisation
        const INITIAL_GAME_STATE = {
            view: 'lobby',
            playerId: `player_${Math.random().toString(36).substring(2, 9)}`,
            playerSymbol: null,
            currentTurn: 'X',
            activeBoard: null,
            boardStates: Array(9).fill().map(() => Array(9).fill(null)),
            smallBoardWinners: Array(9).fill(null),
            gameWinner: null,
            tooltipMessage: '',
            tooltipVisible: false,
            gameMode: 'ai',
            playerTimes: {
                X: 60,
                O: 60
            },
            activeTimer: null,
            darkMode: false,
            difficulty: 'medium',
            language: 'en'
        };

        const WIN_PATTERNS = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];

        let gameState = {...INITIAL_GAME_STATE};
        let aiWorker;

        // Helper functions
        function checkWinSmallBoard(board) {
            return WIN_PATTERNS.some(([a, b, c]) =>
                board[a] && board[a] === board[b] && board[a] === board[c]
            );
        }

        function checkWinBigBoard(winners) {
            return WIN_PATTERNS.some(([a, b, c]) =>
                winners[a] && winners[a] !== 'draw' && winners[a] === winners[b] && winners[a] === winners[c]
            );
        }

        function isBoardFull(board) {
            return board.every(cell => cell !== null);
        }

        function isBigBoardFull(winners, boardStates) {
            if (winners.every(winner => winner !== null)) return true;
            return !boardStates.some((board, i) =>
                winners[i] === null && board.some(cell => cell === null)
            );
        }

        function adjustGameBoardSize() {
            const viewportWidth = window.innerWidth;
            const gameBoard = document.querySelector('.game-board');

            if (!gameBoard) return;

            if (viewportWidth < 360) {
                gameBoard.style.maxWidth = '270px';
            } else if (viewportWidth < 400) {
                gameBoard.style.maxWidth = '310px';
            } else if (viewportWidth < 500) {
                gameBoard.style.maxWidth = '390px';
            } else {
                gameBoard.style.maxWidth = '512px';
            }

            const cells = document.querySelectorAll('.cell');
            const smallBoards = document.querySelectorAll('.small-board');

            if (viewportWidth < 360) {
                smallBoards.forEach(board => {
                    board.style.gap = '0px';
                    board.style.padding = '1px';
                });
            } else if (viewportWidth < 400) {
                smallBoards.forEach(board => {
                    board.style.gap = '1px';
                    board.style.padding = '1px';
                });
            }
        }

        function postRenderAdjustments() {
            adjustGameBoardSize();
            const smallBoards = document.querySelectorAll('.small-board');
            smallBoards.forEach((board, index) => {
                if (gameState.activeBoard === index && gameState.smallBoardWinners[index] === null) {
                    const viewportWidth = window.innerWidth;
                    if (viewportWidth < 400) {
                        board.style.transform = 'scale(1.02)';
                        board.style.boxShadow = '0 0 0 2px #fbbf24';
                    }
                }
            });
            ensureSquareCells();
        }

        function ensureSquareCells() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const width = cell.offsetWidth;
                cell.style.height = `${width}px`;
            });
        }

        function showTooltip(message) {
            const lang = gameState.language;
            const translatedMessage = translations[lang][message] || message;
            gameState.tooltipMessage = translatedMessage;
            gameState.tooltipVisible = true;

            const tooltip = document.getElementById('tooltip');
            tooltip.textContent = translatedMessage;
            tooltip.style.display = 'block';
            tooltip.classList.remove('exit');
            tooltip.classList.add('tooltip');

            setTimeout(() => {
                gameState.tooltipVisible = false;
                tooltip.style.display = 'none';
            }, 2000);
        }

        function toggleDarkMode() {
            gameState.darkMode = !gameState.darkMode;
            document.body.classList.toggle('dark', gameState.darkMode);
            document.body.classList.toggle('bg-gray-100', !gameState.darkMode);
            document.body.classList.toggle('bg-gray-900', gameState.darkMode);

            const appDiv = document.getElementById('app');
            appDiv.classList.toggle('bg-gray-100', !gameState.darkMode);
            appDiv.classList.toggle('bg-gray-900', gameState.darkMode);

            renderView();
        }

        function startNewGame(mode = 'ai') {
            const difficultyDropdown = document.getElementById('difficulty');
            const difficulty = mode === 'timed' ? '4' : (difficultyDropdown ? difficultyDropdown.value : gameState.difficulty);
            const darkMode = gameState.darkMode;
            gameState = {...INITIAL_GAME_STATE};
            gameState.darkMode = darkMode;
            gameState.view = 'game';
            gameState.gameMode = mode;
            gameState.difficulty = difficulty;
            gameState.playerSymbol = Math.random() < 0.5 ? 'X' : 'O';

            if (mode === 'timed') {
                gameState.playerTimes = {
                    X: 60,
                    O: 60
                };
            }

            renderView();

            if (mode === 'ai' || mode === 'timed') {
                const modal = renderFirstPlayerModal();
                document.body.appendChild(modal);
            }
        }

        function showRules() {
            gameState.view = 'rules';
            renderView();
        }

        function backToLobby() {
    if (gameState.activeTimer) {
        clearInterval(gameState.activeTimer);
        gameState.activeTimer = null;
    }

    gameState.playerTimes = {
        X: 60,
        O: 60
    };

    const darkMode = gameState.darkMode;
    gameState = {...INITIAL_GAME_STATE};
    gameState.view = 'lobby';
    gameState.preventAIMove = true;
    gameState.darkMode = darkMode;

    // Restaurer la langue depuis localStorage
    const savedLanguage = localStorage.getItem('selectedLanguage');
    if (savedLanguage) {
        gameState.language = savedLanguage;
    }

    renderView();
}


        function startTimer(player) {
            if (gameState.activeTimer) {
                clearInterval(gameState.activeTimer);
                gameState.activeTimer = null;
            }

            gameState.activeTimer = setInterval(() => {
                if (gameState.playerTimes[player] > 0 && !gameState.gameWinner) {
                    gameState.playerTimes[player]--;
                    renderView();
                } else {
                    clearInterval(gameState.activeTimer);
                    if (!gameState.gameWinner) {
                        gameState.gameWinner = player === 'X' ? 'O' : 'X';
                    }
                    renderView();
                }
            }, 1000);
        }

        function pauseTimer() {
            if (gameState.activeTimer) {
                clearInterval(gameState.activeTimer);
                gameState.activeTimer = null;
            }
        }

        function handleSquareClick(bigIndex, smallIndex) {
            const { gameWinner, gameMode, currentTurn, playerSymbol,
                   activeBoard, smallBoardWinners, boardStates } = gameState;

            if (gameWinner) {
                showTooltip("theGameIsAlreadyOver");
                return;
            }

            if (activeBoard !== null && activeBoard !== bigIndex) {
                showTooltip("youMustPlayInTheIndicatedGrid");
                return;
            }

            if (smallBoardWinners[bigIndex] !== null) {
                showTooltip("thisGridIsAlreadyWon");
                return;
            }

            if (boardStates[bigIndex][smallIndex] !== null) {
                showTooltip("thisCellIsAlreadyTaken");
                return;
            }

            const newBoardStates = JSON.parse(JSON.stringify(boardStates));
            newBoardStates[bigIndex][smallIndex] = currentTurn;

            const newSmallBoardWinners = [...gameState.smallBoardWinners];
            if (checkWinSmallBoard(newBoardStates[bigIndex])) {
                newSmallBoardWinners[bigIndex] = currentTurn;
            } else if (isBoardFull(newBoardStates[bigIndex])) {
                newSmallBoardWinners[bigIndex] = 'draw';
            }

            let nextActiveBoard = smallIndex;
            if (newSmallBoardWinners[smallIndex] !== null) {
                nextActiveBoard = null;
            }

            let newGameWinner = null;
            if (checkWinBigBoard(newSmallBoardWinners)) {
                newGameWinner = currentTurn;
            } else if (isBigBoardFull(newSmallBoardWinners, newBoardStates)) {
                newGameWinner = 'draw';
            }

            gameState = {
                ...gameState,
                boardStates: newBoardStates,
                smallBoardWinners: newSmallBoardWinners,
                currentTurn: currentTurn === 'X' ? 'O' : 'X',
                activeBoard: nextActiveBoard,
                gameWinner: newGameWinner,
                lastMove: { bigIndex, smallIndex }
            };

            renderView();

            if (gameMode === 'timed') {
                pauseTimer();
                if (!newGameWinner) {
                    startTimer(gameState.currentTurn);
                }
            }

            if ((gameMode === 'ai' || gameMode === 'timed') && !newGameWinner && gameState.currentTurn !== playerSymbol) {
                setTimeout(() => simulateOpponentMove(), 1000);
            }
        }

        function simulateOpponentMove() {
            if (gameState.preventAIMove) {
                return;
            }
            const { activeBoard, boardStates, smallBoardWinners, currentTurn, difficulty, gameMode } = gameState;
            const opponentSymbol = currentTurn;
            const playerSymbol = opponentSymbol === 'X' ? 'O' : 'X';

            let maxDepth;
            switch (difficulty) {
                case '1':
                    maxDepth = 1;
                    break;
                case '4':
                    maxDepth = 4;
                    break;
                case '6':
                    maxDepth = 6;
                    break;
                case '9':
                    maxDepth = 9;
                    break;
                default:
                    maxDepth = 4;
            }

            const isFirstMove = boardStates.every(board => board.every(cell => cell === null));

            if (isFirstMove) {
                const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
                if (validMoves.length > 0) {
                    const [bigIndex, smallIndex] = validMoves[Math.floor(Math.random() * validMoves.length)];
                    const delay = gameMode === 'timed' ? 900 : 0;
                    setTimeout(() => handleSquareClick(bigIndex, smallIndex), delay);
                    return;
                }
            }

            if (!aiWorker) {
                aiWorker = new Worker('aiWorker.js');
            }

            aiWorker.onmessage = function(e) {
                const bestMove = e.data;
                if (bestMove) {
                    const delay = gameMode === 'timed' ? 900 : 0;
                    setTimeout(() => handleSquareClick(bestMove[0], bestMove[1]), delay);
                } else {
                    const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
                    if (validMoves.length > 0) {
                        const [bigIndex, smallIndex] = validMoves[Math.floor(Math.random() * validMoves.length)];
                        const delay = gameMode === 'timed' ? 900 : 0;
                        setTimeout(() => handleSquareClick(bigIndex, smallIndex), delay);
                    }
                }
            };

            aiWorker.postMessage({
                activeBoard,
                boardStates,
                smallBoardWinners,
                aiSymbol: opponentSymbol,
                playerSymbol,
                depth: maxDepth
            });
        }

        function findValidMoves(activeBoard, boardStates, smallBoardWinners) {
            const validMoves = [];

            if (activeBoard === null || smallBoardWinners[activeBoard] !== null) {
                for (let i = 0; i < 9; i++) {
                    if (smallBoardWinners[i] === null) {
                        for (let j = 0; j < 9; j++) {
                            if (boardStates[i][j] === null) {
                                validMoves.push([i, j]);
                            }
                        }
                    }
                }
            } else {
                for (let j = 0; j < 9; j++) {
                    if (boardStates[activeBoard][j] === null) {
                        validMoves.push([activeBoard, j]);
                    }
                }
            }

            return validMoves;
        }

        function renderCell(bigIndex, smallIndex) {
            const { boardStates, gameMode, playerSymbol, currentTurn,
                   activeBoard, smallBoardWinners, darkMode, lastMove } = gameState;

            const value = boardStates[bigIndex][smallIndex];
            const theme = darkMode ? 'dark' : 'light';

            let cellClass = "cell ";

            if (value === null) {
                const isInteractive = (gameMode === 'ai' || gameMode === 'timed') && playerSymbol === currentTurn || gameMode === 'local';
                const isValidTarget = (activeBoard === null || activeBoard === bigIndex) && smallBoardWinners[bigIndex] === null;

                cellClass += theme === 'dark' ? 'bg-gray-800 ' : 'bg-white ';

                if (isInteractive && isValidTarget) {
                    cellClass += theme === 'dark' ? 'hover:bg-gray-600 ' : 'hover:bg-blue-100 ';
                    cellClass += 'valid';
                }
            } else {
                cellClass += theme === 'dark' ? 'bg-gray-800 ' : 'bg-white ';
            }

            const cell = document.createElement('div');
            cell.className = cellClass;

            if (value) {
                const symbol = document.createElement('span');
                symbol.className = `symbol ${value === 'X' ? 'text-red-500 font-bold' : 'text-blue-500 font-bold'}`;
                symbol.textContent = value;

                if (lastMove && lastMove.bigIndex === bigIndex && lastMove.smallIndex === smallIndex) {
                    symbol.classList.add('bounce');
                    setTimeout(() => {
                        symbol.classList.remove('bounce');
                    }, 500);
                }

                cell.appendChild(symbol);
            }

            const columnPosition = smallIndex % 3;
            cell.dataset.column = columnPosition;
            cell.dataset.row = Math.floor(smallIndex / 3);

            if (cellClass.includes('valid')) {
                cell.addEventListener('click', () => handleSquareClick(bigIndex, smallIndex));
            }

            return cell;
        }

        function renderSmallBoard(index) {
            const { activeBoard, smallBoardWinners, darkMode } = gameState;
            const winner = smallBoardWinners[index];
            const theme = darkMode ? 'dark' : 'light';
            const viewportWidth = window.innerWidth;

            const boardDiv = document.createElement('div');
            boardDiv.className = `small-board ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`;

            boardDiv.style.display = 'grid';
            boardDiv.style.gridTemplateColumns = 'repeat(3, 1fr)';
            boardDiv.style.gridTemplateRows = 'repeat(3, 1fr)';

            if (activeBoard === index && winner === null) {
                boardDiv.classList.add('active');
                if (viewportWidth < 400) {
                    boardDiv.style.transform = 'scale(1.02)';
                    boardDiv.style.boxShadow = `0 0 0 2px ${theme === 'dark' ? '#f59e0b' : '#fbbf24'}`;
                } else {
                    boardDiv.style.boxShadow = `0 0 0 4px ${theme === 'dark' ? '#f59e0b' : '#fbbf24'}`;
                }
            }

            if (winner !== null) {
                if (winner === 'draw') {
                    boardDiv.classList.add('draw');
                } else {
                    boardDiv.classList.add(winner === 'X' ? 'won-x' : 'won-o');
                }
            }

            if (winner !== null && winner !== 'draw') {
                const winnerOverlay = document.createElement('div');
                winnerOverlay.className = 'winner-overlay';

                const symbol = document.createElement('span');
                symbol.className = winner === 'X' ? 'text-red-500' : 'text-blue-500';
                symbol.textContent = winner;

                winnerOverlay.appendChild(symbol);
                boardDiv.appendChild(winnerOverlay);
            } else {
                for (let i = 0; i < 9; i++) {
                    boardDiv.appendChild(renderCell(index, i));
                }
            }

            return boardDiv;
        }

        function renderGameBoard() {
            const { darkMode } = gameState;
            const theme = darkMode ? 'dark' : 'light';

            const boardContainer = document.createElement('div');
            boardContainer.className = `game-board ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-300'}`;

            boardContainer.style.display = 'grid';
            boardContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
            boardContainer.style.gridTemplateRows = 'repeat(3, 1fr)';

            const viewportWidth = window.innerWidth;
            if (viewportWidth < 360) {
                boardContainer.style.gap = '4px';
                boardContainer.style.padding = '4px';
            } else if (viewportWidth < 400) {
                boardContainer.style.gap = '6px';
                boardContainer.style.padding = '6px';
            } else if (viewportWidth < 512) {
                boardContainer.style.gap = '8px';
                boardContainer.style.padding = '8px';
            } else {
                boardContainer.style.gap = '16px';
                boardContainer.style.padding = '16px';
            }

            for (let i = 0; i < 9; i++) {
                boardContainer.appendChild(renderSmallBoard(i));
            }

            return boardContainer;
        }

        function renderGameInfo() {
            const { gameMode, currentTurn, playerSymbol, darkMode, playerTimes } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = gameState.language;

            const infoDiv = document.createElement('div');
            infoDiv.className = `game-info ${theme === 'dark' ? 'text-white' : 'text-gray-900'}`;

            const header = document.createElement('div');
            header.className = 'game-info-header header-responsive';

            const modeTitleContainer = document.createElement('div');
            modeTitleContainer.className = 'mode-title-container';
            modeTitleContainer.style.padding = '10px';
            modeTitleContainer.style.borderRadius = '8px';
            modeTitleContainer.style.display = 'inline-block';
            modeTitleContainer.style.backgroundColor = darkMode ? '#4b5563' : '#d1d5db';

            const modeTitle = document.createElement('h2');
            modeTitle.className = 'text-3xl font-bold';
            modeTitle.textContent = gameMode === 'ai' ? translations[lang].playAgainstAI : gameMode === 'local' ? translations[lang].localMultiplayer : translations[lang].timedMode;
            modeTitleContainer.appendChild(modeTitle);

            const settingsBtn = document.createElement('button');
            settingsBtn.className = 'p-2 rounded-full';
            settingsBtn.style.position = 'absolute';
            settingsBtn.style.left = '0';
            settingsBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            settingsBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            settingsBtn.textContent = '⚙️';
            settingsBtn.addEventListener('click', () => {
                const modal = renderSettingsModal();
                document.body.appendChild(modal);
            });

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'p-2 rounded-full';
            toggleBtn.style.position = 'absolute';
            toggleBtn.style.right = '0';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);

            header.appendChild(settingsBtn);
            header.appendChild(modeTitleContainer);
            header.appendChild(toggleBtn);
            infoDiv.appendChild(header);

            if (gameMode === 'timed') {
                const timers = document.createElement('div');
                timers.className = 'player-info';

                const timerXContainer = document.createElement('div');
                timerXContainer.className = `player-box ${currentTurn === 'X' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                timerXContainer.innerHTML = `<span class="text-red-500 font-bold">${playerSymbol === 'X' ? '👤' : '🤖'} X : ${playerTimes.X}s</span>`;

                const timerOContainer = document.createElement('div');
                timerOContainer.className = `player-box ${currentTurn === 'O' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                timerOContainer.innerHTML = `<span class="text-blue-500 font-bold">${playerSymbol === 'O' ? '👤' : '🤖'} O : ${playerTimes.O}s</span>`;

                timers.appendChild(timerXContainer);
                timers.appendChild(timerOContainer);
                infoDiv.appendChild(timers);
            } else if (gameMode === 'local') {
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';

                const playerX = document.createElement('div');
                playerX.className = `player-box ${currentTurn === 'X' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerX.innerHTML = `<span class="text-red-500 font-bold">X</span>${currentTurn === 'X' ? ' - ' + translations[lang].yourTurn : ''}`;

                const playerO = document.createElement('div');
                playerO.className = `player-box ${currentTurn === 'O' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerO.innerHTML = `<span class="text-blue-500 font-bold">O</span>${currentTurn === 'O' ? ' - ' + translations[lang].yourTurn : ''}`;

                playerInfo.appendChild(playerX);
                playerInfo.appendChild(playerO);
                infoDiv.appendChild(playerInfo);
            } else if (gameMode === 'ai') {
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';

                const playerSymbolElement = document.createElement('div');
                playerSymbolElement.className = `player-box ${currentTurn === playerSymbol ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerSymbolElement.innerHTML = `<span class="${playerSymbol === 'X' ? 'text-red-500' : 'text-blue-500'} font-bold">${playerSymbol === 'X' ? '👤 X' : '👤 O'}</span>${currentTurn === playerSymbol ? ' - ' + translations[lang].yourTurn : ''}`;

                const aiSymbolElement = document.createElement('div');
                aiSymbolElement.className = `player-box ${currentTurn !== playerSymbol ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                aiSymbolElement.innerHTML = `<span class="${playerSymbol === 'X' ? 'text-blue-500' : 'text-red-500'} font-bold">🤖 ${playerSymbol === 'X' ? 'O' : 'X'}</span>${currentTurn !== playerSymbol ? ' - ' + translations[lang].aiIsThinking : ''}`;

                playerInfo.appendChild(playerSymbolElement);
                playerInfo.appendChild(aiSymbolElement);
                infoDiv.appendChild(playerInfo);
            }

            const controls = document.createElement('div');
            controls.className = 'mt-6 flex justify-center gap-2';

            const newGameBtn = document.createElement('button');
            newGameBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600';
            newGameBtn.textContent = translations[lang].newGame;
            newGameBtn.addEventListener('click', () => {
                if (gameState.gameMode === 'timed') {
                    pauseTimer();
                }
                startNewGame(gameState.gameMode);
            });

            const lobbyBtn = document.createElement('button');
            lobbyBtn.className = 'bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600';
            lobbyBtn.textContent = translations[lang].backToLobby;
            lobbyBtn.addEventListener('click', backToLobby);

            controls.appendChild(newGameBtn);
            controls.appendChild(lobbyBtn);
            infoDiv.appendChild(controls);

            return infoDiv;
        }

        function renderTurnIndicator() {
            return document.createElement('div');
        }

        function renderGameOverModal() {
            const { gameWinner, gameMode, playerSymbol, darkMode, difficulty, playerTimes, language } = gameState;

            if (!gameWinner) return null;

            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            let message = "";
            let iconSymbol = "";
            let additionalInfo = "";

            const difficultyName = translations[lang].difficultyNames[difficulty] || translations[lang].difficult;

            if (gameWinner === 'draw') {
                message = translations[lang].gameEndedInDraw;
                iconSymbol = "🤝";
                additionalInfo = translations[lang].bothPlayersPlayedWell || "";
            } else if (gameMode === 'ai') {
                message = gameWinner === playerSymbol ? translations[lang].youWon : translations[lang].aiWon;
                iconSymbol = gameWinner === playerSymbol ? "🏆" : "🤖";
                additionalInfo = gameWinner === playerSymbol ? `${translations[lang].youDefeatedTheAI} ${difficultyName}.` : `${translations[lang].theAIWon} ${difficultyName}.`;
            } else if (gameMode === 'timed') {
                if (playerTimes.X <= 0 || playerTimes.O <= 0) {
                    message = gameWinner === 'X' ? translations[lang].playerORanOutOfTime : translations[lang].playerXRanOutOfTime;
                    iconSymbol = gameWinner === 'X' ? "❌" : "⭕";
                    additionalInfo = translations[lang].timesUp || "";
                } else {
                    message = `${translations[lang].playerWon} ${gameWinner}.`;
                    iconSymbol = gameWinner === 'X' ? "❌" : "⭕";
                    additionalInfo = `${translations[lang].playerPlayedWell} ${gameWinner}.`;
                }
            } else {
                message = `${translations[lang].playerWon} ${gameWinner}.`;
                iconSymbol = gameWinner === 'X' ? "❌" : "⭕";
                additionalInfo = `${translations[lang].playerPlayedWell} ${gameWinner}.`;
            }

            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';

            const modal = document.createElement('div');
            modal.className = `modal-content ${theme === 'dark' ? 'bg-gray-800 text-white border-gray-700' : 'bg-white text-gray-900 border-gray-300'} border`;

            const header = document.createElement('div');
            header.className = 'modal-header';

            const icon = document.createElement('div');
            icon.className = 'text-5xl mb-4';
            icon.textContent = iconSymbol;

            const title = document.createElement('h2');
            title.className = 'text-2xl font-bold mb-2';
            title.textContent = message;

            const info = document.createElement('p');
            info.className = 'text-lg mb-4';
            info.textContent = additionalInfo;

            header.appendChild(icon);
            header.appendChild(title);
            header.appendChild(info);

            const buttons = document.createElement('div');
            buttons.className = window.innerWidth < 400 ? 'modal-buttons flex flex-col gap-2' : 'modal-buttons flex gap-2';

            const newGameBtn = document.createElement('button');
            newGameBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1';
            newGameBtn.textContent = translations[lang].newGame;
            newGameBtn.addEventListener('click', () => {
                closeMessage(overlay);
                startNewGame(gameMode);
            });

            const lobbyBtn = document.createElement('button');
            lobbyBtn.className = 'bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 flex-1';
            lobbyBtn.textContent = translations[lang].backToLobby;
            lobbyBtn.addEventListener('click', () => {
                closeMessage(overlay);
                backToLobby();
            });

            buttons.appendChild(newGameBtn);
            buttons.appendChild(lobbyBtn);

            modal.appendChild(header);
            modal.appendChild(buttons);
            overlay.appendChild(modal);

            return overlay;
        }

        function renderLobbyView() {
            const { darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const lobby = document.createElement('div');
            lobby.className = `lobby-view ${theme === 'dark' ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`;

            const header = document.createElement('div');
            header.className = 'header-responsive mb-6';

            const title = document.createElement('h1');
            title.className = 'text-3xl font-bold title-responsive';
            title.textContent = translations[lang].title;

            const settingsBtn = document.createElement('button');
            settingsBtn.className = 'p-2 rounded-full';
            settingsBtn.style.position = 'absolute';
            settingsBtn.style.left = '0';
            settingsBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            settingsBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            settingsBtn.textContent = '⚙️';
            settingsBtn.addEventListener('click', () => {
                const modal = renderSettingsModal();
                document.body.appendChild(modal);
            });

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'p-2 rounded-full';
            toggleBtn.style.position = 'absolute';
            toggleBtn.style.right = '0';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);

            header.appendChild(settingsBtn);
            header.appendChild(title);
            header.appendChild(toggleBtn);
            lobby.appendChild(header);

            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'flex flex-col gap-4';

            const firstRow = document.createElement('div');
            firstRow.className = 'flex flex-col gap-4';

            const aiBtn = document.createElement('button');
            aiBtn.className = 'bg-green-500 text-white px-4 py-3 rounded-lg hover:bg-green-600 text-lg flex items-center justify-center gap-2';
            aiBtn.innerHTML = '<span>🤖</span> ' + translations[lang].playAgainstAI;
            aiBtn.addEventListener('click', () => startNewGame('ai'));

            const difficultySelector = document.createElement('div');
            difficultySelector.className = 'difficulty-selector';

            const difficultyLabel = document.createElement('label');
            difficultyLabel.setAttribute('for', 'difficulty');
            difficultyLabel.textContent = translations[lang].difficulty + ':';

            const difficultyDropdown = document.createElement('select');
            difficultyDropdown.id = 'difficulty';
            difficultyDropdown.className = 'difficulty-dropdown';

            const easyOption = document.createElement('option');
            easyOption.value = '1';
            easyOption.textContent = translations[lang].easy;

            const mediumOption1 = document.createElement('option');
            mediumOption1.value = '4';
            mediumOption1.textContent = translations[lang].normal;
            mediumOption1.selected = true;

            const mediumOption2 = document.createElement('option');
            mediumOption2.value = '6';
            mediumOption2.textContent = translations[lang].difficult;

            const hardOption = document.createElement('option');
            hardOption.value = '9';
            hardOption.textContent = translations[lang].impossible;

            difficultyDropdown.appendChild(easyOption);
            difficultyDropdown.appendChild(mediumOption1);
            difficultyDropdown.appendChild(mediumOption2);
            difficultyDropdown.appendChild(hardOption);

            difficultySelector.appendChild(difficultyLabel);
            difficultySelector.appendChild(difficultyDropdown);

            firstRow.appendChild(aiBtn);
            firstRow.appendChild(difficultySelector);

            const secondRow = document.createElement('div');
            secondRow.className = 'flex flex-col gap-4';

            const multiplayerBtn = document.createElement('button');
            multiplayerBtn.className = 'bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 text-lg flex items-center justify-center gap-2';
            multiplayerBtn.innerHTML = '<span>👥</span> ' + translations[lang].localMultiplayer;
            multiplayerBtn.addEventListener('click', () => startNewGame('local'));

            const timedBtn = document.createElement('button');
            timedBtn.className = 'bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 text-lg flex items-center justify-center gap-2';
            timedBtn.innerHTML = '<span>⏱️</span> ' + translations[lang].timedMode;
            timedBtn.addEventListener('click', () => startNewGame('timed'));

            secondRow.appendChild(multiplayerBtn);
            secondRow.appendChild(timedBtn);

            const rulesBtn = document.createElement('button');
            rulesBtn.className = `${theme === 'dark' ? 'bg-gray-700 text-gray-200' : 'bg-gray-200 text-gray-800'} px-4 py-2 rounded ${theme === 'dark' ? 'hover:bg-gray-600' : 'hover:bg-gray-300'} mt-4`;
            rulesBtn.textContent = translations[lang].gameRules;
            rulesBtn.addEventListener('click', showRules);

            buttonContainer.appendChild(firstRow);
            buttonContainer.appendChild(secondRow);
            buttonContainer.appendChild(rulesBtn);
            lobby.appendChild(buttonContainer);

            difficultyDropdown.addEventListener('change', function() {
                gameState.difficulty = this.value;
                showTooltip(`${translations[lang].difficultyChangedTo} ${this.value}`);
            });

            return lobby;
        }

        function renderSettingsModal() {
            const { darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const overlay = document.createElement('div');
            overlay.className = 'settings-modal-overlay';

            const modal = document.createElement('div');
            modal.className = `settings-modal-content ${theme === 'dark' ? 'bg-gray-800 text-white border-gray-700' : 'bg-white text-gray-900 border-gray-300'} border`;

            const header = document.createElement('div');
            header.className = 'settings-modal-header';

            const title = document.createElement('h2');
            title.className = 'text-2xl font-bold mb-2';
            title.textContent = translations[lang].settings;

            const settingsContent = document.createElement('div');
            settingsContent.className = 'mb-4';

            const languageSelector = document.createElement('div');
            languageSelector.className = 'language-selector';

            const languageLabel = document.createElement('label');
            languageLabel.setAttribute('for', 'language');
            languageLabel.textContent = translations[lang].language + ': ';

            const languageDropdown = document.createElement('select');
            languageDropdown.id = 'language';
            languageDropdown.className = 'language-dropdown';

            const languages = [
                { code: 'en', name: 'English' },
                { code: 'fr', name: 'Français' },
                { code: 'de', name: 'Deutsch' },
                { code: 'it', name: 'Italiano' },
                { code: 'sv', name: 'Svenska' }
            ];

            languages.forEach(langOption => {
                const option = document.createElement('option');
                option.value = langOption.code;
                option.textContent = langOption.name;
                if (langOption.code === language) {
                    option.selected = true;
                }
                languageDropdown.appendChild(option);
            });

            languageDropdown.addEventListener('change', function() {
                gameState.language = this.value;
                localStorage.setItem('selectedLanguage', this.value);
                renderView();
            });

            languageSelector.appendChild(languageLabel);
            languageSelector.appendChild(languageDropdown);
            settingsContent.appendChild(languageSelector);

            header.appendChild(title);
            modal.appendChild(header);
            modal.appendChild(settingsContent);

            const buttons = document.createElement('div');
            buttons.className = 'settings-modal-buttons';

            const closeBtn = document.createElement('button');
            closeBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1';
            closeBtn.textContent = translations[lang].close;
            closeBtn.addEventListener('click', () => {
                closeMessage(overlay);
            });

            buttons.appendChild(closeBtn);
            modal.appendChild(buttons);
            overlay.appendChild(modal);

            return overlay;
        }

        function renderRulesView() {
            const { darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const rules = [
                translations[lang].rule1,
                translations[lang].rule2,
                translations[lang].rule3,
                translations[lang].rule4,
                translations[lang].rule5,
                translations[lang].rule6
            ];

            const rulesView = document.createElement('div');
            rulesView.className = `rules-view ${theme === 'dark' ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`;

            const header = document.createElement('div');
            header.className = 'relative mb-4';

            const title = document.createElement('h1');
            title.className = 'text-2xl font-bold text-center';
            title.textContent = translations[lang].gameRules;

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'p-2 rounded-full absolute right-0 top-0';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);

            header.appendChild(title);
            header.appendChild(toggleBtn);
            rulesView.appendChild(header);

            const rulesList = document.createElement('div');
            rulesList.className = `space-y-4 mb-6 border-t ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'} pt-4`;

            rules.forEach((rule, index) => {
                const ruleItem = document.createElement('div');
                ruleItem.className = 'flex gap-3';

                const number = document.createElement('div');
                number.className = 'text-2xl';
                number.textContent = `${index + 1}️⃣`;

                const text = document.createElement('p');
                text.textContent = rule;

                ruleItem.appendChild(number);
                ruleItem.appendChild(text);
                rulesList.appendChild(ruleItem);
            });

            rulesView.appendChild(rulesList);

            const backBtn = document.createElement('button');
            backBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 w-full';
            backBtn.textContent = translations[lang].backToLobby;
            backBtn.addEventListener('click', backToLobby);

            rulesView.appendChild(backBtn);

            return rulesView;
        }

        function renderGameView() {
            const container = document.createElement('div');

            container.appendChild(renderGameInfo());
            container.appendChild(renderGameBoard());
            container.appendChild(renderTurnIndicator());

            const modal = renderGameOverModal();
            if (modal && !document.querySelector('.modal-overlay')) {
                container.appendChild(modal);
            }

            return container;
        }

        function renderFirstPlayerModal() {
            const { playerSymbol, darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';

            const modal = document.createElement('div');
            modal.className = `modal-content ${theme === 'dark' ? 'bg-gray-800 text-white border-gray-700' : 'bg-white text-gray-900 border-gray-300'} border`;

            const header = document.createElement('div');
            header.className = 'modal-header';

            const icon = document.createElement('div');
            icon.className = 'text-5xl mb-4';
            icon.textContent = playerSymbol === 'X' ? '❌' : '⭕';

            const title = document.createElement('h2');
            title.className = 'text-2xl font-bold mb-2';
            title.textContent = `${translations[lang].youArePlayingAs} ${playerSymbol}`;

            const info = document.createElement('p');
            info.className = 'text-lg mb-4';
            info.textContent = playerSymbol === 'X' ? translations[lang].youGoFirst : translations[lang].aiGoesFirst;

            header.appendChild(icon);
            header.appendChild(title);
            header.appendChild(info);

            const buttons = document.createElement('div');
            buttons.className = 'modal-buttons flex gap-2';

            const continueBtn = document.createElement('button');
            continueBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1';
            continueBtn.textContent = translations[lang].continue;
            continueBtn.addEventListener('click', () => {
                closeMessage(overlay);
                if (playerSymbol === 'O') {
                    setTimeout(() => simulateOpponentMove(), 1000);
                } else if (gameState.gameMode === 'timed') {
                    if (gameState.activeTimer) {
                        clearInterval(gameState.activeTimer);
                        gameState.activeTimer = null;
                    }
                    startTimer(playerSymbol);
                }
            });

            buttons.appendChild(continueBtn);
            modal.appendChild(header);
            modal.appendChild(buttons);
            overlay.appendChild(modal);

            return overlay;
        }

        function closeMessage(element) {
            element.classList.add('exit');
            setTimeout(() => {
                element.remove();
            }, 100);
        }

        function renderView() {
    const appContainer = document.querySelector('#app .container');
    appContainer.innerHTML = '';

    // Restaurer la langue depuis localStorage
    const savedLanguage = localStorage.getItem('selectedLanguage');
    if (savedLanguage) {
        gameState.language = savedLanguage;
    }

    document.body.classList.toggle('dark', gameState.darkMode);

    switch (gameState.view) {
        case 'lobby':
            appContainer.appendChild(renderLobbyView());
            break;
        case 'rules':
            appContainer.appendChild(renderRulesView());
            break;
        case 'game':
            appContainer.appendChild(renderGameView());
            setTimeout(postRenderAdjustments, 0);
            break;
    }
}


        document.addEventListener('DOMContentLoaded', () => {
            const savedLanguage = localStorage.getItem('selectedLanguage');
            if (savedLanguage) {
                gameState.language = savedLanguage;
            }
            renderView();
            adjustGameBoardSize();

            window.addEventListener('resize', () => {
                adjustGameBoardSize();
            });
        });
    </script>
</body>
</html>
