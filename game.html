<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Tic Tac Toe</title>
    <style>

        /* Global styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* Transitions for theme changes */
        body, div, button, p, h1, h2, footer {
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        /* Main containers */
        .container {
            width: 100%;
            max-width: 512px;
            margin: 0 auto;
            padding: 0 16px;
        }

        .min-h-screen {
            min-height: 100vh;
            padding: 32px 16px;
        }

        /* Theme classes - Light mode */
        .bg-gray-100 {
            background-color: #f3f4f6;
        }
        .bg-white {
            background-color: #ffffff;
        }
        .text-gray-900 {
            color: #111827;
        }
        .text-gray-600 {
            color: #4b5563;
        }
        .border-gray-300 {
            border-color: #d1d5db;
        }
        .bg-gray-200 {
            background-color: #e5e7eb;
        }
        .text-gray-800 {
            color: #1f2937;
        }
        .hover\:bg-gray-300:hover {
            background-color: #d1d5db;
        }
        .bg-blue-100 {
            background-color: #dbeafe;
        }
        .bg-red-200 {
            background-color: #fecaca;
        }
        .bg-blue-200 {
            background-color: #bfdbfe;
        }
        .ring-yellow-400 {
            box-shadow: 0 0 0 4px #fbbf24;
        }
        .text-gray-500 {
            color: #6b7280;
        }
        .bg-gray-100 {
            background-color: #f3f4f6;
        }

        /* Theme classes - Dark mode */
        .dark .bg-gray-900 {
            background-color: #111827;
        }
        .dark .bg-gray-800 {
            background-color: #1f2937;
        }
        .dark .text-white {
            color: #ffffff;
        }
        .dark .text-gray-300 {
            color: #d1d5db;
        }
        .dark .border-gray-700 {
            border-color: #374151;
        }
        .dark .bg-gray-700 {
            background-color: #374151;
        }
        .dark .bg-blue-900 {
            background-color: #1e3a8a;
        }
        .dark .text-gray-200 {
            color: #e5e7eb;
        }
        .dark .hover\:bg-gray-600:hover {
            background-color: #4b5563;
        }
        .dark .bg-gray-600 {
            background-color: #4b5563;
        }
        .dark .bg-red-900 {
            background-color: #7f1d1d;
        }
        .dark .ring-yellow-500 {
            box-shadow: 0 0 0 4px #f59e0b;
        }
        .dark .text-gray-400 {
            color: #9ca3af;
        }

        /* Common button styles */

        .difficulty-selector {
            margin-bottom: 16px;
            text-align: center;
        }

        .difficulty-selector label {
            margin-right: 8px;
            font-weight: bold;
        }

        .difficulty-dropdown {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
            font-size: 16px;
        }

        .difficulty-dropdown:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        button {
            cursor: pointer;
            font-weight: 500;
            border: none;
            border-radius: 0.375rem;
        }

        .bg-blue-500 {
            background-color: #3b82f6;
            color: white;
        }
        .hover\:bg-blue-600:hover {
            background-color: #2563eb;
        }
        
        .bg-gray-500 {
            background-color: #6b7280;
            color: white;
        }
        .hover\:bg-gray-600:hover {
            background-color: #4b5563;
        }

        .bg-purple-500 {
            background-color: #8b5cf6;
            color: white;
        }
        .hover\:bg-purple-600:hover {
            background-color: #7c3aed;
        }

        .bg-green-500 {
            background-color: #10b981;
            color: white;
        }
        .hover\:bg-green-600:hover {
            background-color: #059669;
        }

        /* Layout utilities */
        .flex {
            display: flex;
        }
        .flex-col {
            flex-direction: column;
        }
        .items-center {
            align-items: center;
        }
        .justify-center {
            justify-content: center;
        }
        .justify-between {
            justify-between: space-between;
        }
        .gap-2 {
            gap: 8px;
        }
        .gap-3 {
            gap: 12px;
        }
        .gap-4 {
            gap: 16px;
        }
        .mt-4 {
            margin-top: 16px;
        }
        .mt-6 {
            margin-top: 24px;
        }
        .mt-8 {
            margin-top: 32px;
        }
        .mb-2 {
            margin-bottom: 8px;
        }
        .mb-4 {
            margin-bottom: 16px;
        }
        .mb-6 {
            margin-bottom: 24px;
        }
        .p-2 {
            padding: 8px;
        }
        .p-4 {
            padding: 16px;
        }
        .p-6 {
            padding: 24px;
        }
        .px-4 {
            padding-left: 16px;
            padding-right: 16px;
        }
        .py-2 {
            padding-top: 8px;
            padding-bottom: 8px;
        }
        .py-3 {
            padding-top: 12px;
            padding-bottom: 12px;
        }
        .pt-4 {
            padding-top: 16px;
        }
        .rounded {
            border-radius: 0.25rem;
        }
        .rounded-lg {
            border-radius: 0.5rem;
        }
        .rounded-full {
            border-radius: 9999px;
        }
        .border {
            border-width: 1px;
            border-style: solid;
        }
        .border-t {
            border-top-width: 1px;
            border-top-style: solid;
        }
        .border-2 {
            border-width: 2px;
            border-style: solid;
        }
        .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .shadow-xl {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .w-full {
            width: 100%;
        }
        .max-w-sm {
            max-width: 384px;
        }
        .max-w-md {
            max-width: 448px;
        }
        .max-w-lg {
            max-width: 512px;
        }
        .space-y-4 > * + * {
            margin-top: 16px;
        }
        .flex-1 {
            flex: 1 1 0%;
        }

        /* Text utilities */
        .text-center {
            text-align: center;
        }
        .text-sm {
            font-size: 0.875rem;
        }
        .text-lg {
            font-size: 1.125rem;
        }
        .text-xl {
            font-size: 1.25rem;
        }
        .text-2xl {
            font-size: 1.5rem;
        }
        .text-3xl {
            font-size: 1.875rem;
        }
        .text-4xl {
            font-size: 2.25rem;
        }
        .text-5xl {
            font-size: 3rem;
        }
        .font-medium {
            font-weight: 500;
        }
        .font-semibold {
            font-weight: 600;
        }
        .font-bold {
            font-weight: 700;
        }
        .text-red-500 {
            color: #ef4444;
        }
        .text-blue-500 {
            color: #3b82f6;
        }

        @media (max-width: 512px) {
            .game-board {
                gap: 8px;
                padding: 8px;
            }

            .cell {
                width: 28px;
                height: 28px;
                font-size: 0.95rem;
                aspect-ratio: 1 / 1;
            }

            .small-board {
                gap: 1px;
                padding: 1px;
                display: grid;
                grid-template-columns: repeat(3, 1fr);
            }

            .header-responsive {
                display: flex !important;
                justify-content: space-between;
                align-items: center;
            }
            
            .title-responsive {
                flex: 1;
                text-align: center;
                padding-right: 42px;
            }
        }

        @media (max-width: 360px) {
            .cell {
                aspect-ratio: 1 / 1;
                min-width: 18px;
                font-size: 0.75rem;
            }

            .game-board {
                gap: 4px;
                padding: 4px;
            }
        }

        @media (max-width: 400px) {
            .game-board {
                gap: 6px;
                padding: 6px;
            }   

            .cell {
                width: auto; 
                height: auto;
                aspect-ratio: 1 / 1;
                min-width: 20px;
                font-size: 0.875rem;
            }

            .small-board {
                gap: 0px;
                padding: 1px;
            }
            
            .button-grid {
                grid-template-columns: 1fr;
            }

            .modal-buttons {
                flex-direction: column;
            }
        }

        /* Game board styles */
        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            padding: 16px;
            max-width: 512px;
            margin: 0 auto;
            border-radius: 0.5rem;
            border-width: 2px;
            border-style: solid;
        }

        .small-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            border-width: 1px;
            border-style: solid;
            border-radius: 0.25rem;
            padding: 2px;
            position: relative;
            overflow: hidden;
        }

        .small-board.active {
            transform: scale(1.03);
        }

        .small-board.won-x {
            background-color: #fecaca;
        }
        .dark .small-board.won-x {
            background-color: #7f1d1d;
        }

        .small-board.won-o {
            background-color: #bfdbfe;
        }
        .dark .small-board.won-o {
            background-color: #1e3a8a;
        }

        .small-board.draw {
            opacity: 0.5;
        }

        .cell {
            box-sizing: border-box;
            overflow: hidden;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
        }

        .cell.valid {
            cursor: pointer;
        }

        .winner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem;
            font-weight: bold;
        }

        @media (min-width: 768px) {
            .cell {
                width: 40px;
                height: 40px;
            }
            .grid-cols-2 {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        /* Game views */
        .game-view, .lobby-view, .rules-view {
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 24px;
            margin: 0 auto;
        }

        /* Game info section */
        .game-info {
            margin-bottom: 24px;
            text-align: center;
        }
        
        .game-info-header {
            position: relative;
            margin-bottom: 16px;
            text-align: center;
        }
        
        .player-info {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 8px;
        }
        
        .player-box {
            padding: 8px 16px;
            border-radius: 0.5rem;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        .modal-content {
            border-radius: 0.5rem;
            max-width: 384px;
            width: 100%;
            padding: 24px;
        }
        
        .modal-header {
            text-align: center;
            margin-bottom: 24px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 12px;
        }
        
        /* Tooltip */
        .tooltip {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background-color: black;
            color: white;
            padding: 8px 16px;
            border-radius: 0.25rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            opacity: 0.9;
            z-index: 50;
            display: none;
        }
        
        /* Utilities for positioning */
        .relative {
            position: relative;
        }
        
        .absolute {
            position: absolute;
        }
        
        .right-0 {
            right: 0;
        }
        
        .top-0 {
            top: 0;
        }
        
        /* Footer */
        footer {
            margin-top: 32px;
            text-align: center;
            font-size: 0.875rem;
        }
        
        /* Button layouts */
        .button-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        @media (min-width: 768px) {
            .button-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="app" class="min-h-screen">
        <div class="container">
            <!-- Views will be dynamically inserted here -->
        </div>
        
        <footer class="text-gray-500">
            Ultimate Tic Tac Toe © 2025
        </footer>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
        // Constants for reuse
        const INITIAL_GAME_STATE = {
           view: 'lobby', // lobby, game, rules
           playerId: `player_${Math.random().toString(36).substring(2, 9)}`,
           playerSymbol: null,
           currentTurn: 'X',
           activeBoard: null,
           boardStates: Array(9).fill().map(() => Array(9).fill(null)),
           smallBoardWinners: Array(9).fill(null),
           gameWinner: null,
           tooltipMessage: '',
           tooltipVisible: false,
           gameMode: 'ai', // 'ai' or 'local'
           darkMode: false,
           difficulty: 'medium' // Ajoutez cette ligne pour le niveau de difficulté
       };

        // Constants for reuse
        const WIN_PATTERNS = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
            [0, 4, 8], [2, 4, 6]             // diagonals
        ];

        // Main game state
        let gameState = {...INITIAL_GAME_STATE};

        // Helper functions
        function checkWinSmallBoard(board) {
            return WIN_PATTERNS.some(([a, b, c]) => 
                board[a] && board[a] === board[b] && board[a] === board[c]
            );
        }
        
        function checkWinBigBoard(winners) {
            return WIN_PATTERNS.some(([a, b, c]) => 
                winners[a] && winners[a] !== 'draw' && winners[a] === winners[b] && winners[a] === winners[c]
            );
        }
        
        function isBoardFull(board) {
            return board.every(cell => cell !== null);
        }
        
        function isBigBoardFull(winners, boardStates) {
            if (winners.every(winner => winner !== null)) return true;
            
            return !boardStates.some((board, i) => 
                winners[i] === null && board.some(cell => cell === null)
            );
        }

        function adjustGameBoardSize() {
            const viewportWidth = window.innerWidth;
            const gameBoard = document.querySelector('.game-board');

            if (!gameBoard) return;

            if (viewportWidth < 360) {
                gameBoard.style.maxWidth = '270px';
            } else if (viewportWidth < 400) {
                gameBoard.style.maxWidth = '310px';
            } else if (viewportWidth < 500) {
                gameBoard.style.maxWidth = '390px';
            } else {
                gameBoard.style.maxWidth = '512px';
            }

            const cells = document.querySelectorAll('.cell');
            const smallBoards = document.querySelectorAll('.small-board');

            if (viewportWidth < 360) {
                smallBoards.forEach(board => {
                    board.style.gap = '0px';
                    board.style.padding = '1px';
                });
            } else if (viewportWidth < 400) {
                smallBoards.forEach(board => {
                    board.style.gap = '1px';
                    board.style.padding = '1px';
                });
            }
        }

        //Réajustement taille après rendu
        function postRenderAdjustments() {
            adjustGameBoardSize();
            const smallBoards = document.querySelectorAll('.small-board');
            smallBoards.forEach((board, index) => {
                if (gameState.activeBoard === index && gameState.smallBoardWinners[index] === null) {
                    const viewportWidth = window.innerWidth;
                    if (viewportWidth < 400) {
                        board.style.transform = 'scale(1.02)';
                        board.style.boxShadow = '0 0 0 2px #fbbf24';
                    }
                }
            });
            ensureSquareCells();
        }

        function ensureSquareCells() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const width = cell.offsetWidth;
                cell.style.height = `${width}px`;
            });
        }

        // UI functions
        function showTooltip(message) {
            gameState.tooltipMessage = message;
            gameState.tooltipVisible = true;
            
            const tooltip = document.getElementById('tooltip');
            tooltip.textContent = message;
            tooltip.style.display = 'block';
            
            setTimeout(() => {
                gameState.tooltipVisible = false;
                tooltip.style.display = 'none';
            }, 2000);
        }

        function toggleDarkMode() {
            gameState.darkMode = !gameState.darkMode;
            document.body.classList.toggle('dark', gameState.darkMode);
            
            // Mettre à jour le fond du body
            document.body.classList.toggle('bg-gray-100', !gameState.darkMode);
            document.body.classList.toggle('bg-gray-900', gameState.darkMode);
            
            // Mettre à jour également la div app qui couvre tout l'écran
            const appDiv = document.getElementById('app');
            appDiv.classList.toggle('bg-gray-100', !gameState.darkMode);
            appDiv.classList.toggle('bg-gray-900', gameState.darkMode);
            
            renderView();
        }

        // Navigation functions
        function startNewGame(mode = 'ai') {
            const difficultyDropdown = document.getElementById('difficulty');
            const difficulty = difficultyDropdown ? difficultyDropdown.value : gameState.difficulty;
            const darkMode = gameState.darkMode; // Sauvegardez le paramètre du mode sombre
            gameState = {...INITIAL_GAME_STATE};
            gameState.darkMode = darkMode; // Restaurez le paramètre du mode sombre
            gameState.view = 'game';
            gameState.gameMode = mode;
            gameState.difficulty = difficulty; // Ajoutez la difficulté à l'état du jeu

            // Choisir aléatoirement le symbole du joueur
            gameState.playerSymbol = mode === 'ai' ? (Math.random() < 0.5 ? 'X' : 'O') : null;
            // Vérifiez si l'IA doit commencer
            if (mode === 'ai' && gameState.playerSymbol === 'O') {
                setTimeout(() => simulateOpponentMove(), 1000);
            }

            console.log("New game state:", gameState); // Ajoutez ceci pour le débogage
            renderView();
        }
        
        function showRules() {
            gameState.view = 'rules';
            renderView();
        }
        
        function backToLobby() {
            gameState.view = 'lobby';
            renderView();
        }

        // Transposition table for memoization
        const transpositionTable = new Map();

        // Hash function for game states
        function hashGameState(boardStates, smallBoardWinners, activeBoard, isMaximizing) {
            return JSON.stringify({
                bs: boardStates,
                sbw: smallBoardWinners,
                ab: activeBoard,
                im: isMaximizing
            });
        }

        // Evaluate the position
        function evaluatePosition(activeBoard, boardStates, smallBoardWinners, aiSymbol, playerSymbol) {
            let score = 0;

            // Evaluate the big board
            score += evaluateBigBoard(smallBoardWinners, aiSymbol, playerSymbol) * 150;

            // Evaluate strategic positions
            score += evaluateStrategicPositions(smallBoardWinners, aiSymbol, playerSymbol) * 80;

            // Evaluate small boards
            score += evaluateSmallBoards(boardStates, smallBoardWinners, aiSymbol, playerSymbol) * 30;

            // Evaluate next board advantage
            score += evaluateNextBoardAdvantage(activeBoard, boardStates, smallBoardWinners, aiSymbol, playerSymbol) * 40;

            return score;
        }

        // Evaluate the big board
        function evaluateBigBoard(smallBoardWinners, aiSymbol, playerSymbol) {
            let score = 0;
        
            for (const pattern of WIN_PATTERNS) {
                const [a, b, c] = pattern;
                const aiCount = pattern.filter(idx => smallBoardWinners[idx] === aiSymbol).length;
                const playerCount = pattern.filter(idx => smallBoardWinners[idx] === playerSymbol).length;
                const emptyCount = 3 - aiCount - playerCount;

                if (aiCount === 2 && emptyCount === 1) score += 800;
                if (playerCount === 2 && emptyCount === 1) score -= 750;
                if (playerCount === 0) score += aiCount * 120;
                if (aiCount === 0) score -= playerCount * 100;
            }

            return score;
        }

        // Evaluate strategic positions
        function evaluateStrategicPositions(smallBoardWinners, aiSymbol, playerSymbol) {
            let score = 0;

            if (smallBoardWinners[4] === aiSymbol) score += 80;
            else if (smallBoardWinners[4] === playerSymbol) score -= 75;
            else if (smallBoardWinners[4] === null) score += 30;

            const corners = [0, 2, 6, 8];
            for (const corner of corners) {
                if (smallBoardWinners[corner] === aiSymbol) score += 50;
                else if (smallBoardWinners[corner] === playerSymbol) score -= 45;
            }

            const sides = [1, 3, 5, 7];
            for (const side of sides) {
                if (smallBoardWinners[side] === aiSymbol) score += 30;
                else if (smallBoardWinners[side] === playerSymbol) score -= 25;
            }

            return score;
        }

        // Evaluate small boards
        function evaluateSmallBoards(boardStates, smallBoardWinners, aiSymbol, playerSymbol) {
            let score = 0;

            for (let boardIdx = 0; boardIdx < 9; boardIdx++) {
                if (smallBoardWinners[boardIdx] !== null) continue;

                const board = boardStates[boardIdx];

                for (const pattern of WIN_PATTERNS) {
                    const [a, b, c] = pattern;
                    const aiCells = [a, b, c].filter(idx => board[idx] === aiSymbol).length;
                    const playerCells = [a, b, c].filter(idx => board[idx] === playerSymbol).length;
                    const emptyCells = [a, b, c].filter(idx => board[idx] === null).length;

                    if (aiCells === 2 && emptyCells === 1) score += 60;
                    if (playerCells === 2 && emptyCells === 1) score -= 55;
                    if (playerCells === 0 && emptyCells > 0) score += aiCells * 8;
                    if (aiCells === 0 && emptyCells > 0) score -= playerCells * 7;
                }

                if (board[4] === aiSymbol) score += 7;
                if (board[4] === playerSymbol) score -= 6;

                for (const corner of [0, 2, 6, 8]) {
                    if (board[corner] === aiSymbol) score += 5;
                    if (board[corner] === playerSymbol) score -= 4;
                }
            }

            return score;
        }

        // Evaluate next board advantage
        function evaluateNextBoardAdvantage(activeBoard, boardStates, smallBoardWinners, aiSymbol, playerSymbol) {
            if (activeBoard === null) return 0;

            let score = 0;

            if (smallBoardWinners[activeBoard] === null) {
                const board = boardStates[activeBoard];

                for (const pattern of WIN_PATTERNS) {
                    const [a, b, c] = pattern;
                    const aiCells = [a, b, c].filter(idx => board[idx] === aiSymbol).length;
                    const playerCells = [a, b, c].filter(idx => board[idx] === playerSymbol).length;
                    const emptyCells = [a, b, c].filter(idx => board[idx] === null).length;

                    if (aiCells === 2 && emptyCells === 1) score += 70;
                    if (playerCells === 2 && emptyCells === 1) score -= 65;
                }

                if ([0, 2, 6, 8, 4].includes(activeBoard)) score += 10;
            } else {
                score += 15;
            }

            return score;
        }

        // Find valid moves
        function findValidMoves(activeBoard, boardStates, smallBoardWinners) {
            const validMoves = [];

            if (activeBoard === null || smallBoardWinners[activeBoard] !== null) {
                for (let i = 0; i < 9; i++) {
                    if (smallBoardWinners[i] === null) {
                        for (let j = 0; j < 9; j++) {
                            if (boardStates[i][j] === null) {
                                validMoves.push([i, j]);
                            }
                        }
                    }
                }
            } else {
                for (let j = 0; j < 9; j++) {
                    if (boardStates[activeBoard][j] === null) {
                        validMoves.push([activeBoard, j]);
                    }
                }
            }

            return validMoves;
        }

        // Minimax with alpha-beta pruning
        function minimax(activeBoard, boardStates, smallBoardWinners, depth, isMaximizing, alpha, beta, aiSymbol, playerSymbol) {
            const hash = hashGameState(boardStates, smallBoardWinners, activeBoard, isMaximizing);
            const cachedResult = transpositionTable.get(hash);
            if (cachedResult && cachedResult.depth >= depth) {
                return cachedResult.score;
            }

            if (depth === 0) {
                const evaluation = evaluatePosition(activeBoard, boardStates, smallBoardWinners, aiSymbol, playerSymbol);
                transpositionTable.set(hash, { score: evaluation, depth });
                return evaluation;
            }

            const winner = checkWinBigBoard(smallBoardWinners);
            if (winner) {
                const score = winner === aiSymbol ? 10000 + depth : -10000 - depth;
                transpositionTable.set(hash, { score, depth: Infinity });
                return score;
            }

            if (isBigBoardFull(smallBoardWinners, boardStates)) {
                transpositionTable.set(hash, { score: 0, depth: Infinity });
                return 0;
            }

            const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
            if (validMoves.length === 0) {
                transpositionTable.set(hash, { score: 0, depth: Infinity });
                return 0;
            }

            const ratedMoves = orderMoves(validMoves, boardStates, smallBoardWinners, isMaximizing ? aiSymbol : playerSymbol);

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const [bigIndex, smallIndex] of ratedMoves) {
                    const newBoardStates = JSON.parse(JSON.stringify(boardStates));
                    newBoardStates[bigIndex][smallIndex] = aiSymbol;

                    const newSmallBoardWinners = [...smallBoardWinners];
                    if (checkWinSmallBoard(newBoardStates[bigIndex])) {
                        newSmallBoardWinners[bigIndex] = aiSymbol;
                    } else if (isBoardFull(newBoardStates[bigIndex])) {
                        newSmallBoardWinners[bigIndex] = 'draw';
                    }

                    let nextActiveBoard = smallIndex;
                    if (newSmallBoardWinners[smallIndex] !== null) {
                        nextActiveBoard = null;
                    }

                    const evalScore = minimax(
                        nextActiveBoard,
                        newBoardStates,
                        newSmallBoardWinners,
                        depth - 1,
                        false,
                        alpha,
                        beta,
                        aiSymbol,
                        playerSymbol
                    );

                    maxEval = Math.max(maxEval, evalScore);
                    alpha = Math.max(alpha, evalScore);
                    if (beta <= alpha) break;
                }

                transpositionTable.set(hash, { score: maxEval, depth });
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const [bigIndex, smallIndex] of ratedMoves) {
                    const newBoardStates = JSON.parse(JSON.stringify(boardStates));
                    newBoardStates[bigIndex][smallIndex] = playerSymbol;

                    const newSmallBoardWinners = [...smallBoardWinners];
                    if (checkWinSmallBoard(newBoardStates[bigIndex])) {
                        newSmallBoardWinners[bigIndex] = playerSymbol;
                    } else if (isBoardFull(newBoardStates[bigIndex])) {
                        newSmallBoardWinners[bigIndex] = 'draw';
                    }

                    let nextActiveBoard = smallIndex;
                    if (newSmallBoardWinners[smallIndex] !== null) {
                        nextActiveBoard = null;
                    }

                    const evalScore = minimax(
                        nextActiveBoard,
                        newBoardStates,
                        newSmallBoardWinners,
                        depth - 1,
                        true,
                        alpha,
                        beta,
                        aiSymbol,
                        playerSymbol
                    );

                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore);
                    if (beta <= alpha) break;
                }

                transpositionTable.set(hash, { score: minEval, depth });
                return minEval;
            }
        }

        // Order moves for better alpha-beta pruning
        function orderMoves(validMoves, boardStates, smallBoardWinners, currentSymbol) {
            const scoredMoves = validMoves.map(move => {
                const [bigIndex, smallIndex] = move;
                let score = 0;

                const tempBoard = [...boardStates[bigIndex]];
                tempBoard[smallIndex] = currentSymbol;
                if (checkWinSmallBoard(tempBoard)) score += 1000;

                if (smallIndex === 4) score += 30;
                if ([0, 2, 6, 8].includes(smallIndex)) score += 20;

                if (smallBoardWinners[smallIndex] !== null) score += 50;

                if ([0, 2, 6, 8, 4].includes(bigIndex)) score += 10;

                return { move, score };
            });

            scoredMoves.sort((a, b) => b.score - a.score);
            return scoredMoves.map(item => item.move);
        }

        // Simulate opponent move
        function simulateOpponentMove() {
            const { activeBoard, boardStates, smallBoardWinners, currentTurn, difficulty } = gameState;
            const opponentSymbol = currentTurn;
            const playerSymbol = opponentSymbol === 'X' ? 'O' : 'X';

            transpositionTable.clear();

            let bestMove = null;
            let maxDepth;
            switch (difficulty) {
                case '1': // Easy
                    maxDepth = 1;
                    break;
                case '4': // Normal
                    maxDepth = 4;
                    break;
                case '6': // Difficult
                    maxDepth = 6;
                    break;
                case '15': // Hardcore
                    maxDepth = 15;
                    break;
                default:
                    maxDepth = 4;
            }

            const startTime = Date.now();
            const timeLimit = 5000;

            // Vérifiez si c'est le premier tour de l'IA
            const isFirstMove = boardStates.every(board => board.every(cell => cell === null));

            if (isFirstMove) {
                // Choisissez un mouvement aléatoire pour le premier tour
                const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
                if (validMoves.length > 0) {
                    const [bigIndex, smallIndex] = validMoves[Math.floor(Math.random() * validMoves.length)];
                    handleSquareClick(bigIndex, smallIndex);
                    return;
                }
            }

            for (let depth = 1; depth <= maxDepth; depth++) {
                const move = findBestMoveWithMinimax(activeBoard, boardStates, smallBoardWinners, opponentSymbol, playerSymbol, depth);

                if (Date.now() - startTime > timeLimit) {
                    console.log(`Max depth reached: ${depth-1}`);
                    break;
                }

                bestMove = move;
            }

            if (bestMove) {
                handleSquareClick(bestMove[0], bestMove[1]);
            } else {
                const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
                if (validMoves.length > 0) {
                    const [bigIndex, smallIndex] = validMoves[Math.floor(Math.random() * validMoves.length)];
                    handleSquareClick(bigIndex, smallIndex);
                }
            }
        }

        // Find best move with Minimax
        function findBestMoveWithMinimax(activeBoard, boardStates, smallBoardWinners, aiSymbol, playerSymbol, depth) {
            const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
            if (validMoves.length === 0) return null;

            let bestScore = -Infinity;
            let bestMove = null;

            let alpha = -Infinity;
            let beta = Infinity;

            const ratedMoves = validMoves.map(move => {
                const [bigIndex, smallIndex] = move;
                let score = 0;

                const tempBoardState = [...boardStates[bigIndex]];
                tempBoardState[smallIndex] = aiSymbol;
                if (checkWinSmallBoard(tempBoardState)) score += 1000;

                if (smallIndex === 4) score += 30;
                if ([0, 2, 6, 8].includes(smallIndex)) score += 20;

                if (smallBoardWinners[smallIndex] !== null) score += 50;

                if ([0, 2, 6, 8, 4].includes(bigIndex)) score += 10;

                return { move, score };
            });

            ratedMoves.sort((a, b) => b.score - a.score);
            const sortedMoves = ratedMoves.map(rated => rated.move);

            for (const [bigIndex, smallIndex] of sortedMoves) {
                const newBoardStates = JSON.parse(JSON.stringify(boardStates));
                newBoardStates[bigIndex][smallIndex] = aiSymbol;

                const newSmallBoardWinners = [...smallBoardWinners];
                if (checkWinSmallBoard(newBoardStates[bigIndex])) {
                    newSmallBoardWinners[bigIndex] = aiSymbol;
                } else if (isBoardFull(newBoardStates[bigIndex])) {
                    newSmallBoardWinners[bigIndex] = 'draw';
                }

                if (checkWinBigBoard(newSmallBoardWinners)) return [bigIndex, smallIndex];

                let nextActiveBoard = smallIndex;
                if (newSmallBoardWinners[smallIndex] !== null) nextActiveBoard = null;

                const score = minimax(
                    nextActiveBoard,
                    newBoardStates,
                    newSmallBoardWinners,
                    depth - 1,
                    false,
                    alpha,
                    beta,
                    aiSymbol,
                    playerSymbol
                );

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = [bigIndex, smallIndex];
                }

                alpha = Math.max(alpha, bestScore);
                if (beta <= alpha) break;
            }

            return bestMove;
        }

        // Check if a small board is won
        function checkWinSmallBoard(board) {
            return WIN_PATTERNS.some(([a, b, c]) =>
                board[a] && board[a] === board[b] && board[a] === board[c]
            );
        }

        // Check if a board is full
        function isBoardFull(board) {
            return board.every(cell => cell !== null);
        }

        // Check if the big board is won
        function checkWinBigBoard(smallBoardWinners) {
            return WIN_PATTERNS.some(([a, b, c]) =>
                smallBoardWinners[a] &&
                smallBoardWinners[a] !== 'draw' &&
                smallBoardWinners[a] === smallBoardWinners[b] &&
                smallBoardWinners[a] === smallBoardWinners[c]
            );
        }

        // Check if the big board is full
        function isBigBoardFull(smallBoardWinners, boardStates) {
            for (let i = 0; i < 9; i++) {
                if (smallBoardWinners[i] === null && boardStates[i].some(cell => cell === null)) {
                    return false;
                }
            }
            return true;
        }
        // Handle board square click
        function handleSquareClick(bigIndex, smallIndex) {
            const { gameWinner, gameMode, currentTurn, playerSymbol, 
                   activeBoard, smallBoardWinners, boardStates } = gameState;
            
            // Early returns for invalid moves
            if (gameWinner || 
                (activeBoard !== null && activeBoard !== bigIndex) ||
                smallBoardWinners[bigIndex] !== null ||
                boardStates[bigIndex][smallIndex] !== null) {
                
                // Show appropriate tooltip message
                if (gameWinner) return;
                if (activeBoard !== null && activeBoard !== bigIndex) {
                    showTooltip("You must play in the indicated grid!");
                } else if (smallBoardWinners[bigIndex] !== null) {
                    showTooltip("This grid is already won!");
                } else if (boardStates[bigIndex][smallIndex] !== null) {
                    showTooltip("This cell is already taken!");
                }
                return;
            }

            // Make the move
            const newBoardStates = JSON.parse(JSON.stringify(boardStates));
            newBoardStates[bigIndex][smallIndex] = currentTurn;

            // Check for small board win
            const newSmallBoardWinners = [...gameState.smallBoardWinners];
            if (checkWinSmallBoard(newBoardStates[bigIndex])) {
                newSmallBoardWinners[bigIndex] = currentTurn;
            } else if (isBoardFull(newBoardStates[bigIndex])) {
                newSmallBoardWinners[bigIndex] = 'draw';
            }

            // Determine next active board
            let nextActiveBoard = smallIndex;
            if (newSmallBoardWinners[smallIndex] !== null) {
                nextActiveBoard = null;
            }

            // Check for game win
            let newGameWinner = null;
            if (checkWinBigBoard(newSmallBoardWinners)) {
                newGameWinner = currentTurn;
            } else if (isBigBoardFull(newSmallBoardWinners, newBoardStates)) {
                newGameWinner = 'draw';
            }

            // Update game state
            gameState = {
                ...gameState,
                boardStates: newBoardStates,
                smallBoardWinners: newSmallBoardWinners,
                currentTurn: currentTurn === 'X' ? 'O' : 'X',
                activeBoard: nextActiveBoard,
                gameWinner: newGameWinner
            };

            // Re-render the view with updated state
            renderView();

            // In AI mode, simulate opponent move after delay
            if (gameMode === 'ai' && !newGameWinner && gameState.currentTurn !== playerSymbol) {
                setTimeout(() => simulateOpponentMove(), 1000);
            }
        }

        // Render functions
        function renderCell(bigIndex, smallIndex) {
            const { boardStates, gameMode, playerSymbol, currentTurn, 
                   activeBoard, smallBoardWinners, darkMode } = gameState;
            
            const value = boardStates[bigIndex][smallIndex];
            const theme = darkMode ? 'dark' : 'light';
            
            let cellClass = "cell ";
            
            if (value === null) {
                const isInteractive = (gameMode === 'ai' && playerSymbol === currentTurn) || gameMode === 'local';
                const isValidTarget = (activeBoard === null || activeBoard === bigIndex) && smallBoardWinners[bigIndex] === null;
                
                cellClass += theme === 'dark' ? 'bg-gray-800 ' : 'bg-white ';
                
                if (isInteractive && isValidTarget) {
                    cellClass += theme === 'dark' ? 'hover:bg-gray-600 ' : 'hover:bg-blue-100 ';
                    cellClass += 'valid';
                }
            } else {
                cellClass += theme === 'dark' ? 'bg-gray-800 ' : 'bg-white ';
                cellClass += value === 'X' ? 'text-red-500 font-bold' : 'text-blue-500 font-bold';
            }
            
            const cell = document.createElement('div');
            cell.className = cellClass;
            cell.textContent = value || '';

            const columnPosition = smallIndex % 3;
            cell.dataset.column = columnPosition;
            
            if (cellClass.includes('valid')) {
                cell.addEventListener('click', () => handleSquareClick(bigIndex, smallIndex));
            }
            
            return cell;
        }

        function renderSmallBoard(index) {
            const { activeBoard, smallBoardWinners, darkMode } = gameState;
            const winner = smallBoardWinners[index];
            const theme = darkMode ? 'dark' : 'light';
            const viewportWidth = window.innerWidth;
            
            const boardDiv = document.createElement('div');
            boardDiv.className = `small-board ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`;

            boardDiv.style.display = 'grid';
            boardDiv.style.gridTemplateColumns = 'repeat(3, 1fr)';
            boardDiv.style.gridTemplateRows = 'repeat(3, 1fr)';
            
            // Active board styling
            if (activeBoard === index && winner === null) {
                boardDiv.classList.add('active');
                if (viewportWidth < 400) {
                    boardDiv.style.boxShadow = `0 0 0 2px ${theme === 'dark' ? '#f59e0b' : '#fbbf24'}`;
                } else {
                    boardDiv.style.boxShadow = `0 0 0 4px ${theme === 'dark' ? '#f59e0b' : '#fbbf24'}`;
                }
            }
            
            // Winner styling
            if (winner !== null) {
                if (winner === 'draw') {
                    boardDiv.classList.add('draw');
                } else {
                    boardDiv.classList.add(winner === 'X' ? 'won-x' : 'won-o');
                }
            }
            
            if (winner !== null && winner !== 'draw') {
                // Show winner symbol
                const winnerOverlay = document.createElement('div');
                winnerOverlay.className = 'winner-overlay';
                
                const symbol = document.createElement('span');
                symbol.className = winner === 'X' ? 'text-red-500' : 'text-blue-500';
                symbol.textContent = winner;
                
                winnerOverlay.appendChild(symbol);
                boardDiv.appendChild(winnerOverlay);
            } else {
                // Render cells
                for (let i = 0; i < 9; i++) {
                    boardDiv.appendChild(renderCell(index, i));
                }
            }
            
            return boardDiv;
        }

        function renderGameBoard() {
            const { darkMode } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            
            const boardContainer = document.createElement('div');
            boardContainer.className = `game-board ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-300'}`;

            boardContainer.style.display = 'grid';
            boardContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
            boardContainer.style.gridTemplateRows = 'repeat(3, 1fr)';

            const viewportWidth = window.innerWidth;
            if (viewportWidth < 360) {
                boardContainer.style.gap = '4px';
                boardContainer.style.padding = '4px';
            } else if (viewportWidth < 400) {
                boardContainer.style.gap = '6px';
                boardContainer.style.padding = '6px';
            } else if (viewportWidth < 512) {
                boardContainer.style.gap = '8px';
                boardContainer.style.padding = '8px';
            } else {
                boardContainer.style.gap = '16px';
                boardContainer.style.padding = '16px';
            }
            
            for (let i = 0; i < 9; i++) {
                boardContainer.appendChild(renderSmallBoard(i));
            }
            
            return boardContainer;
        }

        function renderGameInfo() {
            const { gameMode, currentTurn, playerSymbol, activeBoard, darkMode } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            
            const infoDiv = document.createElement('div');
            infoDiv.className = `game-info ${theme === 'dark' ? 'text-white' : 'text-gray-900'}`;
            
            // Header with title and dark mode toggle
            const header = document.createElement('div');
            header.className = 'game-info-header';
            
            const title = document.createElement('h2');
            title.className = 'text-2xl font-bold';
            title.textContent = 'Ultimate Tic Tac Toe';
            header.appendChild(title);
            
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'absolute right-0 top-0 p-2 rounded-full';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);
            header.appendChild(toggleBtn);
            
            infoDiv.appendChild(header);
            
            // Game mode info
            const modeInfo = document.createElement('p');
            modeInfo.className = 'text-xl font-semibold mb-2';
            modeInfo.textContent = gameMode === 'ai' ? 'Mode: Solo vs AI' : 'Mode: Local Multiplayer';
            infoDiv.appendChild(modeInfo);
            
            // Player info
            if (gameMode === 'local') {
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                
                const playerX = document.createElement('div');
                playerX.className = `player-box ${currentTurn === 'X' ? 
                                              (theme === 'dark' ? 'bg-blue-900' : 'bg-blue-100') : 
                                              (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerX.innerHTML = `<span class="text-red-500 font-bold">X</span>${currentTurn === 'X' ? ' - Your turn' : ''}`;
                
                const playerO = document.createElement('div');
                playerO.className = `player-box ${currentTurn === 'O' ? 
                                              (theme === 'dark' ? 'bg-blue-900' : 'bg-blue-100') : 
                                              (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerO.innerHTML = `<span class="text-blue-500 font-bold">O</span>${currentTurn === 'O' ? ' - Your turn' : ''}`;
                
                playerInfo.appendChild(playerX);
                playerInfo.appendChild(playerO);
                infoDiv.appendChild(playerInfo);
            }
            
            if (gameMode === 'ai') {
                const turnInfo = document.createElement('p');
                turnInfo.className = 'text-lg mb-2';
                turnInfo.textContent = currentTurn === playerSymbol ? 'Your turn' : "AI is thinking...";
                infoDiv.appendChild(turnInfo);
            }
            
            // Active board info
            const boardInfo = document.createElement('p');
            boardInfo.className = `text-sm ${theme === 'dark' ? 'text-gray-300' : 'text-gray-600'} font-medium`;
            boardInfo.textContent = activeBoard === null 
                ? "You can play in any open grid" 
                : `You must play in grid ${activeBoard + 1}`;
            infoDiv.appendChild(boardInfo);
            
            // Game controls
            const controls = document.createElement('div');
            controls.className = 'mt-6 flex justify-center gap-2';
            
            const newGameBtn = document.createElement('button');
            newGameBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600';
            newGameBtn.textContent = 'New Game';
            newGameBtn.addEventListener('click', () => startNewGame(gameMode));
            
            const lobbyBtn = document.createElement('button');
            lobbyBtn.className = 'bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600';
            lobbyBtn.textContent = 'Back to Lobby';
            lobbyBtn.addEventListener('click', backToLobby);
            
            controls.appendChild(newGameBtn);
            controls.appendChild(lobbyBtn);
            infoDiv.appendChild(controls);
            
            return infoDiv;
        }

        function renderGameOverModal() {
            const { gameWinner, gameMode, playerSymbol, darkMode, difficulty } = gameState;

            if (!gameWinner) return null;

            const theme = darkMode ? 'dark' : 'light';

            let message = "";
            let iconSymbol = "";
            let additionalInfo = ""; // Nouvelle variable pour les informations supplémentaires

            // Mapper les valeurs de difficulté aux noms
            const difficultyNames = {
                '1': 'Easy',
                '4': 'Normal',
                '6': 'Difficult',
                '15': 'Impossible'
            };

            const difficultyName = difficultyNames[difficulty] || 'Unknown';

            if (gameWinner === 'draw') {
                message = "The game ended in a draw.";
                iconSymbol = "🤝";
                additionalInfo = "Both players played well.";
            } else if (gameMode === 'ai') {
                message = gameWinner === playerSymbol ? "You won." : "AI won.";
                iconSymbol = gameWinner === playerSymbol ? "🏆" : "🤖";
                additionalInfo = gameWinner === playerSymbol ? `You defeated the AI at level ${difficultyName}.` : `The AI won at level ${difficultyName}.`;
            } else {
                message = `Player ${gameWinner} won.`;
                iconSymbol = gameWinner === 'X' ? "❌" : "⭕";
                additionalInfo = `Player ${gameWinner} played well.`;
            }

            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';

            const modal = document.createElement('div');
            modal.className = `modal-content ${theme === 'dark' ? 'bg-gray-800 text-white border-gray-700' : 'bg-white text-gray-900 border-gray-300'} border`;

            const header = document.createElement('div');
            header.className = 'modal-header';

            const icon = document.createElement('div');
            icon.className = 'text-5xl mb-4';
            icon.textContent = iconSymbol;

            const title = document.createElement('h2');
            title.className = 'text-2xl font-bold mb-2';
            title.textContent = message;

            const info = document.createElement('p');
            info.className = 'text-lg mb-4';
            info.textContent = additionalInfo;

            header.appendChild(icon);
            header.appendChild(title);
            header.appendChild(info);

            const buttons = document.createElement('div');
            buttons.className = window.innerWidth < 400 ? 'modal-buttons flex flex-col gap-2' : 'modal-buttons flex gap-2';

            const newGameBtn = document.createElement('button');
            newGameBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1';
            newGameBtn.textContent = 'New Game';
            newGameBtn.addEventListener('click', () => startNewGame(gameMode));

            const lobbyBtn = document.createElement('button');
            lobbyBtn.className = 'bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 flex-1';
            lobbyBtn.textContent = 'Back to Lobby';
            lobbyBtn.addEventListener('click', backToLobby);

            buttons.appendChild(newGameBtn);
            buttons.appendChild(lobbyBtn);

            modal.appendChild(header);
            modal.appendChild(buttons);
            overlay.appendChild(modal);

            return overlay;
        }



        function renderLobbyView() {
            const { darkMode } = gameState;
            const theme = darkMode ? 'dark' : 'light';

            const lobby = document.createElement('div');
            lobby.className = `lobby-view ${theme === 'dark' ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`;

            // Header avec titre centré et bouton dark mode à droite
            const header = document.createElement('div');
            header.className = 'relative text-center mb-6 header-responsive';

            const title = document.createElement('h1');
            title.className = 'text-3xl font-bold title-responsive';
            title.textContent = 'Ultimate Tic Tac Toe';

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'absolute right-0 top-0 p-2 rounded-full';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);

            header.appendChild(title);
            header.appendChild(toggleBtn);
            lobby.appendChild(header);

            // Game mode buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'flex flex-col gap-4';

            const gameButtons = document.createElement('div');
            gameButtons.className = 'button-grid';

            const multiplayerBtn = document.createElement('button');
            multiplayerBtn.className = 'bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 text-lg flex items-center justify-center gap-2';
            multiplayerBtn.innerHTML = '<span>👥</span> Local Multiplayer';
            multiplayerBtn.addEventListener('click', () => startNewGame('local'));

            const aiBtn = document.createElement('button');
            aiBtn.className = 'bg-green-500 text-white px-4 py-3 rounded-lg hover:bg-green-600 text-lg flex items-center justify-center gap-2';
            aiBtn.innerHTML = '<span>🤖</span> Play against AI';
            aiBtn.addEventListener('click', () => startNewGame('ai'));

            gameButtons.appendChild(multiplayerBtn);
            gameButtons.appendChild(aiBtn);

            const rulesBtn = document.createElement('button');
            rulesBtn.className = `${theme === 'dark' ? 'bg-gray-700 text-gray-200' : 'bg-gray-200 text-gray-800'} px-4 py-2 rounded ${theme === 'dark' ? 'hover:bg-gray-600' : 'hover:bg-gray-300'} mt-4`;
            rulesBtn.textContent = 'Game Rules';
            rulesBtn.addEventListener('click', showRules);

            // Ajoutez le menu déroulant pour le niveau de difficulté
            const difficultySelector = document.createElement('div');
            difficultySelector.className = 'difficulty-selector';

            const difficultyLabel = document.createElement('label');
            difficultyLabel.setAttribute('for', 'difficulty');
            difficultyLabel.textContent = 'Difficulty Level:';

            const difficultyDropdown = document.createElement('select');
            difficultyDropdown.id = 'difficulty';
            difficultyDropdown.className = 'difficulty-dropdown';

            const easyOption = document.createElement('option');
            easyOption.value = '1'; // Mode à 4
            easyOption.textContent = 'Easy';

            const mediumOption1 = document.createElement('option');
            mediumOption1.value = '4'; // Mode à 6
            mediumOption1.textContent = 'Normal';
            mediumOption1.selected = true; // Définir cette option comme sélectionnée par défaut

            const mediumOption2 = document.createElement('option');
            mediumOption2.value = '6'; // Mode à 7
            mediumOption2.textContent = 'Difficult';

            const hardOption = document.createElement('option');
            hardOption.value = '15'; // Mode à 8
            hardOption.textContent = 'Impossible';

            difficultyDropdown.appendChild(easyOption);
            difficultyDropdown.appendChild(mediumOption1);
            difficultyDropdown.appendChild(mediumOption2);
            difficultyDropdown.appendChild(hardOption);

            difficultySelector.appendChild(difficultyLabel);
            difficultySelector.appendChild(difficultyDropdown);

            buttonContainer.appendChild(gameButtons);
            buttonContainer.appendChild(difficultySelector);
            buttonContainer.appendChild(rulesBtn);
            lobby.appendChild(buttonContainer);

            difficultyDropdown.addEventListener('change', function() {
                gameState.difficulty = this.value;
                console.log('Difficulty level changed to:', gameState.difficulty);
                showTooltip(`Difficulty level set to: ${gameState.difficulty}`);
            });

            return lobby;
        }


        function renderRulesView() {
            const { darkMode } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            
            const rules = [
                "Ultimate Tic Tac Toe consists of 9 small Tic Tac Toe grids, forming one large grid.",
                "On each turn, you must play in the small grid corresponding to the cell played by your opponent in their small grid.",
                "For example, if your opponent plays in the top-right cell of their small grid, you must play in the top-right small grid of the large grid.",
                "If you are sent to a grid that is already won or full, you can play in any open grid.",
                "To win a small grid, align 3 symbols as in classic Tic Tac Toe.",
                "To win the game, align 3 won small grids."
            ];
            
            const rulesView = document.createElement('div');
            rulesView.className = `rules-view ${theme === 'dark' ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`;
            
            // Header with title and dark mode toggle
            const header = document.createElement('div');
            header.className = 'relative mb-4';
            
            const title = document.createElement('h1');
            title.className = 'text-2xl font-bold text-center';
            title.textContent = 'Game Rules';
            
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'p-2 rounded-full absolute right-0 top-0';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);
            
            header.appendChild(title);
            header.appendChild(toggleBtn);
            rulesView.appendChild(header);
            
            // Rules list
            const rulesList = document.createElement('div');
            rulesList.className = `space-y-4 mb-6 border-t ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'} pt-4`;
            
            rules.forEach((rule, index) => {
                const ruleItem = document.createElement('div');
                ruleItem.className = 'flex gap-3';
                
                const number = document.createElement('div');
                number.className = 'text-2xl';
                number.textContent = `${index + 1}️⃣`;
                
                const text = document.createElement('p');
                text.textContent = rule;
                
                ruleItem.appendChild(number);
                ruleItem.appendChild(text);
                rulesList.appendChild(ruleItem);
            });
            
            rulesView.appendChild(rulesList);
            
            // Back button
            const backBtn = document.createElement('button');
            backBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 w-full';
            backBtn.textContent = 'Back to Lobby';
            backBtn.addEventListener('click', backToLobby);
            
            rulesView.appendChild(backBtn);
            
            return rulesView;
        }

        function renderGameView() {
            const container = document.createElement('div');
            
            container.appendChild(renderGameInfo());
            container.appendChild(renderGameBoard());
            
            const modal = renderGameOverModal();
            if (modal) {
                container.appendChild(modal);
            }
            
            return container;
        }

        function renderView() {
            const appContainer = document.querySelector('#app .container');
            appContainer.innerHTML = '';
            
            // Apply dark mode to body
            document.body.classList.toggle('dark', gameState.darkMode);
            
            // Render the appropriate view
            switch (gameState.view) {
                case 'lobby':
                    appContainer.appendChild(renderLobbyView());
                    break;
                case 'rules':
                    appContainer.appendChild(renderRulesView());
                    break;
                case 'game':
                    appContainer.appendChild(renderGameView());
                    setTimeout(postRenderAdjustments, 0);
                    break;
            }
        }

        // Initialize the game
        document.addEventListener('DOMContentLoaded', () => {
            renderView();
            adjustGameBoardSize();

            window.addEventListener('resize', () => {
                adjustGameBoardSize();
            });
        });
    </script>
</body>
</html>
