<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Tic Tac Toe</title>
    <style>
        /* Styles globaux */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* Animation de rebond */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.2);
            }
            60% {
                transform: scale(0.9);
            }
        }

        .bounce {
            animation: bounce 0.5s;
        }

        /* Animation accentuée */
        @keyframes enhancedBounce {
            0%, 20%, 50%, 80%, 100% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.4);
            }
            60% {
                transform: scale(0.8);
            }
        }

        .enhanced-bounce {
            animation: enhancedBounce 0.7s;
        }

        /* Animation d'entrée */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInlayout {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        /* Animation de sortie */
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        @keyframes zoom {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .zoom {
            animation: zoom 1s infinite;
        }

        /* Animation d'entrée aux layouts */
        .lobby-view, .game-view, .rules-view {
            animation: fadeInlayout 0.3s ease-in-out;
        }

        /* Animation de sortie aux layouts */
        .lobby-view.exit, .game-view.exit, .rules-view.exit {
            animation: fadeOut 0.3s ease-in-out;
        }

        /* Animation d'entrée aux messages */
        .tooltip, .modal-content {
            animation: fadeIn 0.3s ease-in-out;
        }

        /* Animation de sortie aux messages */
        .tooltip.exit, .modal-content.exit {
            animation: fadeOut 0.3s ease-in-out;
        }

        /* Transition pour le changement de thème */
        body, div, button, p, h1, h2, footer {
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        /* Effet de survol pour les cases valides */
        .cell.valid {
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }

        .cell.valid:hover {
            transform: scale(1.13);
            background-color: #dbeafe;
        }

        /* Assurez-vous que l'effet est visible en mode sombre */
        .dark .cell.valid:hover {
            background-color: #4b5563;
        }

        /* Ajoutez ce style pour la modal de paramètres */
        .settings-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .settings-modal-content {
            border-radius: 0.5rem;
            max-width: 384px;
            width: 100%;
            padding: 24px;
        }

        .settings-modal-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .settings-modal-buttons {
            display: flex;
            gap: 12px;
        }

        /* Assurez-vous que le conteneur d'en-tête est correctement configuré */
        .header-responsive {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .title-responsive {
            text-align: center;
        }

        /* Conteneurs principaux */
        .container {
            width: 100%;
            max-width: 512px;
            margin: 0 auto;
            padding: 0 16px;
        }

        .min-h-screen {
            min-height: 100vh;
            padding: 32px 16px;
        }

        /* Light mode */
        .bg-gray-100 {
            background-color: #f3f4f6;
        }
        .bg-white {
            background-color: #ffffff;
        }
        .text-gray-900 {
            color: #111827;
        }
        .text-gray-600 {
            color: #4b5563;
        }
        .border-gray-300 {
            border-color: #d1d5db;
        }
        .bg-gray-200 {
            background-color: #e5e7eb;
        }
        .text-gray-800 {
            color: #1f2937;
        }
        .hover\:bg-gray-300:hover {
            background-color: #d1d5db;
        }
        .bg-blue-100 {
            background-color: #dbeafe;
        }
        .bg-red-200 {
            background-color: #fecaca;
        }
        .bg-blue-200 {
            background-color: #bfdbfe;
        }
        .ring-yellow-400 {
            box-shadow: 0 0 0 4px #fbbf24;
        }
        .text-gray-500 {
            color: #6b7280;
        }
        .bg-gray-100 {
            background-color: #f3f4f6;
        }

        /* Theme classes - Dark mode */
        .dark .bg-gray-900 {
            background-color: #111827;
        }
        .dark .bg-gray-800 {
            background-color: #1f2937;
        }
        .dark .text-white {
            color: #ffffff;
        }
        .dark .text-gray-300 {
            color: #d1d5db;
        }
        .dark .border-gray-700 {
            border-color: #374151;
        }
        .dark .bg-gray-700 {
            background-color: #374151;
        }
        .dark .bg-blue-900 {
            background-color: #1e3a8a;
        }
        .dark .text-gray-200 {
            color: #e5e7eb;
        }
        .dark .hover\:bg-gray-600:hover {
            background-color: #4b5563;
        }
        .dark .bg-gray-600 {
            background-color: #4b5563;
        }
        .dark .bg-red-900 {
            background-color: #7f1d1d;
        }
        .dark .ring-yellow-500 {
            box-shadow: 0 0 0 4px #f59e0b;
        }
        .dark .text-gray-400 {
            color: #9ca3af;
        }

        /* Common button styles */
        .difficulty-selector {
            margin-bottom: 16px;
            text-align: center;
        }

        .difficulty-selector label {
            margin-right: 8px;
            font-weight: bold;
        }

        .difficulty-dropdown {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
            font-size: 16px;
        }

        .difficulty-dropdown:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        button {
            cursor: pointer;
            font-weight: 500;
            border: none;
            border-radius: 0.375rem;
        }

        .bg-blue-500 {
            background-color: #3b82f6;
            color: white;
        }
        .hover\:bg-blue-600:hover {
            background-color: #2563eb;
        }

        .bg-gray-500 {
            background-color: #6b7280;
            color: white;
        }
        .hover\:bg-gray-600:hover {
            background-color: #4b5563;
        }

        .bg-purple-500 {
            background-color: #8b5cf6;
            color: white;
        }
        .hover\:bg-purple-600:hover {
            background-color: #7c3aed;
        }

        .bg-green-500 {
            background-color: #10b981;
            color: white;
        }
        .hover\:bg-green-600:hover {
            background-color: #059669;
        }

        .hover\:bg-yellow-400:hover {
            background-color: #facc15;
        }
        .hover\:bg-emerald-600:hover {
            background-color: #84cc16;
        }

        /* Layout */
        .flex {
            display: flex;
        }
        .flex-col {
            flex-direction: column;
        }
        .items-center {
            align-items: center;
        }
        .justify-center {
            justify-content: center;
        }
        .justify-between {
            justify-content: space-between;
        }
        .gap-2 {
            gap: 8px;
        }
        .gap-3 {
            gap: 12px;
        }
        .gap-4 {
            gap: 16px;
        }
        .mt-4 {
            margin-top: 16px;
        }
        .mt-6 {
            margin-top: 24px;
        }
        .mt-8 {
            margin-top: 32px;
        }
        .mb-2 {
            margin-bottom: 8px;
        }
        .mb-4 {
            margin-bottom: 16px;
        }
        .mb-6 {
            margin-bottom: 24px;
        }
        .p-2 {
            padding: 8px;
        }
        .p-4 {
            padding: 16px;
        }
        .p-6 {
            padding: 24px;
        }
        .px-4 {
            padding-left: 16px;
            padding-right: 16px;
        }
        .py-2 {
            padding-top: 8px;
            padding-bottom: 8px;
        }
        .py-3 {
            padding-top: 12px;
            padding-bottom: 12px;
        }
        .pt-4 {
            padding-top: 16px;
        }
        .rounded {
            border-radius: 0.25rem;
        }
        .rounded-lg {
            border-radius: 0.5rem;
        }
        .rounded-full {
            border-radius: 9999px;
        }
        .border {
            border-width: 1px;
            border-style: solid;
        }
        .border-t {
            border-top-width: 1px;
            border-top-style: solid;
        }
        .border-2 {
            border-width: 2px;
            border-style: solid;
        }
        .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .shadow-xl {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .w-full {
            width: 100%;
        }
        .max-w-sm {
            max-width: 384px;
        }
        .max-w-md {
            max-width: 448px;
        }
        .max-w-lg {
            max-width: 512px;
        }
        .space-y-4 > * + * {
            margin-top: 16px;
        }
        .flex-1 {
            flex: 1 1 0%;
        }

        /* Texte */
        .text-center {
            text-align: center;
        }
        .text-sm {
            font-size: 0.875rem;
        }
        .text-lg {
            font-size: 1.125rem;
        }
        .text-xl {
            font-size: 1.25rem;
        }
        .text-2xl {
            font-size: 1.5rem;
        }
        .text-3xl {
            font-size: 1.875rem;
        }
        .text-4xl {
            font-size: 2.25rem;
        }
        .text-5xl {
            font-size: 3rem;
        }
        .font-medium {
            font-weight: 500;
        }
        .font-semibold {
            font-weight: 600;
        }
        .font-bold {
            font-weight: 700;
        }
        .text-red-500 {
            color: #ef4444;
        }
        .text-blue-500 {
            color: #3b82f6;
        }

        .turn-text {
            color: #1f2937;
        }

        .dark .turn-text {
            color: #ffffff;
        }

        /* Styles pour le sélecteur de langue */
        .language-selector {
            margin-bottom: 16px;
            text-align: center;
        }

        .language-dropdown {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
            font-size: 16px;
        }

        .language-dropdown:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        @media (max-width: 512px) {
            .game-board {
                gap: 8px;
                padding: 8px;
            }

            .cell {
                width: 28px;
                height: 28px;
                font-size: 0.95rem;
                aspect-ratio: 1 / 1;
            }

            .small-board {
                gap: 1px;
                padding: 1px;
                display: grid;
                grid-template-columns: repeat(3, 1fr);
            }

            .header-responsive {
                flex-direction: column;
                align-items: fixed;
            }

            .title-responsive {
                width: 70%;
                text-align: center;
                margin-top: 10px;
            }

            .text-3xl {
                font-size: 1.5rem;
            }

            .game-info-header {
                margin-bottom: 12px;
            }

            .modal-buttons {
                gap: 8px;
            }
        }

        @media (max-width: 360px) {
            .cell {
                aspect-ratio: 1 / 1;
                min-width: 18px;
                font-size: 0.75rem;
            }

            .game-board {
                gap: 4px;
                padding: 4px;
            }

            .title-responsive {
                width: 70%;
                text-align: center;
            }
        }

        @media (max-width: 400px) {
            .game-board {
                gap: 6px;
                padding: 6px;
            }

            .cell {
                width: auto;
                height: auto;
                aspect-ratio: 1 / 1;
                min-width: 20px;
                font-size: 0.875rem;
            }

            .small-board {
                gap: 0px;
                padding: 1px;
            }

            .button-grid {
                grid-template-columns: 1fr;
            }

            .modal-buttons {
                flex-direction: column;
            }

            .title-responsive {
                width: 70%;
                text-align: center;
            }
        }

        /* Game board styles */
        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            padding: 16px;
            max-width: 512px;
            margin: 0 auto;
            border-radius: 0.5rem;
            border-width: 2px;
            border-style: solid;
        }

        .small-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            border-width: 1px;
            border-style: solid;
            border-radius: 0.25rem;
            padding: 2px;
            position: relative;
            overflow: hidden;
        }

        .small-board.active {
            transform: scale(1.03);
        }

        .small-board.won-x {
            background-color: #fecaca;
        }
        .dark .small-board.won-x {
            background-color: #7f1d1d;
        }

        .small-board.won-o {
            background-color: #bfdbfe;
        }
        .dark .small-board.won-o {
            background-color: #1e3a8a;
        }

        .small-board.draw {
            opacity: 0.5;
        }

        .cell {
            box-sizing: border-box;
            overflow: hidden;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
        }

        .cell.valid {
            cursor: pointer;
        }

        .winner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem;
            font-weight: bold;
        }

        @media (min-width: 768px) {
            .cell {
                width: 40px;
                height: 40px;
            }
            .grid-cols-2 {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            .title-responsive {
                width: 70%;
                text-align: center;
            }
        }

        /* Game views */
        .game-view, .lobby-view, .rules-view {
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 24px;
            margin: 0 auto;
        }

        /* Game info section */
        .game-info {
            margin-bottom: 24px;
            text-align: center;
        }

        .game-info-header {
            position: relative;
            margin-bottom: 16px;
            text-align: center;
        }

        .player-info {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 8px;
        }

        .player-box {
            padding: 8px 16px;
            border-radius: 0.5rem;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .modal-content {
            border-radius: 0.5rem;
            max-width: 384px;
            width: 100%;
            padding: 24px;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background-color: black;
            color: white;
            padding: 8px 16px;
            border-radius: 0.25rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            opacity: 0.9;
            z-index: 50;
            display: none;
        }

        /* Utilities for positioning */
        .relative {
            position: relative;
        }

        .absolute {
            position: absolute;
        }

        .right-0 {
            right: 0;
        }

        .top-0 {
            top: 0;
        }

        /* Footer glitché */
        footer {
            position: fixed;
            bottom: 0;
            width: 100%;
            color: white;
            text-align: center;
            padding: 10px 0;
            font-size: 0.875rem;
            z-index: 100;
        }

        /* Button layouts */
        .button-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        @media (min-width: 768px) {
            .button-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @keyframes blink {
            0%, 100% {
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
        }

        .thinking-dots {
            display: inline-block;
            font-size: 24px;
            margin: 10px;
        }

        .thinking-dots span {
            display: inline-block;
            opacity: 0;
            animation: blink 1.4s infinite both;
        }

        .thinking-dots span:nth-child(1) {
            animation-delay: 0.2s;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: 0.4s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0.6s;
        }

        .turn-indicator {
            display: inline-block;
            min-width: 120px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="app" class="min-h-screen">
        <div class="container">
        </div>
        <footer class="text-gray-500">
            Ultimate Tic Tac Toe © 2025
        </footer>
    </div>
    <div id="tooltip" class="tooltip"></div>
    <script>
        // Ajoutez les traductions
        const translations = {
            en: {
                level: "level",
                title: "Ultimate Tic Tac Toe",
                playAgainstAI: "Play against AI",
                localMultiplayer: "Local Multiplayer",
                timedMode: "Timed Mode",
                gameRules: "Game Rules",
                settings: "Settings",
                difficulty: "Difficulty",
                close: "Close",
                continue: "Continue",
                newGame: "New Game",
                backToLobby: "Back to Lobby",
                language: "Language",
                easy: "Easy",
                normal: "Normal",
                difficult: "Difficult",
                youArePlayingAs: "You are playing as",
                youGoFirst: "You go first!",
                aiGoesFirst: "AI goes first!",
                youWon: "You won.",
                aiWon: "AI won.",
                playerWon: "Player won.",
                gameEndedInDraw: "The game ended in a draw.",
                playerXRanOutOfTime: "Player X ran out of time. Player O wins!",
                playerORanOutOfTime: "Player O ran out of time. Player X wins!",
                playerXWon: "Player X won.",
                playerOWon: "Player O won.",
                gameOver: "Game Over",
                theGameIsAlreadyOver: "The game is already over!",
                youMustPlayInTheIndicatedGrid: "You must play in the indicated grid!",
                thisGridIsAlreadyWon: "This grid is already won!",
                thisCellIsAlreadyTaken: "This cell is already taken!",
                difficultyChangedTo: "Difficulty changed to:",
                difficultyNames: {
                    '1': 'Easy',
                    '4': 'Normal',
                    '8': 'Difficult'
                },
                yourTurn: "Your turn",
                aiIsThinking: "AI is thinking",
                rule1: "Ultimate Tic Tac Toe is made up of 9 smaller Tic Tac Toe boards arranged in a big 3x3 grid.",
                rule2: "You must play in the small board that matches where your opponent last played.",
                rule3: "Example: If your opponent plays in the top-right cell, you must play in the top-right grid.",
                rule4: "If you're sent to a board that's already won or full, you can play anywhere.",
                rule5: "Win a small board by getting three in a row, just like regular Tic Tac Toe.",
                rule6: "Win the game by aligning three grids.",
                youDefeatedTheAI: "You defeated the AI at",
                theAIWon: "The AI won at"
            },
            fr: {
                level: "niveau",
                title: "Morpion Ultime",
                playAgainstAI: "Jouer contre l'IA",
                localMultiplayer: "Multijoueur Local",
                timedMode: "Mode Chronométré",
                gameRules: "Règles du Jeu",
                settings: "Paramètres",
                difficulty: "Difficulté",
                close: "Fermer",
                continue: "Continuer",
                newGame: "Nouvelle Partie",
                backToLobby: "Retour au Lobby",
                language: "Langue",
                easy: "Facile",
                normal: "Normal",
                difficult: "Difficile",
                youArePlayingAs: "Vous jouez en tant que",
                youGoFirst: "Vous commencez!",
                aiGoesFirst: "L'IA commence!",
                youWon: "Vous avez gagné.",
                aiWon: "L'IA a gagné.",
                playerWon: "Le joueur a gagné.",
                gameEndedInDraw: "La partie s'est terminée par un match nul.",
                playerXRanOutOfTime: "Le joueur X a manqué de temps. Le joueur O gagne!",
                playerORanOutOfTime: "Le joueur O a manqué de temps. Le joueur X gagne!",
                playerXWon: "Le joueur X a gagné.",
                playerOWon: "Le joueur O a gagné.",
                gameOver: "Fin de la partie",
                theGameIsAlreadyOver: "La partie est déjà terminée!",
                youMustPlayInTheIndicatedGrid: "Vous devez jouer dans la grille indiquée!",
                thisGridIsAlreadyWon: "Cette grille est déjà gagnée!",
                thisCellIsAlreadyTaken: "Cette cellule est déjà prise!",
                difficultyChangedTo: "Difficulté changée en:",
                difficultyNames: {
                    '1': 'Facile',
                    '4': 'Normal',
                    '8': 'Difficile'
                },
                yourTurn: "Votre tour",
                aiIsThinking: "L'IA réfléchit",
                rule1: "Le Morpion Ultime est composé de 9 grilles de Morpion disposées en une grande grille 3x3.",
                rule2: "Vous devez jouer dans la grille correspondant à la dernière case jouée par votre adversaire.",
                rule3: "Exemple: Si votre adversaire joue dans la case en haut à droite, vous devez jouer dans la grille en haut à droite.",
                rule4: "Si vous êtes dirigé vers une grille déjà gagnée ou pleine, vous pouvez jouer n'importe où.",
                rule5: "Gagnez une petite grille en alignant trois symboles, comme au Morpion classique.",
                rule6: "Gagnez la partie en alignant trois grilles.",
                youDefeatedTheAI: "Vous avez battu l'IA au",
                theAIWon: "L'IA a gagné au"
            },
            de: {
                level: "Stufe",
                title: "Ultimatives Tic Tac Toe",
                playAgainstAI: "Gegen KI spielen",
                localMultiplayer: "Lokaler Mehrspieler",
                timedMode: "Zeitmodus",
                gameRules: "Spielregeln",
                settings: "Einstellungen",
                difficulty: "Schwierigkeit",
                close: "Schließen",
                continue: "Fortsetzen",
                newGame: "Neues Spiel",
                backToLobby: "Zurück zur Lobby",
                language: "Sprache",
                easy: "Einfach",
                normal: "Normal",
                difficult: "Schwierig",
                youArePlayingAs: "Sie spielen als",
                youGoFirst: "Sie beginnen!",
                aiGoesFirst: "Die KI beginnt!",
                youWon: "Sie haben gewonnen.",
                aiWon: "Die KI hat gewonnen.",
                playerWon: "Der Spieler hat gewonnen.",
                gameEndedInDraw: "Das Spiel endete unentschieden.",
                playerXRanOutOfTime: "Spieler X hat keine Zeit mehr. Spieler O gewinnt!",
                playerORanOutOfTime: "Spieler O hat keine Zeit mehr. Spieler X gewinnt!",
                playerXWon: "Spieler X hat gewonnen.",
                playerOWon: "Spieler O hat gewonnen.",
                gameOver: "Spiel vorbei",
                theGameIsAlreadyOver: "Das Spiel ist bereits vorbei!",
                youMustPlayInTheIndicatedGrid: "Sie müssen im angegebenen Feld spielen!",
                thisGridIsAlreadyWon: "Dieses Feld ist bereits gewonnen!",
                thisCellIsAlreadyTaken: "Diese Zelle ist bereits belegt!",
                difficultyChangedTo: "Schwierigkeit geändert zu:",
                difficultyNames: {
                    '1': 'Einfach',
                    '4': 'Normal',
                    '8': 'Schwierig'
                },
                yourTurn: "Ihr Zug",
                aiIsThinking: "Die KI denkt nach",
                rule1: "Ultimatives Tic Tac Toe besteht aus 9 kleinen Tic Tac Toe-Rastern, die ein großes Raster bilden.",
                rule2: "Sie müssen in dem kleinen Raster spielen, das der zuletzt gespielten Zelle Ihres Gegners entspricht.",
                rule3: "Beispiel: Wenn Ihr Gegner in der oberen rechten Zelle spielt, müssen Sie im oberen rechten kleinen Raster spielen.",
                rule4: "Wenn Sie zu einem bereits gewonnenen oder vollen Raster geschickt werden, können Sie überall spielen.",
                rule5: "Gewinnen Sie ein kleines Raster, indem Sie drei in einer Reihe bekommen, genau wie beim normalen Tic Tac Toe.",
                rule6: "Gewinnen Sie das Spiel, indem Sie drei Raster in einer Reihe ausrichten.",
                youDefeatedTheAI: "Sie haben die KI auf",
                theAIWon: "Die KI hat auf"
            },
            it: {
                level: "livello",
                title: "Tris Ultimo",
                playAgainstAI: "Gioca contro l'IA",
                localMultiplayer: "Multigiocatore Locale",
                timedMode: "Modalità Cronometrata",
                gameRules: "Regole del Gioco",
                settings: "Impostazioni",
                difficulty: "Difficoltà",
                close: "Chiudi",
                continue: "Continua",
                newGame: "Nuova Partita",
                backToLobby: "Torna alla Lobby",
                language: "Lingua",
                easy: "Facile",
                normal: "Normale",
                difficult: "Difficile",
                youArePlayingAs: "Stai giocando come",
                youGoFirst: "Inizi tu!",
                aiGoesFirst: "L'IA inizia!",
                youWon: "Hai vinto.",
                aiWon: "L'IA ha vinto.",
                playerWon: "Il giocatore ha vinto.",
                gameEndedInDraw: "La partita è finita in parità.",
                playerXRanOutOfTime: "Il giocatore X ha finito il tempo. Il giocatore O vince!",
                playerORanOutOfTime: "Il giocatore O ha finito il tempo. Il giocatore X vince!",
                playerXWon: "Il giocatore X ha vinto.",
                playerOWon: "Il giocatore O ha vinto.",
                gameOver: "Partita finita",
                theGameIsAlreadyOver: "La partita è già finita!",
                youMustPlayInTheIndicatedGrid: "Devi giocare nella griglia indicata!",
                thisGridIsAlreadyWon: "Questa griglia è già stata vinta!",
                thisCellIsAlreadyTaken: "Questa cella è già occupata!",
                difficultyChangedTo: "Difficoltà cambiata in:",
                difficultyNames: {
                    '1': 'Facile',
                    '4': 'Normale',
                    '8': 'Difficile'
                },
                yourTurn: "Il tuo turno",
                aiIsThinking: "L'IA sta pensando",
                rule1: "Tris Ultimo consiste in 9 piccole griglie di Tris, che formano una grande griglia.",
                rule2: "Devi giocare nella griglia corrispondente all'ultima cella giocata dal tuo avversario.",
                rule3: "Esempio: Se il tuo avversario gioca nella cella in alto a destra, devi giocare nella griglia in alto a destra.",
                rule4: "Se sei indirizzato a una griglia già vinta o piena, puoi giocare ovunque.",
                rule5: "Vinci una piccola griglia ottenendo tre in fila, proprio come nel Tris normale.",
                rule6: "Vinci la partita allineando tre griglie.",
                youDefeatedTheAI: "Hai sconfitto l'IA al",
                theAIWon: "L'IA ha vinto al"
            },
            es: {
                level: "nivel",
                title: "Tres en Raya Ultimate",
                playAgainstAI: "Jugar contra la IA",
                localMultiplayer: "Multijugador Local",
                timedMode: "Modo Cronometrado",
                gameRules: "Reglas del Juego",
                settings: "Configuración",
                difficulty: "Dificultad",
                close: "Cerrar",
                continue: "Continuar",
                newGame: "Nuevo Juego",
                backToLobby: "Volver al Lobby",
                language: "Idioma",
                easy: "Fácil",
                normal: "Normal",
                difficult: "Difícil",
                youArePlayingAs: "Estás jugando como",
                youGoFirst: "¡Tú empiezas!",
                aiGoesFirst: "¡La IA empieza!",
                youWon: "Has ganado.",
                aiWon: "La IA ha ganado.",
                playerWon: "El jugador ha ganado.",
                gameEndedInDraw: "El juego terminó en empate.",
                playerXRanOutOfTime: "El jugador X se quedó sin tiempo. ¡El jugador O gana!",
                playerORanOutOfTime: "El jugador O se quedó sin tiempo. ¡El jugador X gana!",
                playerXWon: "El jugador X ha ganado.",
                playerOWon: "El jugador O ha ganado.",
                gameOver: "Juego terminado",
                theGameIsAlreadyOver: "¡El juego ya ha terminado!",
                youMustPlayInTheIndicatedGrid: "¡Debes jugar en la cuadrícula indicada!",
                thisGridIsAlreadyWon: "¡Esta cuadrícula ya ha sido ganada!",
                thisCellIsAlreadyTaken: "¡Esta celda ya está ocupada!",
                difficultyChangedTo: "Dificultad cambiada a:",
                difficultyNames: {
                    '1': 'Fácil',
                    '4': 'Normal',
                    '8': 'Difícil'
                },
                yourTurn: "Tu turno",
                aiIsThinking: "La IA está pensando",
                rule1: "El Tres en Raya Ultimate consiste en 9 pequeñas cuadrículas de Tres en Raya, que forman una cuadrícula grande.",
                rule2: "Debes jugar en la cuadrícula que corresponde a la última celda jugada por tu oponente.",
                rule3: "Ejemplo: Si tu oponente juega en la celda superior derecha, debes jugar en la cuadrícula superior derecha.",
                rule4: "Si eres enviado a una cuadrícula que ya ha sido ganada o está llena, puedes jugar en cualquier lugar.",
                rule5: "Gana una pequeña cuadrícula obteniendo tres en línea, justo como en el Tres en Raya regular.",
                rule6: "Gana el juego alineando tres cuadrículas.",
                youDefeatedTheAI: "Has derrotado a la IA en el",
                theAIWon: "La IA ganó en el"
            },
            ar: {
                level: "مستوى",
                title: "تيك تاك تو النهائي",
                playAgainstAI: "العب ضد الذكاء الاصطناعي",
                localMultiplayer: "اللعب الجماعي المحلي",
                timedMode: "الوضع المؤقت",
                gameRules: "قوانين اللعبة",
                settings: "الإعدادات",
                difficulty: "الصعوبة",
                close: "إغلاق",
                continue: "استمرار",
                newGame: "لعبة جديدة",
                backToLobby: "العودة إلى اللوبي",
                language: "اللغة",
                easy: "سهل",
                normal: "عادي",
                difficult: "صعب",
                youArePlayingAs: "أنت تلعب ك",
                youGoFirst: "أنت تبدأ!",
                aiGoesFirst: "الذكاء الاصطناعي يبدأ!",
                youWon: "لقد فازت.",
                aiWon: "الذكاء الاصطناعي فاز.",
                playerWon: "اللاعب فاز.",
                gameEndedInDraw: "انتهت اللعبة بالتعادل.",
                playerXRanOutOfTime: "نفد الوقت من اللاعب X. اللاعب O يفوز!",
                playerORanOutOfTime: "نفد الوقت من اللاعب O. اللاعب X يفوز!",
                playerXWon: "اللاعب X فاز.",
                playerOWon: "اللاعب O فاز.",
                gameOver: "انتهاء اللعبة",
                theGameIsAlreadyOver: "اللعبة انتهت بالفعل!",
                youMustPlayInTheIndicatedGrid: "يجب أن تلعب في الشبكة المحددة!",
                thisGridIsAlreadyWon: "هذه الشبكة قد فازت بالفعل!",
                thisCellIsAlreadyTaken: "هذه الخلية مشغولة بالفعل!",
                difficultyChangedTo: "تم تغيير الصعوبة إلى:",
                difficultyNames: {
                    '1': 'سهل',
                    '4': 'عادي',
                    '8': 'صعب'
                },
                yourTurn: "دورك",
                aiIsThinking: "الذكاء الاصطناعي يفكر",
                rule1: "تيك تاك تو النهائي يتكون من 9 شبكات صغيرة من تيك تاك تو، تشكل شبكة كبيرة.",
                rule2: "يجب أن تلعب في الشبكة التي تتوافق مع آخر خلية لعبها خصمك.",
                rule3: "مثال: إذا لعب خصمك في الخلية العلوية اليمنى، يجب أن تلعب في الشبكة العلوية اليمنى.",
                rule4: "إذا تم إرسالك إلى شبكة فازت بالفعل أو ممتلئة، يمكنك اللعب في أي مكان.",
                rule5: "افوز بشبكة صغيرة عن طريق الحصول على ثلاثة في صف، مثل تيك تاك تو العادي.",
                rule6: "افوز باللعبة عن طريق محاذاة ثلاث شبكات.",
                youDefeatedTheAI: "لقد هزمت الذكاء الاصطناعي في",
                theAIWon: "الذكاء الاصطناعي فاز في"
            },
            zh: {
                level: "级别",
                title: "终极井字棋",
                playAgainstAI: "与AI对战",
                localMultiplayer: "本地多人游戏",
                timedMode: "计时模式",
                gameRules: "游戏规则",
                settings: "设置",
                difficulty: "难度",
                close: "关闭",
                continue: "继续",
                newGame: "新游戏",
                backToLobby: "返回大厅",
                language: "语言",
                easy: "简单",
                normal: "普通",
                difficult: "困难",
                youArePlayingAs: "你正在扮演",
                youGoFirst: "你先走！",
                aiGoesFirst: "AI先走！",
                youWon: "你赢了。",
                aiWon: "AI赢了。",
                playerWon: "玩家赢了。",
                gameEndedInDraw: "游戏以平局结束。",
                playerXRanOutOfTime: "玩家X时间用完。玩家O赢！",
                playerORanOutOfTime: "玩家O时间用完。玩家X赢！",
                playerXWon: "玩家X赢了。",
                playerOWon: "玩家O赢了。",
                gameOver: "游戏结束",
                theGameIsAlreadyOver: "游戏已经结束！",
                youMustPlayInTheIndicatedGrid: "你必须在指定的网格中玩！",
                thisGridIsAlreadyWon: "这个网格已经赢了！",
                thisCellIsAlreadyTaken: "这个单元格已经被占用！",
                difficultyChangedTo: "难度更改为：",
                difficultyNames: {
                    '1': '简单',
                    '4': '普通',
                    '8': '困难'
                },
                yourTurn: "你的回合",
                aiIsThinking: "AI正在思考",
                rule1: "终极井字棋由9个小井字棋网格组成，形成一个大网格。",
                rule2: "你必须在对应于对手最后一次移动的网格中玩。",
                rule3: "例如，如果对手在其右上角单元格移动，你必须在大网格的右上角网格中移动。",
                rule4: "如果你被发送到一个已经赢或已满的网格，你可以在任何地方玩。",
                rule5: "通过获得三个连成一线来赢得一个小网格，就像普通井字棋一样。",
                rule6: "通过对齐三个网格来赢得游戏。",
                youDefeatedTheAI: "你在级别上击败了AI",
                theAIWon: "AI在级别上赢了"
            },
            ja: {
                level: "レベル",
                title: "最難関パズル",
                playAgainstAI: "AIと対戦",
                localMultiplayer: "ローカルマルチプレイヤー",
                timedMode: "タイムモード",
                gameRules: "ゲームルール",
                settings: "設定",
                difficulty: "難易度",
                close: "閉じる",
                continue: "続ける",
                newGame: "新しいゲーム",
                backToLobby: "ロビーに戻る",
                language: "言語",
                easy: "簡単",
                normal: "普通",
                difficult: "難しい",
                youArePlayingAs: "あなたはとしてプレイしています",
                youGoFirst: "あなたが先に行きます！",
                aiGoesFirst: "AIが先に行きます！",
                youWon: "あなたの勝ちです。",
                aiWon: "AIの勝ちです。",
                playerWon: "プレイヤーの勝ちです。",
                gameEndedInDraw: "ゲームは引き分けで終了しました。",
                playerXRanOutOfTime: "プレイヤーXの時間切れ。プレイヤーOの勝ち！",
                playerORanOutOfTime: "プレイヤーOの時間切れ。プレイヤーXの勝ち！",
                playerXWon: "プレイヤーXの勝ちです。",
                playerOWon: "プレイヤーOの勝ちです。",
                gameOver: "ゲームオーバー",
                theGameIsAlreadyOver: "ゲームは既に終了しています！",
                youMustPlayInTheIndicatedGrid: "指定されたグリッドでプレイする必要があります！",
                thisGridIsAlreadyWon: "このグリッドは既に勝っています！",
                thisCellIsAlreadyTaken: "このセルは既に取られています！",
                difficultyChangedTo: "難易度が変更されました：",
                difficultyNames: {
                    '1': '簡単',
                    '4': '普通',
                    '8': '難しい'
                },
                yourTurn: "あなたのターン",
                aiIsThinking: "AIが考えています",
                rule1: "アルティメット三目並べは、9つの小さな三目並べグリッドで構成され、1つの大きなグリッドを形成します。",
                rule2: "あなたは、相手が最後にプレイしたセルに対応するグリッドでプレイする必要があります。",
                rule3: "例えば、相手が右上のセルでプレイした場合、あなたは大きなグリッドの右上のグリッドでプレイする必要があります。",
                rule4: "既に勝っているか満たされているグリッドに送られた場合、あなたはどこでもプレイできます。",
                rule5: "小さなグリッドに勝つために、通常の三目並べのように3つのシンボルを揃えます。",
                rule6: "ゲームに勝つために、3つのグリッドを揃えます。",
                youDefeatedTheAI: "あなたはレベルでAIに勝利しました",
                theAIWon: "AIはレベルで勝ちました"
            },
            ru: {
                level: "уровень",
                title: "Ультимативные крестики-нолики",
                playAgainstAI: "Играть против ИИ",
                localMultiplayer: "Локальный мультиплеер",
                timedMode: "Режим с таймером",
                gameRules: "Правила игры",
                settings: "Настройки",
                difficulty: "Сложность",
                close: "Закрыть",
                continue: "Продолжить",
                newGame: "Новая игра",
                backToLobby: "Вернуться в лобби",
                language: "Язык",
                easy: "Легко",
                normal: "Нормально",
                difficult: "Сложно",
                youArePlayingAs: "Вы играете за",
                youGoFirst: "Вы ходите первыми!",
                aiGoesFirst: "ИИ ходит первым!",
                youWon: "Вы выиграли.",
                aiWon: "ИИ выиграл.",
                playerWon: "Игрок выиграл.",
                gameEndedInDraw: "Игра закончилась вничью.",
                playerXRanOutOfTime: "У игрока X закончилось время. Игрок O побеждает!",
                playerORanOutOfTime: "У игрока O закончилось время. Игрок X побеждает!",
                playerXWon: "Игрок X победил.",
                playerOWon: "Игрок O победил.",
                gameOver: "Игра окончена",
                theGameIsAlreadyOver: "Игра уже закінчена!",
                youMustPlayInTheIndicatedGrid: "Вы должны играть в указанной сетке!",
                thisGridIsAlreadyWon: "Эта сетка уже выиграна!",
                thisCellIsAlreadyTaken: "Эта ячейка уже занята!",
                difficultyChangedTo: "Сложность изменена на:",
                difficultyNames: {
                    '1': 'Легко',
                    '4': 'Нормально',
                    '8': 'Сложно'
                },
                yourTurn: "Ваш ход",
                aiIsThinking: "ИИ думает",
                rule1: "Ультимативные крестики-нолики состоят из 9 маленьких сеток крестиков-ноликов, образующих одну большую сетку.",
                rule2: "Вы должны играть в сетке, соответствующей последней клетке, в которую сыграл ваш противник.",
                rule3: "Например: если ваш противник играет в правой верхней ячейке, вы должны играть в правой верхней сетке.",
                rule4: "Если вас отправляют в сетку, которая уже выиграна или заполнена, вы можете играть в любой открытой сетке.",
                rule5: "Чтобы выиграть маленькую сетку, выстройте 3 символа в ряд, как в классических крестиках-ноликах.",
                rule6: "Чтобы выиграть игру, выстройте 3 сетки в ряд.",
                youDefeatedTheAI: "Вы победили ИИ на",
                theAIWon: "ИИ победил на"
            },
            sv: {
                level: "nivå",
                title: "Ultimate Tic Tac Toe",
                playAgainstAI: "Spela mot AI",
                localMultiplayer: "Lokal Multiplayer",
                timedMode: "Tidsbegränsat Läge",
                gameRules: "Spelregler",
                settings: "Inställningar",
                difficulty: "Svårighetsgrad",
                close: "Stäng",
                continue: "Fortsätt",
                newGame: "Nytt Spel",
                backToLobby: "Tillbaka till Lobby",
                language: "Språk",
                easy: "Lätt",
                normal: "Normal",
                difficult: "Svår",
                youArePlayingAs: "Du spelar som",
                youGoFirst: "Du börjar!",
                aiGoesFirst: "AI börjar!",
                youWon: "Du vann.",
                aiWon: "AI vann.",
                playerWon: "Spelaren vann.",
                gameEndedInDraw: "Spelet slutade oavgjort.",
                playerXRanOutOfTime: "Spelare X tog slut på tid. Spelare O vinner!",
                playerORanOutOfTime: "Spelare O tog slut på tid. Spelare X vinner!",
                playerXWon: "Spelare X vann.",
                playerOWon: "Spelare O vann.",
                gameOver: "Spel slut",
                theGameIsAlreadyOver: "Spelet är redan över!",
                youMustPlayInTheIndicatedGrid: "Du måste spela i den angivna rutan!",
                thisGridIsAlreadyWon: "Den här rutan är redan vunnen!",
                thisCellIsAlreadyTaken: "Den här cellen är redan tagen!",
                difficultyChangedTo: "Svårighetsgrad ändrad till:",
                difficultyNames: {
                    '1': 'Lätt',
                    '4': 'Normal',
                    '8': 'Svår'
                },
                yourTurn: "Din tur",
                aiIsThinking: "AI tänker",
                rule1: "Ultimate Tic Tac Toe består av 9 mindre Tic Tac Toe-brädor arrangerade i ett stort 3x3-rutnät.",
                rule2: "Du måste spela i den lilla brädet som matchar var din motståndare senast spelade.",
                rule3: "Exempel: Om din motståndare spelar i den övre högra cellen, måste du spela i det övre högra lilla brädet.",
                rule4: "Om du skickas till ett bräde som redan är vunnet eller fullt, kan du spela var som helst.",
                rule5: "Vinn ett litet bräde genom att få tre i rad, precis som vanligt Tic Tac Toe.",
                rule6: "Vinn spelet genom att radera upp tre brädor.",
                youDefeatedTheAI: "Du besegrade AI på",
                theAIWon: "AI vann på"
            },
            hi: {
                level: "स्तर",
                title: "अल्टिमेट टिक टैक टो",
                playAgainstAI: "एआई के खिलाफ खेलें",
                localMultiplayer: "लोकल मल्टीप्लेयर",
                timedMode: "समयबद्ध मोड",
                gameRules: "गेम नियम",
                settings: "सेटिंग्स",
                difficulty: "कठिनाई",
                close: "बंद करें",
                continue: "जारी रखें",
                newGame: "नया खेल",
                backToLobby: "लॉबी पर वापस",
                language: "भाषा",
                easy: "आसान",
                normal: "सामान्य",
                difficult: "कठिन",
                youArePlayingAs: "आप खेल रहे हैं",
                youGoFirst: "आप पहले जाते हैं!",
                aiGoesFirst: "एआई पहले जाता है!",
                youWon: "आप जीत गए।",
                aiWon: "एआई जीत गया।",
                playerWon: "खिलाड़ी जीत गया।",
                gameEndedInDraw: "गेम ड्रॉ पर समाप्त हुआ।",
                playerXRanOutOfTime: "खिलाड़ी X का समय समाप्त हो गया। खिलाड़ी O जीतता है!",
                playerORanOutOfTime: "खिलाड़ी O का समय समाप्त हो गया। खिलाड़ी X जीतता है!",
                playerXWon: "खिलाड़ी X जीत गया।",
                playerOWon: "खिलाड़ी O जीत गया।",
                gameOver: "गेम खत्म",
                theGameIsAlreadyOver: "गेम पहले ही खत्म हो चुका है!",
                youMustPlayInTheIndicatedGrid: "आपको निर्दिष्ट ग्रिड में खेलना चाहिए!",
                thisGridIsAlreadyWon: "यह ग्रिड पहले ही जीत चुका है!",
                thisCellIsAlreadyTaken: "यह सेल पहले ही लिया जा चुका है!",
                difficultyChangedTo: "कठिनाई बदलकर:",
                difficultyNames: {
                    '1': 'आसान',
                    '4': 'सामान्य',
                    '8': 'कठिन'
                },
                yourTurn: "आपकी बारी",
                aiIsThinking: "एआई सोच रहा है",
                rule1: "अल्टिमेट टिक टैक टो 9 छोटे टिक टैक टो बोर्डों से बना होता है जो एक बड़े 3x3 ग्रिड में व्यवस्थित होते हैं।",
                rule2: "आपको उस ग्रिड में खेलना चाहिए जो आपके प्रतिद्वंद्वी के अंतिम खेले गए स्थान से मेल खाता हो।",
                rule3: "उदाहरण: यदि आपका प्रतिद्वंद्वी ऊपर दाएं कोने की सेल में खेलता है, तो आपको ऊपर दाएं ग्रिड में खेलना चाहिए।",
                rule4: "यदि आपको एक ऐसे ग्रिड पर भेजा जाता है जो पहले से जीत चुका है या भर चुका है, तो आप कहीं भी खेल सकते हैं।",
                rule5: "एक छोटे बोर्ड को जीतने के लिए, सामान्य टिक टैक टो की तरह तीन पंक्तियों में प्राप्त करें।",
                rule6: "बड़े बोर्ड पर तीन ग्रिडों को संरेखित करके खेल जीतें।",
                youDefeatedTheAI: "आपने स्तर पर एआई को हराया",
                theAIWon: "एआई ने स्तर पर जीत हासिल की"
            },
            pt: {
                level: "nível",
                title: "Jogo da Velha Ultimate",
                playAgainstAI: "Jogar contra a IA",
                localMultiplayer: "Multijogador Local",
                timedMode: "Modo Cronometrado",
                gameRules: "Regras do Jogo",
                settings: "Configurações",
                difficulty: "Dificuldade",
                close: "Fechar",
                continue: "Continuar",
                newGame: "Novo Jogo",
                backToLobby: "Voltar ao Lobby",
                language: "Idioma",
                easy: "Fácil",
                normal: "Normal",
                difficult: "Difícil",
                youArePlayingAs: "Você está jogando como",
                youGoFirst: "Você começa!",
                aiGoesFirst: "A IA começa!",
                youWon: "Você ganhou.",
                aiWon: "A IA ganhou.",
                playerWon: "O jogador ganhou.",
                gameEndedInDraw: "O jogo terminou em empate.",
                playerXRanOutOfTime: "O jogador X ficou sem tempo. O jogador O ganha!",
                playerORanOutOfTime: "O jogador O ficou sem tempo. O jogador X ganha!",
                playerXWon: "O jogador X ganhou.",
                playerOWon: "O jogador O ganhou.",
                gameOver: "Fim de Jogo",
                theGameIsAlreadyOver: "O jogo já terminou!",
                youMustPlayInTheIndicatedGrid: "Você deve jogar na grade indicada!",
                thisGridIsAlreadyWon: "Esta grade já foi vencida!",
                thisCellIsAlreadyTaken: "Esta célula já está ocupada!",
                difficultyChangedTo: "Dificuldade alterada para:",
                difficultyNames: {
                    '1': 'Fácil',
                    '4': 'Normal',
                    '8': 'Difícil'
                },
                yourTurn: "Sua vez",
                aiIsThinking: "A IA está pensando",
                rule1: "O Jogo da Velha Ultimate é composto por 9 tabuleiros menores de Jogo da Velha, formando um grande tabuleiro 3x3.",
                rule2: "Você deve jogar no tabuleiro que corresponde à última jogada do seu oponente.",
                rule3: "Exemplo: Se o seu oponente jogar na célula superior direita, você deve jogar no tabuleiro superior direito.",
                rule4: "Se você for enviado para um tabuleiro que já foi vencido ou está cheio, você pode jogar em qualquer lugar.",
                rule5: "Ganhe um tabuleiro pequeno alinhando três símbolos, como no Jogo da Velha clássico.",
                rule6: "Ganhe o jogo alinhando três tabuleiros.",
                youDefeatedTheAI: "Você derrotou a IA no",
                theAIWon: "A IA venceu no"
            },
            eu: {
                level: "maila",
                title: "Hiru Lerroren Joko Goratua",
                playAgainstAI: "AIaren aurka jolastu",
                localMultiplayer: "Jokalari Anitz Lokala",
                timedMode: "Denbora Mugatuko Modua",
                gameRules: "Joko Arauak",
                settings: "Ezarpenak",
                difficulty: "Zailtasuna",
                close: "Itxi",
                continue: "Jarraitu",
                newGame: "Joko Berria",
                backToLobby: "Itzuli Lobira",
                language: "Hizkuntza",
                easy: "Erraza",
                normal: "Normala",
                difficult: "Zaila",
                youArePlayingAs: "Honekin jokatzen ari zara",
                youGoFirst: "Zuk hasten du!",
                aiGoesFirst: "AIak hasten du!",
                youWon: "Zuk irabazi duzu.",
                aiWon: "AIak irabazi du.",
                playerWon: "Jokalariak irabazi du.",
                gameEndedInDraw: "Jokoa berdinketa batean amaitu da.",
                playerXRanOutOfTime: "X jokalariak denbora agortu du. O jokalariak irabazten du!",
                playerORanOutOfTime: "O jokalariak denbora agortu du. X jokalariak irabazten du!",
                playerXWon: "X jokalariak irabazi du.",
                playerOWon: "O jokalariak irabazi du.",
                gameOver: "Jokoa Amaitua",
                theGameIsAlreadyOver: "Jokoa jada amaituta dago!",
                youMustPlayInTheIndicatedGrid: "Indikatutako taulan jolastu behar duzu!",
                thisGridIsAlreadyWon: "Taula hau jada irabazita dago!",
                thisCellIsAlreadyTaken: "Kasila hau jada hartuta dago!",
                difficultyChangedTo: "Zailtasun maila hauetara aldatu da:",
                difficultyNames: {
                    '1': 'Erraza',
                    '4': 'Normala',
                    '8': 'Zaila'
                },
                yourTurn: "Zure txanda",
                aiIsThinking: "AIak pentsatzen ari da",
                rule1: "Hiru Lerroren Joko Goratua 3x3 sare handi batean antolatutako 9 Hiru Lerroren Joko txikiz osatuta dago.",
                rule2: "Aurreko jokalariak bere taula txikian egindako azken mugimenduaren arabera, zure mugimendua egin behar duzu taula txiki horretara.",
                rule3: "Adibidea: aurkariak bere taula txikian goiko eskuineko kasillan jokatzen badu, zuek taula handiaren goiko eskuineko taula txikian jokatuko duzue.",
                rule4: "Iada irabazita edo beteta dagoen taula batera bidalita bazaraude, edozein taula libretan jolastu dezakezu.",
                rule5: "Taula txiki bat irabazteko, hiru sinbolo lerroan jarri behar dituzu, Hiru Lerroren Joko klasikoan bezala.",
                rule6: "Jokoa irabazteko, zure hiru taula txiki irabazitakoak lerroan jarri behar dituzu taula handian.",
                youDefeatedTheAI: "Zuk AIa garaitu duzu maila",
                theAIWon: "AIak irabazi du maila"
            },
            uk: {
                level: "рівень",
                title: "Ультимативні хрестики-нулики",
                playAgainstAI: "Грати проти ШІ",
                localMultiplayer: "Локальний мультиплеєр",
                timedMode: "Режим з таймером",
                gameRules: "Правила гри",
                settings: "Налаштування",
                difficulty: "Складність",
                close: "Закрити",
                continue: "Продовжити",
                newGame: "Нова гра",
                backToLobby: "Повернутися до лобі",
                language: "Мова",
                easy: "Легко",
                normal: "Нормально",
                difficult: "Складно",
                youArePlayingAs: "Ви граєте за",
                youGoFirst: "Ви ходите першими!",
                aiGoesFirst: "ШІ ходить першим!",
                youWon: "Ви виграли.",
                aiWon: "ШІ виграв.",
                playerWon: "Гравець виграв.",
                gameEndedInDraw: "Гра закінчилася внічию.",
                playerXRanOutOfTime: "У гравця X закінчився час. Гравець O перемагає!",
                playerORanOutOfTime: "У гравця O закінчився час. Гравець X перемагає!",
                playerXWon: "Гравець X переміг.",
                playerOWon: "Гравець O переміг.",
                gameOver: "Гра закінчена",
                theGameIsAlreadyOver: "Гра вже закінчена!",
                youMustPlayInTheIndicatedGrid: "Ви повинні грати у вказаній сітці!",
                thisGridIsAlreadyWon: "Ця сітка вже виграна!",
                thisCellIsAlreadyTaken: "Ця клітинка вже зайнята!",
                difficultyChangedTo: "Складність змінена на:",
                difficultyNames: {
                    '1': 'Легко',
                    '4': 'Нормально',
                    '8': 'Складно'
                },
                yourTurn: "Ваш хід",
                aiIsThinking: "ШІ думає",
                rule1: "Ультимативні хрестики-нулики складаються з 9 маленьких сіток хрестиків-нуликів, що утворюють одну велику сітку.",
                rule2: "Ви повинні грати в сітці, яка відповідає останній клітинці, в яку зіграв ваш супротивник.",
                rule3: "Приклад: якщо ваш супротивник грає у правій верхній клітинці, ви повинні грати у правій верхній сітці.",
                rule4: "Якщо вас відправлено в сітку, яка вже виграна або заповнена, ви можете грати в будь-якій відкритій сітці.",
                rule5: "Щоб виграти маленьку сітку, вибудовуйте 3 символи в ряд, як у класичних хрестиках-нуликах.",
                rule6: "Щоб виграти гру, вибудовуйте 3 сітки в ряд.",
                youDefeatedTheAI: "Ви перемогли ШІ на",
                theAIWon: "ШІ переміг на"
            }
        };

        // Constantes pour la réutilisation
        const INITIAL_GAME_STATE = {
            view: 'lobby',
            playerId: `player_${Math.random().toString(36).substring(2, 9)}`,
            playerSymbol: null,
            currentTurn: 'X',
            activeBoard: null,
            boardStates: Array(9).fill().map(() => Array(9).fill(null)),
            smallBoardWinners: Array(9).fill(null),
            gameWinner: null,
            tooltipMessage: '',
            tooltipVisible: false,
            gameMode: 'ai',
            playerTimes: {
                X: 60,
                O: 60
            },
            activeTimer: null,
            darkMode: false,
            difficulty: 'medium',
            language: 'en'
        };

        const WIN_PATTERNS = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];

        let gameState = {...INITIAL_GAME_STATE};
        let aiWorker;

        // Helper functions
        function checkWinSmallBoard(board) {
            return WIN_PATTERNS.some(([a, b, c]) =>
                board[a] && board[a] === board[b] && board[a] === board[c]
            );
        }

        function checkWinBigBoard(winners) {
            return WIN_PATTERNS.some(([a, b, c]) =>
                winners[a] && winners[a] !== 'draw' && winners[a] === winners[b] && winners[a] === winners[c]
            );
        }

        function isBoardFull(board) {
            return board.every(cell => cell !== null);
        }

        function isBigBoardFull(winners, boardStates) {
            if (winners.every(winner => winner !== null)) return true;
            return !boardStates.some((board, i) =>
                winners[i] === null && board.some(cell => cell === null)
            );
        }

        function adjustGameBoardSize() {
            const viewportWidth = window.innerWidth;
            const gameBoard = document.querySelector('.game-board');

            if (!gameBoard) return;

            if (viewportWidth < 360) {
                gameBoard.style.maxWidth = '270px';
            } else if (viewportWidth < 400) {
                gameBoard.style.maxWidth = '310px';
            } else if (viewportWidth < 500) {
                gameBoard.style.maxWidth = '390px';
            } else {
                gameBoard.style.maxWidth = '512px';
            }

            const cells = document.querySelectorAll('.cell');
            const smallBoards = document.querySelectorAll('.small-board');

            if (viewportWidth < 360) {
                smallBoards.forEach(board => {
                    board.style.gap = '0px';
                    board.style.padding = '1px';
                });
            } else if (viewportWidth < 400) {
                smallBoards.forEach(board => {
                    board.style.gap = '1px';
                    board.style.padding = '1px';
                });
            }
        }

        function postRenderAdjustments() {
            adjustGameBoardSize();
            const smallBoards = document.querySelectorAll('.small-board');
            smallBoards.forEach((board, index) => {
                if (gameState.activeBoard === index && gameState.smallBoardWinners[index] === null) {
                    const viewportWidth = window.innerWidth;
                    if (viewportWidth < 400) {
                        board.style.transform = 'scale(1.02)';
                        board.style.boxShadow = '0 0 0 2px #fbbf24';
                    }
                }
            });
            ensureSquareCells();
        }

        function ensureSquareCells() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const width = cell.offsetWidth;
                cell.style.height = `${width}px`;
            });
        }

        function showTooltip(message) {
            const lang = gameState.language;
            const translatedMessage = translations[lang][message] || message;
            gameState.tooltipMessage = translatedMessage;
            gameState.tooltipVisible = true;

            const tooltip = document.getElementById('tooltip');
            tooltip.textContent = translatedMessage;
            tooltip.style.display = 'block';
            tooltip.classList.remove('exit');
            tooltip.classList.add('tooltip');

            setTimeout(() => {
                gameState.tooltipVisible = false;
                tooltip.style.display = 'none';
            }, 2000);
        }

        function toggleDarkMode() {
            gameState.darkMode = !gameState.darkMode;
            document.body.classList.toggle('dark', gameState.darkMode);
            document.body.classList.toggle('bg-gray-100', !gameState.darkMode);
            document.body.classList.toggle('bg-gray-900', gameState.darkMode);

            const appDiv = document.getElementById('app');
            appDiv.classList.toggle('bg-gray-100', !gameState.darkMode);
            appDiv.classList.toggle('bg-gray-900', gameState.darkMode);

            renderView();
        }

        function startNewGame(mode = 'ai') {
            const difficultyDropdown = document.getElementById('difficulty');
            const difficulty = mode === 'timed' ? '4' : (difficultyDropdown ? difficultyDropdown.value : gameState.difficulty);
            const darkMode = gameState.darkMode;
            gameState = {...INITIAL_GAME_STATE};
            gameState.darkMode = darkMode;
            gameState.view = 'game';
            gameState.gameMode = mode;
            gameState.difficulty = difficulty;
            gameState.playerSymbol = Math.random() < 0.5 ? 'X' : 'O';

            if (mode === 'timed') {
                gameState.playerTimes = {
                    X: 60,
                    O: 60
                };
            }

            renderView();

            if (mode === 'ai' || mode === 'timed') {
                const modal = renderFirstPlayerModal();
                document.body.appendChild(modal);
            }
        }

        function showRules() {
            gameState.view = 'rules';
            renderView();
        }

        function backToLobby() {
            if (gameState.activeTimer) {
                clearInterval(gameState.activeTimer);
                gameState.activeTimer = null;
            }

            gameState.playerTimes = {
                X: 60,
                O: 60
            };

            const darkMode = gameState.darkMode;
            gameState = {...INITIAL_GAME_STATE};
            gameState.view = 'lobby';
            gameState.preventAIMove = true;
            gameState.darkMode = darkMode;

            // Restaurer la langue depuis localStorage
            const savedLanguage = localStorage.getItem('selectedLanguage');
            if (savedLanguage) {
                gameState.language = savedLanguage;
            }

            renderView();
        }

        function startTimer(player) {
            if (gameState.activeTimer) {
                clearInterval(gameState.activeTimer);
                gameState.activeTimer = null;
            }

            gameState.activeTimer = setInterval(() => {
                if (gameState.playerTimes[player] > 0 && !gameState.gameWinner) {
                    gameState.playerTimes[player]--;
                    renderView();
                } else {
                    clearInterval(gameState.activeTimer);
                    if (!gameState.gameWinner) {
                        gameState.gameWinner = player === 'X' ? 'O' : 'X';
                    }
                    renderView();
                }
            }, 1000);
        }

        function pauseTimer() {
            if (gameState.activeTimer) {
                clearInterval(gameState.activeTimer);
                gameState.activeTimer = null;
            }
        }

        function handleSquareClick(bigIndex, smallIndex) {
            const { gameWinner, gameMode, currentTurn, playerSymbol,
                   activeBoard, smallBoardWinners, boardStates } = gameState;

            if (gameWinner) {
                showTooltip("theGameIsAlreadyOver");
                return;
            }

            if (activeBoard !== null && activeBoard !== bigIndex) {
                showTooltip("youMustPlayInTheIndicatedGrid");
                return;
            }

            if (smallBoardWinners[bigIndex] !== null) {
                showTooltip("thisGridIsAlreadyWon");
                return;
            }

            if (boardStates[bigIndex][smallIndex] !== null) {
                showTooltip("thisCellIsAlreadyTaken");
                return;
            }

            const newBoardStates = JSON.parse(JSON.stringify(boardStates));
            newBoardStates[bigIndex][smallIndex] = currentTurn;

            const newSmallBoardWinners = [...gameState.smallBoardWinners];
            if (checkWinSmallBoard(newBoardStates[bigIndex])) {
                newSmallBoardWinners[bigIndex] = currentTurn;
            } else if (isBoardFull(newBoardStates[bigIndex])) {
                newSmallBoardWinners[bigIndex] = 'draw';
            }

            let nextActiveBoard = smallIndex;
            if (newSmallBoardWinners[smallIndex] !== null) {
                nextActiveBoard = null;
            }

            let newGameWinner = null;
            if (checkWinBigBoard(newSmallBoardWinners)) {
                newGameWinner = currentTurn;
            } else if (isBigBoardFull(newSmallBoardWinners, newBoardStates)) {
                newGameWinner = 'draw';
            }

            gameState = {
                ...gameState,
                boardStates: newBoardStates,
                smallBoardWinners: newSmallBoardWinners,
                currentTurn: currentTurn === 'X' ? 'O' : 'X',
                activeBoard: nextActiveBoard,
                gameWinner: newGameWinner,
                lastMove: { bigIndex, smallIndex }
            };

            renderView();

            if (gameMode === 'timed') {
                pauseTimer();
                if (!newGameWinner) {
                    startTimer(gameState.currentTurn);
                }
            }

            if ((gameMode === 'ai' || gameMode === 'timed') && !newGameWinner && gameState.currentTurn !== playerSymbol) {
                setTimeout(() => simulateOpponentMove(), 1000);
            }
        }

        function simulateOpponentMove() {
            if (gameState.preventAIMove) {
                return;
            }
            const { activeBoard, boardStates, smallBoardWinners, currentTurn, difficulty, gameMode } = gameState;
            const opponentSymbol = currentTurn;
            const playerSymbol = opponentSymbol === 'X' ? 'O' : 'X';

            let maxDepth;
            switch (difficulty) {
                case '1':
                    maxDepth = 1;
                    break;
                case '4':
                    maxDepth = 4;
                    break;
                case '8':
                    maxDepth = 8;
                    break;
                default:
                    maxDepth = 4;
            }

            const isFirstMove = boardStates.every(board => board.every(cell => cell === null));

            if (isFirstMove) {
                const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
                if (validMoves.length > 0) {
                    const [bigIndex, smallIndex] = validMoves[Math.floor(Math.random() * validMoves.length)];
                    const delay = gameMode === 'timed' ? 900 : 0;
                    setTimeout(() => handleSquareClick(bigIndex, smallIndex), delay);
                    return;
                }
            }

            if (!aiWorker) {
                aiWorker = new Worker('aiWorker.js');
            }

            aiWorker.onmessage = function(e) {
                const bestMove = e.data;
                if (bestMove) {
                    const delay = gameMode === 'timed' ? 900 : 0;
                    setTimeout(() => handleSquareClick(bestMove[0], bestMove[1]), delay);
                } else {
                    const validMoves = findValidMoves(activeBoard, boardStates, smallBoardWinners);
                    if (validMoves.length > 0) {
                        const [bigIndex, smallIndex] = validMoves[Math.floor(Math.random() * validMoves.length)];
                        const delay = gameMode === 'timed' ? 900 : 0;
                        setTimeout(() => handleSquareClick(bigIndex, smallIndex), delay);
                    }
                }
            };

            aiWorker.postMessage({
                activeBoard,
                boardStates,
                smallBoardWinners,
                aiSymbol: opponentSymbol,
                playerSymbol,
                depth: maxDepth
            });
        }

        function findValidMoves(activeBoard, boardStates, smallBoardWinners) {
            const validMoves = [];

            if (activeBoard === null || smallBoardWinners[activeBoard] !== null) {
                for (let i = 0; i < 9; i++) {
                    if (smallBoardWinners[i] === null) {
                        for (let j = 0; j < 9; j++) {
                            if (boardStates[i][j] === null) {
                                validMoves.push([i, j]);
                            }
                        }
                    }
                }
            } else {
                for (let j = 0; j < 9; j++) {
                    if (boardStates[activeBoard][j] === null) {
                        validMoves.push([activeBoard, j]);
                    }
                }
            }

            return validMoves;
        }

        function renderCell(bigIndex, smallIndex) {
            const { boardStates, gameMode, playerSymbol, currentTurn,
                   activeBoard, smallBoardWinners, darkMode, lastMove } = gameState;

            const value = boardStates[bigIndex][smallIndex];
            const theme = darkMode ? 'dark' : 'light';

            let cellClass = "cell ";

            if (value === null) {
                const isInteractive = (gameMode === 'ai' || gameMode === 'timed') && playerSymbol === currentTurn || gameMode === 'local';
                const isValidTarget = (activeBoard === null || activeBoard === bigIndex) && smallBoardWinners[bigIndex] === null;

                cellClass += theme === 'dark' ? 'bg-gray-800 ' : 'bg-white ';

                if (isInteractive && isValidTarget) {
                    cellClass += theme === 'dark' ? 'hover:bg-gray-600 ' : 'hover:bg-blue-100 ';
                    cellClass += 'valid';
                }
            } else {
                cellClass += theme === 'dark' ? 'bg-gray-800 ' : 'bg-white ';
            }

            const cell = document.createElement('div');
            cell.className = cellClass;

            if (value) {
                const symbol = document.createElement('span');
                symbol.className = `symbol ${value === 'X' ? 'text-red-500 font-bold' : 'text-blue-500 font-bold'} ${lastMove && lastMove.bigIndex === bigIndex && lastMove.smallIndex === smallIndex ? 'enhanced-bounce' : ''}`;
                symbol.textContent = value;

                if (lastMove && lastMove.bigIndex === bigIndex && lastMove.smallIndex === smallIndex) {
                    setTimeout(() => {
                        symbol.classList.remove('enhanced-bounce');
                    }, 700);
                }

                cell.appendChild(symbol);
            }

            const columnPosition = smallIndex % 3;
            cell.dataset.column = columnPosition;
            cell.dataset.row = Math.floor(smallIndex / 3);

            if (cellClass.includes('valid')) {
                cell.addEventListener('click', () => handleSquareClick(bigIndex, smallIndex));
            }

            return cell;
        }

        function renderSmallBoard(index) {
            const { activeBoard, smallBoardWinners, darkMode } = gameState;
            const winner = smallBoardWinners[index];
            const theme = darkMode ? 'dark' : 'light';
            const viewportWidth = window.innerWidth;

            const boardDiv = document.createElement('div');
            boardDiv.className = `small-board ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`;

            boardDiv.style.display = 'grid';
            boardDiv.style.gridTemplateColumns = 'repeat(3, 1fr)';
            boardDiv.style.gridTemplateRows = 'repeat(3, 1fr)';

            if (activeBoard === index && winner === null) {
                boardDiv.classList.add('active');
                if (viewportWidth < 400) {
                    boardDiv.style.transform = 'scale(1.02)';
                    boardDiv.style.boxShadow = `0 0 0 2px ${theme === 'dark' ? '#f59e0b' : '#fbbf24'}`;
                } else {
                    boardDiv.style.boxShadow = `0 0 0 4px ${theme === 'dark' ? '#f59e0b' : '#fbbf24'}`;
                }
            }

            if (winner !== null) {
                if (winner === 'draw') {
                    boardDiv.classList.add('draw');
                } else {
                    boardDiv.classList.add(winner === 'X' ? 'won-x' : 'won-o');
                }
            }

            if (winner !== null && winner !== 'draw') {
                const winnerOverlay = document.createElement('div');
                winnerOverlay.className = 'winner-overlay';

                const symbol = document.createElement('span');
                symbol.className = winner === 'X' ? 'text-red-500' : 'text-blue-500';
                symbol.textContent = winner;

                winnerOverlay.appendChild(symbol);
                boardDiv.appendChild(winnerOverlay);
            } else {
                for (let i = 0; i < 9; i++) {
                    boardDiv.appendChild(renderCell(index, i));
                }
            }

            return boardDiv;
        }

        function renderGameBoard() {
            const { darkMode } = gameState;
            const theme = darkMode ? 'dark' : 'light';

            const boardContainer = document.createElement('div');
            boardContainer.className = `game-board ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-300'}`;

            boardContainer.style.display = 'grid';
            boardContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
            boardContainer.style.gridTemplateRows = 'repeat(3, 1fr)';

            const viewportWidth = window.innerWidth;
            if (viewportWidth < 360) {
                boardContainer.style.gap = '4px';
                boardContainer.style.padding = '4px';
            } else if (viewportWidth < 400) {
                boardContainer.style.gap = '6px';
                boardContainer.style.padding = '6px';
            } else if (viewportWidth < 512) {
                boardContainer.style.gap = '8px';
                boardContainer.style.padding = '8px';
            } else {
                boardContainer.style.gap = '16px';
                boardContainer.style.padding = '16px';
            }

            for (let i = 0; i < 9; i++) {
                boardContainer.appendChild(renderSmallBoard(i));
            }

            return boardContainer;
        }

        function renderGameInfo() {
            const { gameMode, currentTurn, playerSymbol, darkMode, playerTimes } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = gameState.language;

            const infoDiv = document.createElement('div');
            infoDiv.className = `game-info ${theme === 'dark' ? 'text-white' : 'text-gray-900'}`;

            const header = document.createElement('div');
            header.className = 'game-info-header header-responsive';

            const modeTitleContainer = document.createElement('div');
            modeTitleContainer.className = 'mode-title-container';
            modeTitleContainer.style.padding = '8px';
            modeTitleContainer.style.borderRadius = '8px';
            modeTitleContainer.style.display = 'inline-block';
            modeTitleContainer.style.backgroundColor = darkMode ? '#4b5563' : '#d1d5db';

            const modeTitle = document.createElement('h2');
            modeTitle.className = 'text-2xl font-bold';
            modeTitle.textContent = gameMode === 'ai' ? translations[lang].playAgainstAI : gameMode === 'local' ? translations[lang].localMultiplayer : translations[lang].timedMode;
            modeTitleContainer.appendChild(modeTitle);

            const settingsBtn = document.createElement('button');
            settingsBtn.className = 'p-2 rounded-full';
            settingsBtn.style.position = 'absolute';
            settingsBtn.style.left = '0';
            settingsBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            settingsBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            settingsBtn.textContent = '⚙️';
            settingsBtn.addEventListener('click', () => {
                const modal = renderSettingsModal();
                document.body.appendChild(modal);
            });

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'p-2 rounded-full';
            toggleBtn.style.position = 'absolute';
            toggleBtn.style.right = '0';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);

            header.appendChild(settingsBtn);
            header.appendChild(modeTitleContainer);
            header.appendChild(toggleBtn);
            infoDiv.appendChild(header);

            if (gameMode === 'timed') {
                const timers = document.createElement('div');
                timers.className = 'player-info';

                const timerXContainer = document.createElement('div');
                timerXContainer.className = `player-box ${currentTurn === 'X' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                timerXContainer.innerHTML = `<span class="text-red-500 font-bold">${playerSymbol === 'X' ? '👤' : '🤖'} X : ${playerTimes.X}s</span>`;

                const timerOContainer = document.createElement('div');
                timerOContainer.className = `player-box ${currentTurn === 'O' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                timerOContainer.innerHTML = `<span class="text-blue-500 font-bold">${playerSymbol === 'O' ? '👤' : '🤖'} O : ${playerTimes.O}s</span>`;

                timers.appendChild(timerXContainer);
                timers.appendChild(timerOContainer);
                infoDiv.appendChild(timers);
            } else if (gameMode === 'local') {
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';

                const playerX = document.createElement('div');
                playerX.className = `player-box ${currentTurn === 'X' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerX.innerHTML = `<span class="text-red-500 font-bold">X</span>${currentTurn === 'X' ? ' - ' + translations[lang].yourTurn : ''}`;

                const playerO = document.createElement('div');
                playerO.className = `player-box ${currentTurn === 'O' ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerO.innerHTML = `<span class="text-blue-500 font-bold">O</span>${currentTurn === 'O' ? ' - ' + translations[lang].yourTurn : ''}`;

                playerInfo.appendChild(playerX);
                playerInfo.appendChild(playerO);
                infoDiv.appendChild(playerInfo);
            } else if (gameMode === 'ai') {
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';

                const playerSymbolElement = document.createElement('div');
                playerSymbolElement.className = `player-box ${currentTurn === playerSymbol ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                playerSymbolElement.innerHTML = `<span class="${playerSymbol === 'X' ? 'text-red-500' : 'text-blue-500'} font-bold">${playerSymbol === 'X' ? '👤 X' : '👤 O'}</span>${currentTurn === playerSymbol ? ' - ' + translations[lang].yourTurn : ''}`;

                const aiSymbolElement = document.createElement('div');
                aiSymbolElement.className = `player-box ${currentTurn !== playerSymbol ? (theme === 'dark' ? 'bg-blue-900 zoom' : 'bg-blue-100 zoom') : (theme === 'dark' ? 'bg-gray-700' : 'bg-gray-100')}`;
                aiSymbolElement.innerHTML = `<span class="${playerSymbol === 'X' ? 'text-blue-500' : 'text-red-500'} font-bold">🤖 ${playerSymbol === 'X' ? 'O' : 'X'}</span>${currentTurn !== playerSymbol ? ' - ' + translations[lang].aiIsThinking : ''}`;

                playerInfo.appendChild(playerSymbolElement);
                playerInfo.appendChild(aiSymbolElement);
                infoDiv.appendChild(playerInfo);
            }

            const controls = document.createElement('div');
            controls.className = 'mt-4 flex justify-center gap-2';

            const newGameBtn = document.createElement('button');
            newGameBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600';
            newGameBtn.textContent = translations[lang].newGame;
            newGameBtn.addEventListener('click', () => {
                if (gameState.gameMode === 'timed') {
                    pauseTimer();
                }
                startNewGame(gameState.gameMode);
            });

            const lobbyBtn = document.createElement('button');
            lobbyBtn.className = 'bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600';
            lobbyBtn.textContent = translations[lang].backToLobby;
            lobbyBtn.addEventListener('click', backToLobby);

            controls.appendChild(newGameBtn);
            controls.appendChild(lobbyBtn);
            infoDiv.appendChild(controls);

            return infoDiv;
        }

        function renderTurnIndicator() {
            return document.createElement('div');
        }

        function renderGameOverModal() {
            const { gameWinner, gameMode, playerSymbol, darkMode, difficulty, playerTimes, language } = gameState;

            if (!gameWinner) return null;

            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            let message = "";
            let iconSymbol = "";
            let additionalInfo = "";

            const difficultyName = translations[lang].difficultyNames[difficulty] || translations[lang].difficult;

            if (gameWinner === 'draw') {
                message = translations[lang].gameEndedInDraw;
                iconSymbol = "🤝";
                additionalInfo = "";
            } else if (gameMode === 'ai') {
                message = gameWinner === playerSymbol ? translations[lang].youWon : translations[lang].aiWon;
                iconSymbol = gameWinner === playerSymbol ? "🏆" : "🤖";
                additionalInfo = gameWinner === playerSymbol ? `${translations[lang].youDefeatedTheAI} ${translations[lang].level} ${difficultyName}.` : `${translations[lang].theAIWon} ${translations[lang].level} ${difficultyName}.`;
            } else if (gameMode === 'timed') {
                if (playerTimes.X <= 0 || playerTimes.O <= 0) {
                    message = gameWinner === 'X' ? translations[lang].playerORanOutOfTime : translations[lang].playerXRanOutOfTime;
                    iconSymbol = gameWinner === 'X' ? "❌" : "⭕";
                    additionalInfo = "";
                } else {
                    message = `${translations[lang].playerWon} ${gameWinner}.`;
                    iconSymbol = gameWinner === 'X' ? "❌" : "⭕";
                    additionalInfo = `${gameWinner} ${translations[lang].playerPlayedWell}.`;
                }
            } else {
                message = `${translations[lang].playerWon} ${gameWinner}.`;
                iconSymbol = gameWinner === 'X' ? "❌" : "⭕";
                additionalInfo = `${gameWinner} ${translations[lang].playerPlayedWell}.`;
            }

            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';

            const modal = document.createElement('div');
            modal.className = `modal-content ${theme === 'dark' ? 'bg-gray-800 text-white border-gray-700' : 'bg-white text-gray-900 border-gray-300'} border`;

            const header = document.createElement('div');
            header.className = 'modal-header';

            const icon = document.createElement('div');
            icon.className = 'text-5xl mb-4';
            icon.textContent = iconSymbol;

            const title = document.createElement('h2');
            title.className = 'text-2xl font-bold mb-2';
            title.textContent = message;

            const info = document.createElement('p');
            info.className = 'text-lg mb-4';
            info.textContent = additionalInfo;

            header.appendChild(icon);
            header.appendChild(title);
            header.appendChild(info);

            const buttons = document.createElement('div');
            buttons.className = window.innerWidth < 400 ? 'modal-buttons flex flex-col gap-2' : 'modal-buttons flex gap-2';

            const newGameBtn = document.createElement('button');
            newGameBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1';
            newGameBtn.textContent = translations[lang].newGame;
            newGameBtn.addEventListener('click', () => {
                closeMessage(overlay);
                startNewGame(gameMode);
            });

            const lobbyBtn = document.createElement('button');
            lobbyBtn.className = 'bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 flex-1';
            lobbyBtn.textContent = translations[lang].backToLobby;
            lobbyBtn.addEventListener('click', () => {
                closeMessage(overlay);
                backToLobby();
            });

            buttons.appendChild(newGameBtn);
            buttons.appendChild(lobbyBtn);

            modal.appendChild(header);
            modal.appendChild(buttons);
            overlay.appendChild(modal);

            return overlay;
        }

        function renderLobbyView() {
            const { darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const lobby = document.createElement('div');
            lobby.className = `lobby-view ${theme === 'dark' ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`;

            const header = document.createElement('div');
            header.className = 'header-responsive mb-4';

            const title = document.createElement('h1');
            title.className = 'text-2xl font-bold title-responsive';
            title.textContent = translations[lang].title;

            const settingsBtn = document.createElement('button');
            settingsBtn.className = 'p-2 rounded-full';
            settingsBtn.style.position = 'absolute';
            settingsBtn.style.left = '0';
            settingsBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            settingsBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            settingsBtn.textContent = '⚙️';
            settingsBtn.addEventListener('click', () => {
                const modal = renderSettingsModal();
                document.body.appendChild(modal);
            });

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'p-2 rounded-full';
            toggleBtn.style.position = 'absolute';
            toggleBtn.style.right = '0';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);

            header.appendChild(settingsBtn);
            header.appendChild(title);
            header.appendChild(toggleBtn);
            lobby.appendChild(header);

            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'flex flex-col gap-4';

            const firstRow = document.createElement('div');
            firstRow.className = 'flex flex-col gap-2';

            const aiBtn = document.createElement('button');
            aiBtn.className = 'bg-green-500 text-white px-4 py-3 rounded-lg hover:bg-green-600 text-lg flex items-center justify-center gap-2';
            aiBtn.innerHTML = '<span>🤖</span> ' + translations[lang].playAgainstAI;
            aiBtn.addEventListener('click', () => startNewGame('ai'));

            const difficultySelector = document.createElement('div');
            difficultySelector.className = 'difficulty-selector';

            const difficultyLabel = document.createElement('label');
            difficultyLabel.setAttribute('for', 'difficulty');
            difficultyLabel.textContent = translations[lang].difficulty + ':';

            const difficultyDropdown = document.createElement('select');
            difficultyDropdown.id = 'difficulty';
            difficultyDropdown.className = 'difficulty-dropdown';

            const easyOption = document.createElement('option');
            easyOption.value = '1';
            easyOption.textContent = translations[lang].easy;

            const mediumOption1 = document.createElement('option');
            mediumOption1.value = '4';
            mediumOption1.textContent = translations[lang].normal;
            mediumOption1.selected = true;

            const mediumOption2 = document.createElement('option');
            mediumOption2.value = '8';
            mediumOption2.textContent = translations[lang].difficult;

            difficultyDropdown.appendChild(easyOption);
            difficultyDropdown.appendChild(mediumOption1);
            difficultyDropdown.appendChild(mediumOption2);

            difficultySelector.appendChild(difficultyLabel);
            difficultySelector.appendChild(difficultyDropdown);

            firstRow.appendChild(aiBtn);
            firstRow.appendChild(difficultySelector);

            const secondRow = document.createElement('div');
            secondRow.className = 'flex flex-col gap-2';

            const multiplayerBtn = document.createElement('button');
            multiplayerBtn.className = 'bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 text-lg flex items-center justify-center gap-2';
            multiplayerBtn.innerHTML = '<span>👥</span> ' + translations[lang].localMultiplayer;
            multiplayerBtn.addEventListener('click', () => startNewGame('local'));

            const timedBtn = document.createElement('button');
            timedBtn.className = 'bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 text-lg flex items-center justify-center gap-2';
            timedBtn.innerHTML = '<span>⏱️</span> ' + translations[lang].timedMode;
            timedBtn.addEventListener('click', () => startNewGame('timed'));

            secondRow.appendChild(multiplayerBtn);
            secondRow.appendChild(timedBtn);

            const rulesBtn = document.createElement('button');
            rulesBtn.className = `${theme === 'dark' ? 'bg-gray-700 text-gray-200' : 'bg-gray-200 text-gray-800'} px-4 py-2 rounded ${theme === 'dark' ? 'hover:bg-gray-600' : 'hover:bg-gray-300'} mt-2`;
            rulesBtn.textContent = translations[lang].gameRules;
            rulesBtn.addEventListener('click', showRules);

            buttonContainer.appendChild(firstRow);
            buttonContainer.appendChild(secondRow);
            buttonContainer.appendChild(rulesBtn);
            lobby.appendChild(buttonContainer);

            difficultyDropdown.addEventListener('change', function() {
                gameState.difficulty = this.value;
                showTooltip(`${translations[lang].difficultyChangedTo} ${this.value}`);
            });

            return lobby;
        }

        function renderSettingsModal() {
            const { darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const overlay = document.createElement('div');
            overlay.className = 'settings-modal-overlay';

            const modal = document.createElement('div');
            modal.className = `settings-modal-content ${theme === 'dark' ? 'bg-gray-800 text-white border-gray-700' : 'bg-white text-gray-900 border-gray-300'} border`;

            const header = document.createElement('div');
            header.className = 'settings-modal-header';

            const title = document.createElement('h2');
            title.className = 'text-2xl font-bold mb-2';
            title.textContent = translations[lang].settings;

            const settingsContent = document.createElement('div');
            settingsContent.className = 'mb-4';

            const languageSelector = document.createElement('div');
            languageSelector.className = 'language-selector';

            const languageLabel = document.createElement('label');
            languageLabel.setAttribute('for', 'language');
            languageLabel.textContent = translations[lang].language + ': ';

            const languageDropdown = document.createElement('select');
            languageDropdown.id = 'language';
            languageDropdown.className = 'language-dropdown';

            const languages = [
                { code: 'ar', name: 'العربية (Arabic)' },
                { code: 'de', name: 'Deutsch (German)' },
                { code: 'en', name: 'English' },
                { code: 'es', name: 'Español (Spanish)' },
                { code: 'eu', name: 'Euskara (Basque)' },
                { code: 'fr', name: 'Français (French)' },
                { code: 'hi', name: 'हिन्दी (Hindi)' },
                { code: 'it', name: 'Italiano (Italian)' },
                { code: 'ja', name: '日本語 (Japanese)' },
                { code: 'pt', name: 'Português (Portuguese)' },
                { code: 'ru', name: 'Русский (Russian)' },
                { code: 'sv', name: 'Svenska (Swedish)' },
                { code: 'uk', name: 'Українська (Ukrainian)' },
                { code: 'zh', name: '中文 (Chinese)' }
            ];

            languages.sort((a, b) => a.name.localeCompare(b.name));

            languages.forEach(langOption => {
                const option = document.createElement('option');
                option.value = langOption.code;
                option.textContent = langOption.name;
                if (langOption.code === language) {
                    option.selected = true;
                }
                languageDropdown.appendChild(option);
            });

            languageDropdown.addEventListener('change', function() {
                gameState.language = this.value;
                localStorage.setItem('selectedLanguage', this.value);
                renderView();
            });

            languageSelector.appendChild(languageLabel);
            languageSelector.appendChild(languageDropdown);
            settingsContent.appendChild(languageSelector);

            header.appendChild(title);
            modal.appendChild(header);
            modal.appendChild(settingsContent);

            const buttons = document.createElement('div');
            buttons.className = 'settings-modal-buttons';

            const closeBtn = document.createElement('button');
            closeBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1';
            closeBtn.textContent = translations[lang].close;
            closeBtn.addEventListener('click', () => {
                closeMessage(overlay);
            });

            buttons.appendChild(closeBtn);
            modal.appendChild(buttons);
            overlay.appendChild(modal);

            return overlay;
        }

        function renderRulesView() {
            const { darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const rules = [
                translations[lang].rule1,
                translations[lang].rule2,
                translations[lang].rule3,
                translations[lang].rule4,
                translations[lang].rule5,
                translations[lang].rule6
            ];

            const rulesView = document.createElement('div');
            rulesView.className = `rules-view ${theme === 'dark' ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`;

            const header = document.createElement('div');
            header.className = 'relative mb-4';

            const title = document.createElement('h1');
            title.className = 'text-xl font-bold text-center';
            title.textContent = translations[lang].gameRules;

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'p-2 rounded-full absolute right-0 top-0';
            toggleBtn.style.backgroundColor = darkMode ? '#374151' : '#e5e7eb';
            toggleBtn.style.color = darkMode ? '#e5e7eb' : '#1f2937';
            toggleBtn.textContent = darkMode ? '☀️' : '🌙';
            toggleBtn.addEventListener('click', toggleDarkMode);

            header.appendChild(title);
            header.appendChild(toggleBtn);
            rulesView.appendChild(header);

            const rulesList = document.createElement('div');
            rulesList.className = `space-y-4 mb-6 border-t ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'} pt-4`;

            rules.forEach((rule, index) => {
                const ruleItem = document.createElement('div');
                ruleItem.className = 'flex gap-3';

                const number = document.createElement('div');
                number.className = 'text-2xl';
                number.textContent = `${index + 1}️⃣`;

                const text = document.createElement('p');
                text.textContent = rule;

                ruleItem.appendChild(number);
                ruleItem.appendChild(text);
                rulesList.appendChild(ruleItem);
            });

            rulesView.appendChild(rulesList);

            const backBtn = document.createElement('button');
            backBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 w-full';
            backBtn.textContent = translations[lang].backToLobby;
            backBtn.addEventListener('click', backToLobby);

            rulesView.appendChild(backBtn);

            return rulesView;
        }

        function renderGameView() {
            const container = document.createElement('div');

            container.appendChild(renderGameInfo());
            container.appendChild(renderGameBoard());
            container.appendChild(renderTurnIndicator());

            const modal = renderGameOverModal();
            if (modal && !document.querySelector('.modal-overlay')) {
                container.appendChild(modal);
            }

            return container;
        }

        function renderFirstPlayerModal() {
            const { playerSymbol, darkMode, language } = gameState;
            const theme = darkMode ? 'dark' : 'light';
            const lang = language;

            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';

            const modal = document.createElement('div');
            modal.className = `modal-content ${theme === 'dark' ? 'bg-gray-800 text-white border-gray-700' : 'bg-white text-gray-900 border-gray-300'} border`;

            const header = document.createElement('div');
            header.className = 'modal-header';

            const icon = document.createElement('div');
            icon.className = 'text-5xl mb-4';
            icon.textContent = playerSymbol === 'X' ? '❌' : '⭕';

            const title = document.createElement('h2');
            title.className = 'text-xl font-bold mb-2';
            title.textContent = `${translations[lang].youArePlayingAs} ${playerSymbol}`;

            const info = document.createElement('p');
            info.className = 'text-lg mb-4';
            info.textContent = playerSymbol === 'X' ? translations[lang].youGoFirst : translations[lang].aiGoesFirst;

            header.appendChild(icon);
            header.appendChild(title);
            header.appendChild(info);

            const buttons = document.createElement('div');
            buttons.className = 'modal-buttons flex gap-2';

            const continueBtn = document.createElement('button');
            continueBtn.className = 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex-1';
            continueBtn.textContent = translations[lang].continue;
            continueBtn.addEventListener('click', () => {
                closeMessage(overlay);
                if (playerSymbol === 'O') {
                    setTimeout(() => simulateOpponentMove(), 1000);
                } else if (gameState.gameMode === 'timed') {
                    if (gameState.activeTimer) {
                        clearInterval(gameState.activeTimer);
                        gameState.activeTimer = null;
                    }
                    startTimer(playerSymbol);
                }
            });

            buttons.appendChild(continueBtn);
            modal.appendChild(header);
            modal.appendChild(buttons);
            overlay.appendChild(modal);

            return overlay;
        }

        function closeMessage(element) {
            element.classList.add('exit');
            setTimeout(() => {
                element.remove();
            }, 100);
        }

        function renderView() {
            const appContainer = document.querySelector('#app .container');
            appContainer.innerHTML = '';

            // Restaurer la langue depuis localStorage
            const savedLanguage = localStorage.getItem('selectedLanguage');
            if (savedLanguage) {
                gameState.language = savedLanguage;
            }

            document.body.classList.toggle('dark', gameState.darkMode);

            switch (gameState.view) {
                case 'lobby':
                    appContainer.appendChild(renderLobbyView());
                    break;
                case 'rules':
                    appContainer.appendChild(renderRulesView());
                    break;
                case 'game':
                    appContainer.appendChild(renderGameView());
                    setTimeout(postRenderAdjustments, 0);
                    break;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const savedLanguage = localStorage.getItem('selectedLanguage');
            if (savedLanguage) {
                gameState.language = savedLanguage;
            }
            renderView();
            adjustGameBoardSize();

            window.addEventListener('resize', () => {
                adjustGameBoardSize();
            });
        });
    </script>
</body>
</html>
